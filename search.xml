<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>redis-dict</title>
    <url>/posts/1350d72f/</url>
    <content><![CDATA[<p>redis作为key-value数据库字典在其中被大量的使用，如redis的数据库就是使用字典来作为底层实现的，对数据库的增、删、改、查操作都是建立在对字典的操作之上的。</p>
<p>本节源码可见:</p>
<p><a href="https://github.com/wxl2/my-redis/blob/main/test/test_dict.c">https://github.com/wxl2/my-redis/blob/main/test/test_dict.c</a></p>
<p><a href="https://github.com/wxl2/my-redis/blob/main/base/dict.c">https://github.com/wxl2/my-redis/blob/main/base/dict.c</a></p>
<p><a href="https://github.com/wxl2/my-redis/blob/main/base/dict.h">https://github.com/wxl2/my-redis/blob/main/base/dict.h</a></p>
<a id="more"></a>

<h4 id="总体结构"><a href="#总体结构" class="headerlink" title="总体结构"></a>总体结构</h4><p>redis使用三个结构体来构建字典，三者之间的关系如图：<img src="/images/dict.png" alt="dict.png"></p>
<h5 id="dictEntry"><a href="#dictEntry" class="headerlink" title="dictEntry"></a>dictEntry</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">        <span class="keyword">double</span> d;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;<span class="comment">//64位机器，sizeof(dictEntry) == 24</span></span><br></pre></td></tr></table></figure>

<p>dictEntry是dict中保存k-v键值对的节点，使用一个union联合体来保存值，其中next指针的作用是用来解决hash冲突，也就是拉链法。</p>
<h5 id="dictht"><a href="#dictht" class="headerlink" title="dictht"></a>dictht</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    <span class="comment">//哈希表数组</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="comment">//哈希表大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line">    <span class="comment">//哈希表大小掩码，用于计算索引值，总是等于size-1</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line">    <span class="comment">//该哈希表已有的节点的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure>

<p>dictht结构体用于保存哈希表其中二级指针table指向真正的hash table，因为哈希表的特性所以table是一个由dictEntry*构成的数组。对于sizemask，其值总是等于size-1（rehash时会被改变），并且和哈希值一起决定一个键应该被放在table数组的哪个索引上<code>idx = hash &amp; d-&gt;ht[table].sizemask</code>。</p>
<h5 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    <span class="comment">//操作字典的函数指针结构体</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="comment">//保存需要传给那些类型特定函数的可选参数</span></span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">//如果rehashidx不等于-1,则表示正在进行rehash操作</span></span><br><span class="line">    <span class="keyword">long</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> iterators; <span class="comment">/* number of iterators currently running */</span></span><br><span class="line">&#125; dict;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line">    <span class="comment">//计算哈希值的值的函数</span></span><br><span class="line">    <span class="keyword">uint64_t</span> (*hashFunction)(<span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="comment">//复制键的函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*keyDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="comment">//复制值的函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*valDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *obj);</span><br><span class="line">    <span class="comment">//比较键的函数</span></span><br><span class="line">    <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2);</span><br><span class="line">    <span class="comment">//析构键的函数</span></span><br><span class="line">    <span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="comment">//析构值的函数</span></span><br><span class="line">    <span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *obj);</span><br><span class="line">&#125; dictType;</span><br></pre></td></tr></table></figure>

<p>ht是一个包含两个dictht结构体的数组，一般情况只使用ht[0]，ht[1]仅在rehash时使用</p>
<h4 id="操作API"><a href="#操作API" class="headerlink" title="操作API"></a>操作API</h4><p>代码可见：<a href="https://github.com/wxl2/my-redis/blob/main/test/test_dict.c">test_dict</a></p>
<h5 id="dictCreate—构建一个字典"><a href="#dictCreate—构建一个字典" class="headerlink" title="dictCreate—构建一个字典"></a>dictCreate—构建一个字典</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*首先设置一系列回调*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">hashCallback</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dictGenHashFunction((<span class="keyword">unsigned</span> <span class="keyword">char</span>*)key, sdslen((<span class="keyword">char</span>*)key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compareCallback</span><span class="params">(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l1,l2;</span><br><span class="line">    DICT_NOTUSED(privdata);</span><br><span class="line"></span><br><span class="line">    l1 = sdslen((sds)key1);</span><br><span class="line">    l2 = sdslen((sds)key2);</span><br><span class="line">    <span class="keyword">if</span> (l1 != l2) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">memcmp</span>(key1, key2, l1) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeCallback</span><span class="params">(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *val)</span> </span>&#123;</span><br><span class="line">    DICT_NOTUSED(privdata);</span><br><span class="line"></span><br><span class="line">    sdsfree(val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dictType BenchmarkDictType = &#123;</span><br><span class="line">    hashCallback,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    compareCallback,</span><br><span class="line">    freeCallback,</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*而后调用dictCretate即可*/</span></span><br><span class="line">dict *dict = dictCreate(&amp;BenchmarkDictType,<span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<h5 id="dictAdd—往字典中添加一个k-v键值对"><a href="#dictAdd—往字典中添加一个k-v键值对" class="headerlink" title="dictAdd—往字典中添加一个k-v键值对"></a>dictAdd—往字典中添加一个k-v键值对</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">dictAdd(dict,sdsfromlonglong(j),(<span class="keyword">void</span>*)j);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>流程：判断是否rehash如果在则先进行rehash，而后再将k-v键值对添加进字典。随着不停的增加元素，会扩展hash table 此时rehsahidx就会被设置为0，代表需要进行rehash操作。</p>
</blockquote>
<h4 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h4><p>负载因子:哈希表已保存的节点数量/哈希表大小</p>
<p>load_factor = ht[0].used / ht[0].size</p>
<p>随着操作的不断执行，哈希表保持的k-v对会逐渐的增多或者减少，为了让哈希表的负载因子维持在一个合理的范围之内，当哈希表保存的k-v对数量太多或者太少时，程序需要对哈希表的大小进行相应的扩展或收缩。</p>
<p>redis rehash的步骤如下</p>
<ol>
<li>为字典ht[1]哈希表分配空间（在进行添加元素时触发rehash条件时便会分配），这个哈希表的空间大小取决于要执行的操作，以及ht[0]当前包含的键值对的数量—_dictNextPower(unsigned long size)<ul>
<li>如果执行扩展操作，那么ht[1]的大小就为地一个大于等于ht[0].used*2的2^n(2的n次方) —&gt;增加元素到一定条件自动触发</li>
<li>如果执行收缩操作，那么ht[1]的大小就为地一个大于等于ht[0].used的2^n(2的n次方) —&gt;外部调用dictResize</li>
</ul>
</li>
<li>将保存在ht[0]中的k-v重新计算hash后放在ht[1]上</li>
<li>在ht[0]上的所有k-v都迁移到ht[1]之后，释放ht[0],将ht[1]设置为ht[0],并再创建一个ht[1]空白hash表，为下一次rehash做准备</li>
<li>阅读源码可以发现redis并不是一次就将rehash执行完，而是采用的渐进式rehash，比如dictAdd函数中就会进行rehash操作</li>
</ol>
<h4 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h4><p>服务器执行命令时对dict的操作BGSAVE 和 BGREWRITEAOF</p>
]]></content>
      <categories>
        <category>开源代码</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>redis-sds-and-adlist</title>
    <url>/posts/ffcb78d2/</url>
    <content><![CDATA[<p>因为redis的sds动态字符串和双向链表比较简单所以放在一起，redis版本:<a href="http://download.redis.io/releases/redis-4.0.11.tar.gz">4.0.11</a>，参考redis设计与实现（第二版）</p>
<p>本节源码：</p>
<p>sds</p>
<p><a href="https://github.com/wxl2/my-redis/blob/main/base/sds.h">https://github.com/wxl2/my-redis/blob/main/base/sds.h</a></p>
<p><a href="https://github.com/wxl2/my-redis/blob/main/base/sds.c">https://github.com/wxl2/my-redis/blob/main/base/sds.c</a></p>
<p>adlist</p>
<p><a href="https://github.com/wxl2/my-redis/blob/main/base/adlist.h">https://github.com/wxl2/my-redis/blob/main/base/adlist.h</a></p>
<p><a href="https://github.com/wxl2/my-redis/blob/main/base/adlist.c">https://github.com/wxl2/my-redis/blob/main/base/adlist.c</a></p>
<p>test</p>
<p><a href="https://github.com/wxl2/my-redis/blob/main/test/test_adlist.c">https://github.com/wxl2/my-redis/blob/main/test/test_adlist.c</a></p>
<p><a href="https://github.com/wxl2/my-redis/blob/main/test/test_sds.c">https://github.com/wxl2/my-redis/blob/main/test/test_sds.c</a></p>
<a id="more"></a>

<h4 id="SDS动态字符串"><a href="#SDS动态字符串" class="headerlink" title="SDS动态字符串"></a>SDS动态字符串</h4><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><p>和C风格字符串相同，sds以’\0’作为结尾，所以可以使用C库中所有对字符串操作的函数；不同的是sds为动态的可以预分配内存，并且有标识字符串长度的成员len因而获取其长度非常的简单快捷。下面是sds结构体的定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *sds;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Note: sdshdr5 is never used, we just access the flags byte directly.</span></span><br><span class="line"><span class="comment"> * However is here to document the layout of type 5 SDS strings. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr5</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, and 5 msb of string length */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr16</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr32</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr64</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>sds其实就是一个typdef的char*，它指向sdshdr结构体成员buf。这里后面的数字为保存buf数组长度的变量的二进制位个数。redis中字符串的长度不同那么其使用的sdshdr也有可能不同。而sdshdr又可以细分为sdshdr5和其他类型。sdshdr5使用低3位来保存sdshdr的类型，高三位来保存buf的长度（0000 len 000 type）可以结合<code>SDS_TYPE_MASK 7</code>来判断。</p>
<p>这里值得一提的是</p>
<ul>
<li><strong>attribute</strong> ((<strong>packed</strong>)) 取消字节对齐</li>
<li><strong>struct sdshdr##T</strong>  字符粘连 –&gt;&gt; struct sdshdrT</li>
</ul>
<p>当新建一个sds字符串时:sds s = sdsnew(“hello”)，如图:<img src="/images/sds.png" alt="sds.png"></p>
<p>其实上图中新建hello字符串并不是使用的sdshdr8结构体而是sdshdr5，调用sdslen函数结合gdb调试可以得到，如图<img src="/images/sdshdr5.png" alt="sdshdr5.png"></p>
<p>这里的40 二进制拆分为00101 000，所以其type为SDS_TYPE_5，也就是flags为0。</p>
<p>下面结合一份代码并gdb跟踪调试来研究sds动态字符串</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sds mm = sdsnew(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">size_t</span> len = sdslen(mm);</span><br><span class="line"><span class="keyword">size_t</span> alloc = sdsalloc(mm);</span><br><span class="line">sdsfree(mm);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>(gdb) bt<br>#0  sdsnewlen (init=0x405fb8, initlen=5) at /root/my-redis/base/sds.c:87<br>#1  0x000000000040341c in sdsnew (init=0x405fb8 “hello”)<br>at /root/my-redis/base/sds.c:149<br>#2  0x0000000000401d55 in main () at /root/my-redis/test/test_sds.c:8<br>(gdb) </p>
</blockquote>
<p>sdsnew函数在计算完字符串长度后会调用sdsnewlen函数来进行下一步分配动作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Create a new sds string starting from a null terminated C string. */</span></span><br><span class="line"><span class="function">sds <span class="title">sdsnew</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *init)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> initlen = (init == <span class="literal">NULL</span>) ? <span class="number">0</span> : <span class="built_in">strlen</span>(init);</span><br><span class="line">    <span class="keyword">return</span> sdsnewlen(init, initlen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在sdsnewlen函数中会根据传进来的字符串长度来选择使用哪一种类型的sdshdr来保存这个字符串，之后计算需要的内存并分配，内存大小为sdshdr的大小加上字符串的大小，最后将sds指针指向buf并返回。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Create a new sds string with the content specified by the &#x27;init&#x27; pointer</span></span><br><span class="line"><span class="comment"> * and &#x27;initlen&#x27;.</span></span><br><span class="line"><span class="comment"> * If NULL is used for &#x27;init&#x27; the string is initialized with zero bytes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The string is always null-termined (all the sds strings are, always) so</span></span><br><span class="line"><span class="comment"> * even if you create an sds string with:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * mystring = sdsnewlen(&quot;abc&quot;,3);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * You can print the string with printf() as there is an implicit \0 at the</span></span><br><span class="line"><span class="comment"> * end of the string. However the string is binary safe and can contain</span></span><br><span class="line"><span class="comment"> * \0 characters in the middle, as the length is stored in the sds header. */</span></span><br><span class="line"><span class="function">sds <span class="title">sdsnewlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *init, <span class="keyword">size_t</span> initlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *sh;</span><br><span class="line">    sds s;</span><br><span class="line">    <span class="keyword">char</span> type = sdsReqType(initlen);</span><br><span class="line">    <span class="comment">/* Empty strings are usually created in order to append. Use type 8</span></span><br><span class="line"><span class="comment">     * since type 5 is not good at this. */</span></span><br><span class="line">    <span class="keyword">if</span> (type == SDS_TYPE_5 &amp;&amp; initlen == <span class="number">0</span>) type = SDS_TYPE_8;</span><br><span class="line">    <span class="keyword">int</span> hdrlen = sdsHdrSize(type);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *fp; <span class="comment">/* flags pointer. */</span></span><br><span class="line"></span><br><span class="line">    sh = s_malloc(hdrlen+initlen+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (!init)</span><br><span class="line">        <span class="built_in">memset</span>(sh, <span class="number">0</span>, hdrlen+initlen+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (sh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    s = (<span class="keyword">char</span>*)sh+hdrlen;</span><br><span class="line">    fp = ((<span class="keyword">unsigned</span> <span class="keyword">char</span>*)s)<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">switch</span>(type) &#123;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_5: &#123;</span><br><span class="line">            *fp = type | (initlen &lt;&lt; SDS_TYPE_BITS);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_8: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">8</span>,s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = initlen;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_16: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">16</span>,s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = initlen;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_32: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">32</span>,s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = initlen;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_64: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">64</span>,s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = initlen;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (initlen &amp;&amp; init)</span><br><span class="line">        <span class="built_in">memcpy</span>(s, init, initlen);</span><br><span class="line">    s[initlen] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于sdslen和sdsalloc，便是使用<code>##</code>来拼接出结构体并获取其成员来获取长度(sdshdr5除外)，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_HDR(T,s) ((struct sdshdr##T *)((s)-(sizeof(struct sdshdr##T))))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_5_LEN(f) ((f)&gt;&gt;SDS_TYPE_BITS) <span class="comment">//sdshdr5：直接右移3位得到长度</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_MASK 7</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">size_t</span> <span class="title">sdslen</span><span class="params">(<span class="keyword">const</span> sds s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags = s[<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">switch</span>(flags&amp;SDS_TYPE_MASK) &#123;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_5:</span><br><span class="line">            <span class="keyword">return</span> SDS_TYPE_5_LEN(flags);</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_8:</span><br><span class="line">            <span class="keyword">return</span> SDS_HDR(<span class="number">8</span>,s)-&gt;len;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_16:</span><br><span class="line">            <span class="keyword">return</span> SDS_HDR(<span class="number">16</span>,s)-&gt;len;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_32:</span><br><span class="line">            <span class="keyword">return</span> SDS_HDR(<span class="number">32</span>,s)-&gt;len;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_64:</span><br><span class="line">            <span class="keyword">return</span> SDS_HDR(<span class="number">64</span>,s)-&gt;len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* sdsalloc() = sdsavail() + sdslen() */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">size_t</span> <span class="title">sdsalloc</span><span class="params">(<span class="keyword">const</span> sds s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags = s[<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">switch</span>(flags&amp;SDS_TYPE_MASK) &#123;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_5:</span><br><span class="line">            <span class="keyword">return</span> SDS_TYPE_5_LEN(flags); </span><br><span class="line">            <span class="comment">/*sdshdr5 没有预分配内存的机制，直接返回buf字符串长度（包括&#x27;\0&#x27;)，</span></span><br><span class="line"><span class="comment">             *后续sds扩容会更加详细的解释*/</span></span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_8:</span><br><span class="line">            <span class="keyword">return</span> SDS_HDR(<span class="number">8</span>,s)-&gt;alloc;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_16:</span><br><span class="line">            <span class="keyword">return</span> SDS_HDR(<span class="number">16</span>,s)-&gt;alloc;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_32:</span><br><span class="line">            <span class="keyword">return</span> SDS_HDR(<span class="number">32</span>,s)-&gt;alloc;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_64:</span><br><span class="line">            <span class="keyword">return</span> SDS_HDR(<span class="number">64</span>,s)-&gt;alloc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后使用sdsfree释放内存时因为C库分配内存的特性（malloc分配内存有cookie块，若不进行偏移释放内存会失败）需要传入起始指针所以需要将sds指针偏移</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Free an sds string. No operation is performed if &#x27;s&#x27; is NULL. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsfree</span><span class="params">(sds s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    s_free((<span class="keyword">char</span>*)s-sdsHdrSize(s[<span class="number">-1</span>]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="预分配机制"><a href="#预分配机制" class="headerlink" title="预分配机制"></a>预分配机制</h5><p>预分配在sds API对一个sds字符串进行修改并需要扩展其内存时发生，程序不仅会为sds分配修改所必须要的空间，还会为sds分配额外的未使用的内存，对于预分配，满足一下公式：</p>
<ul>
<li>如果duisds进行修改之后，sds的长度（len值）将小于1MB，那么程序会分配和len值相同大小的未使用空间，也就是alloc属性会变为 len+len+1(1用来保存’\0’)，len全都为改变后字符串的长度</li>
<li>如果对sds进行修改之后，sds的长度将大于1MB，那么程序只会分配1MB的未使用空间，alloc的值为len+1MB+1byte</li>
</ul>
<p>使用预分配机制可以减少内存分配的次数提高程序效率但一定程度上存在浪费内存的情况，算是一种空间换时间的策略，redis中sdsMakeRoomFor函数为预分配内存函数，对于sdshdr5是否能使用预分配策略，在这个函数中就存在答案。在这个函数中有这样一行代码<code>if (type == SDS_TYPE_5) type = SDS_TYPE_8</code>而在这之前的一行<code>type = sdsReqType(newlen)</code>；保证了之后提升的类型能容纳下新分配出来的字符串；如果sdshdr类型为sdshdr5将其提升为sdshdr8进行操作，所以sdshdr5这种型仅仅存在于刚分配出一个新的sds字符串（且其长度小于sdshdr5的最大长度）到在使用sds API对其进行操作需要扩容这段时间。</p>
<blockquote>
<p>Don’t use type 5: the user is appending to the string and type 5 is not able to remember empty space, so sdsMakeRoomFor() must be called at every appending operation. </p>
</blockquote>
<h5 id="惰性空间释放"><a href="#惰性空间释放" class="headerlink" title="惰性空间释放"></a>惰性空间释放</h5><p>惰性空间释放用于优化字符串缩短操作：当sds API需要缩短sds所保存的字符串时并不是使用realloc来重新分配内存，而是直接使用原来的内存，将len长度减小即可，空闲内存大小可以使用sdsavail函数来获得（sdsavail = alloc -len）；这样一来如果后续需要对字符串进行增加操作有很大不用再分配内存了（可用内存足以放下增加字符串的大小）。</p>
<h5 id="防止缓冲区溢出-amp-amp-二进制安全"><a href="#防止缓冲区溢出-amp-amp-二进制安全" class="headerlink" title="防止缓冲区溢出&amp;&amp;二进制安全"></a>防止缓冲区溢出&amp;&amp;二进制安全</h5><p>这两个特性主要得益于sds结构体成员len，sds字符串在使用c库函数时使用’\0’标识字符串结束，但是实际上在使用sds API时使用结构体成员len来标识结束。</p>
<ul>
<li><p>缓冲区溢出</p>
<p>在使用C风格字符串时需要注意的一个问题就是容易造成缓冲区溢出问题，因为其没有变量来标识其长度。例如c库函数<code>extern char *strcat(char *dest, const char *src)</code>这个函数的作用是将src拼接到dest后并返回dest，在这个函数内并没有重新分配一块内存来保存拼接后的字符串，而是直接将src的内容拷贝到dest后并去除dest原来末尾的’\0’，当保持dest字符串的容器装不下两个字符串拼接后的大小时就会发生缓冲区溢出。为了避免这个问题，在使用sds字符串时应使用sdscat系列函数。</p>
</li>
<li><p>二进制安全</p>
<p>因为C库中的函数都将’\0’作为字符串结尾，因而C风格字符串只能保存符合某种编码的字符，而不能保存图片等二进制数据；但是由于sds字符串使用len结构体成员保持字符串长度，所以即使是字符串中存在’\0’也不会影响数据的输出，因而sds能保存任意类型的字符串。</p>
</li>
</ul>
<h4 id="adlist双向链表"><a href="#adlist双向链表" class="headerlink" title="adlist双向链表"></a>adlist双向链表</h4><p>redis使用的链表是很常见的一种：将数据结构塞入链表；独特的是redis使用void*保存节点数据以此来达到泛型的目的，另外还提供了一个类似于C++中迭代器的的结构体listIter。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *value;<span class="comment">//节点数据</span></span><br><span class="line">&#125; listNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listIter</span> &#123;</span></span><br><span class="line">    listNode *next;</span><br><span class="line">    <span class="keyword">int</span> direction;<span class="comment">//标识迭代器方向，往头还是往尾部移动</span></span><br><span class="line">&#125; listIter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);<span class="comment">//复制listNode.value函数指针</span></span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);<span class="comment">//释放listNode.value函数指针</span></span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);<span class="comment">//比较listNode.value函数指针</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure>

<p>adlist代码很少很容易看懂，这里提供一个API使用示例代码：<a href="https://github.com/wxl2/my-redis/blob/main/test/test_adlist.c">test_adlist</a></p>
<p>后续会有一篇文章来讲数据结构塞入链表和链表塞入数据结构两种不同类型的链表。</p>
]]></content>
      <categories>
        <category>开源代码</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>Cmake基本语法及使用</title>
    <url>/posts/f57b4ca7/</url>
    <content><![CDATA[<a id="more"></a>

<p><img src="/images/45678.jpg" alt="Logger"></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>muduo-net库分析</title>
    <url>/posts/5eab9dd9/</url>
    <content><![CDATA[<p>详细见源码注释：<a href="https://github.com/wxl2/maya">https://github.com/wxl2/maya</a></p>
<a id="more"></a>

<h3 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h3><p>拥有EventLoop对象的线程为IO线程，负责事件循环，循环检测Poller返回的activeChannel列表事件到来，调用对应Channel的事件分发函数</p>
<blockquote>
<p>wakeup_唤醒:</p>
<p>回调handRead将IO线程从poll阻塞中唤醒，wakeup_由wakeupChannel_管理,在EventLoop初始化时设置读回调函数并调用 enableReading函数将其添加进Poller的监听Channel列表内.一旦有时间则由Poller返回给EventLoop</p>
</blockquote>
<h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><blockquote>
<p>维护一个文件描述符,并分发这个文件描述符的事件</p>
</blockquote>
<h3 id="Poller"><a href="#Poller" class="headerlink" title="Poller"></a>Poller</h3><blockquote>
<p>监听文件描述符,并返回一个事件到来的Channel列表供EventLoop分发</p>
<p>muduo net库中几乎所有类的构造函数都含有一个EventLoop指针,所有类函数的调用都由EventLoop线程调用即I/O线程</p>
</blockquote>
<h3 id="EventLoop-Channel-Poller三者之间的调用关系"><a href="#EventLoop-Channel-Poller三者之间的调用关系" class="headerlink" title="EventLoop,Channel,Poller三者之间的调用关系"></a>EventLoop,Channel,Poller三者之间的调用关系</h3><blockquote>
<p>最开始调用在EventLoop::updateChannel函数将channel添加到Poller的监听列表中,而后利用EventLoop::loop函数,将EventLoop成员变量activeChanels_地址传递给Poller,由Poller调用成员函数poll将监听的Channel列表中有事件到来的channel添加到传递进来的activeChanels_中,之后IO线程便可利用activeChanels_来处理到来的事件,其使用Channel::handleEvent函数来进行事件的分发并处理.</p>
</blockquote>
<h3 id="Epoller-amp-PollPoller"><a href="#Epoller-amp-PollPoller" class="headerlink" title="Epoller&amp;PollPoller"></a>Epoller&amp;PollPoller</h3><blockquote>
<p>多路IO复用,分别由epoll和poll实现,作用就是监听事件并返回到来的事件,两个类都继承于纯虚类poller所以可通过poller指针调用</p>
</blockquote>
<h3 id="Acceptor"><a href="#Acceptor" class="headerlink" title="Acceptor"></a>Acceptor</h3><blockquote>
<p>仅建立连接,不创建channel等对象,内部使用channel管理监听套接字,监听读事件,一旦有连接到来即有读事件到达,建立好一个tcp连接,将connfd通过回调传递给上层对象进行建立TcpConnection进行一系列操作.另外Acceptor还管理一个Sokcet对象,Socket对象封装了一系列sokcet操作,Accepetor通常有TcpServer类所拥有</p>
</blockquote>
<h3 id="TcpConnection"><a href="#TcpConnection" class="headerlink" title="TcpConnection"></a>TcpConnection</h3><blockquote>
<p>负责管理Tcp连接,进行网络数据的收发</p>
</blockquote>
<h3 id="Connector"><a href="#Connector" class="headerlink" title="Connector"></a>Connector</h3><blockquote>
<p>非阻塞调用,调用connect建立连接获得文件描述符,可以重连和断开连接.连接创建创建成功后会回调TcpClient传入的NewConnectionCallback</p>
</blockquote>
<h3 id="当有连接到来或者消息到来时"><a href="#当有连接到来或者消息到来时" class="headerlink" title="当有连接到来或者消息到来时"></a>当有连接到来或者消息到来时</h3><h4 id="以Http为例"><a href="#以Http为例" class="headerlink" title="以Http为例"></a>以Http为例</h4><p>从初始化开始,从上层开始逐渐往下层设置函数回调,</p>
<p>首先是主函数函数</p>
<blockquote>
<p>在主函数中设置HttpServer的一个用户回调函数httpCallback_用于处理当有事件到来的其他操作</p>
</blockquote>
<p>HttpServer</p>
<blockquote>
<p>HttpServer中含有一个TcpServer成员,HttpServer在其构造函数内设置TcpServer所提供的用户回调函数,分别为</p>
<p>ConnectionCallback:HttpServer::onConnection;onConnection中调用httpCallback_</p>
<p>MessageCallback:HttpServer::onMessage</p>
</blockquote>
<p>TcpServer</p>
<blockquote>
<p>TcpServer设置Acceptor连接到来回调NewConnectionCallback:TcpServer::newConnection</p>
</blockquote>
<p>Acceptor</p>
<blockquote>
<p>Acceptor中有一个channel负责处理有连接事件到来,一旦有连接事件到来便回调TcpServer::newConnection</p>
</blockquote>
<p>TcpServer::newConnection</p>
<blockquote>
<p>创建一个TcpConnection,并将上层的回调函数设置给TcpConnection</p>
<p>CloseCallback:TcpServer::removeConnection<br>ConnectionCallback:-&gt;TcpServer::ConnectionCallback:HttpServer::onConnection<br>MessageCallback:-&gt;TcpServer::MessageCallback:HttpServer::onMessage<br>WriteCompleteCallback:writeCompleteCallback_</p>
<p>TcpConnection中有一个channel负责处理事件的分发</p>
</blockquote>
<p>返回数据</p>
<blockquote>
<p>HttpServer::onRequest()-&gt;TcpConnection::send-&gt;TcpConnection::sendInLoop-&gt;::write()写回http客户端</p>
</blockquote>
]]></content>
      <categories>
        <category>开源代码</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>muduo</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL中文乱码问题</title>
    <url>/posts/1490c64f/</url>
    <content><![CDATA[<p>关于MySQL中文字符乱码问题十分常见,多出现于windwos客户端编程,这里使用Linux还原出各种乱码场景并说出如何解决.</p>
<p>先决条件:安装好MySQL,安装文档:<a href="https://www.allhw.top/posts/fcb57d42/#MySQL%E9%85%8D%E7%BD%AE">Windows</a>,<a href="https://www.allhw.top/posts/cf6a0fee/">Linux</a></p>
<a id="more"></a>

<p>关于解决MySQL中文乱码的问题,互联网上有着大量优秀的文章,这里参考了以下大佬的文章:</p>
<p><a href="https://www.cnblogs.com/wj-1314/p/9147166.html">https://www.cnblogs.com/wj-1314/p/9147166.html</a></p>
<p><a href="http://cenalulu.github.io/mysql/mysql-mojibake/">http://cenalulu.github.io/mysql/mysql-mojibake/</a></p>
<p><a href="https://blog.csdn.net/chengxuyuanyonghu/article/details/70147023">https://blog.csdn.net/chengxuyuanyonghu/article/details/70147023</a></p>
<p>可以先看下这些文章一般就能大致了解MySQL乱码原因及相应的解决办法.</p>
<h3 id="MySQL乱码的几种情况"><a href="#MySQL乱码的几种情况" class="headerlink" title="MySQL乱码的几种情况"></a>MySQL乱码的几种情况</h3><p>在开始之前先做好准备工作,创建一个student表,SQL语句为</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="string">`student`</span>(</span><br><span class="line">   <span class="string">`id`</span> <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span> AUTO_INCREMENT,</span><br><span class="line">   <span class="string">`name`</span> <span class="built_in">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">   PRIMARY <span class="keyword">KEY</span> ( <span class="string">`id`</span> )</span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure>

<h4 id="1-显示层面问题"><a href="#1-显示层面问题" class="headerlink" title="1.显示层面问题"></a>1.显示层面问题</h4><p>问题大概为使用MySQL客户端工具时执行SQL语句插入中文后,select乱码,这种问题的原因在于终端的字符编码问题,如:</p>
<p>首先列出一个正常的<img src="/images/1490c64f/right.png" alt="正确显示的"></p>
<p>此时显示的是正常的,并且此时终端的编码为UTF-8,但如果一旦将终端显示编码修改不是utf-8,如此处修改为gbk<img src="/images/1490c64f/gbk.png" alt="gbk">,将终端字符改回utf-8即可显示正常.</p>
<p>此时MySQL内部的字符集为</p>
<blockquote>
<p>mysql&gt; show variables like ‘%char%’;<br>+————————–+——————————————————————–+<br>| Variable_name            | Value                                                              |<br>+————————–+——————————————————————–+<br>| character_set_client     | utf8                                                               |<br>| character_set_connection | utf8                                                               |<br>| character_set_database   | latin1                                                             |<br>| character_set_filesystem | binary                                                             |<br>| character_set_results    | utf8                                                               |<br>| character_set_server     | latin1                                                             |<br>| character_set_system     | utf8                                                               |<br>| character_sets_dir       | /home/wxl/date/mysql-5.7.28-linux-glibc2.12-x86_64/share/charsets/ |<br>+————————–+——————————————————————–+<br>8 rows in set (0.01 sec)</p>
</blockquote>
<h4 id="2-进行数据库开发时的乱码问题"><a href="#2-进行数据库开发时的乱码问题" class="headerlink" title="2.进行数据库开发时的乱码问题"></a>2.进行数据库开发时的乱码问题</h4><p>第二中问题也是比较常见的一种问题,产生的原因,前面的文章中也有做解释的,这里大致说下:就是客户端与服务器端所采用的字符集编码不同,在字符集进行转换时导致一部分数据丢失造成的乱码,如下面有一个C库操作MySQL的程序</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mysql.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MYSQL* m_Mysql;</span><br><span class="line">	m_Mysql=mysql_init(<span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (m_Mysql != <span class="literal">NULL</span> &amp;&amp; mysql_real_connect(m_Mysql, <span class="string">&quot;127.0.0.1&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;55555&quot;</span>, <span class="string">&quot;test&quot;</span>, <span class="number">3306</span>, <span class="literal">NULL</span>, <span class="number">0</span>))<span class="comment">//使用API连接数据库</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!mysql_select_db(m_Mysql,<span class="string">&quot;test&quot;</span>))<span class="comment">//选择数据库</span></span><br><span class="line"></span><br><span class="line">		&#123;</span><br><span class="line">			mysql_query(m_Mysql, <span class="string">&quot;set names utf8&quot;</span>);<span class="comment">//设置字符编码，避免中文乱码</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	MYSQL_RES* result = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">uint64_t</span> rowCount = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">uint32_t</span> fieldCount = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(mysql_query(m_Mysql,<span class="string">&quot;select * from student&quot;</span>)&lt;<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	result = mysql_store_result(m_Mysql);</span><br><span class="line">	<span class="comment">//cout&lt;&lt;(char*)mysql_error(m_Mysql)&lt;&lt;endl;//执行有误时的错误输出</span></span><br><span class="line">	rowCount = mysql_affected_rows(m_Mysql);</span><br><span class="line">	fieldCount = mysql_field_count(m_Mysql);</span><br><span class="line">	MYSQL_FIELD *fields = mysql_fetch_fields(result);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">uint32_t</span> i=<span class="number">0</span>;i&lt;fieldCount;i++)</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;fields[i].name&lt;&lt;<span class="string">&quot;\t&quot;</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rowCount;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		MYSQL_ROW row = mysql_fetch_row(result);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;fieldCount;++j)</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;row[j]&lt;&lt;<span class="string">&quot;\t&quot;</span>;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	mysql_close(m_Mysql);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在的字符集:</p>
<p>mysql&gt; show variables like ‘%char%’;</p>
<blockquote>
<p>+————————–+——————————————————————–+<br>| Variable_name            | Value                                                              |<br>+————————–+——————————————————————–+<br>| character_set_client     | utf8                                                               |<br>| character_set_connection | utf8                                                               |<br>| character_set_database   | latin1                                                             |<br>| character_set_filesystem | binary                                                             |<br>| character_set_results    | utf8                                                               |<br>| character_set_server     | latin1                                                             |<br>| character_set_system     | utf8                                                               |<br>| character_sets_dir       | /home/wxl/date/mysql-5.7.28-linux-glibc2.12-x86_64/share/charsets/ |<br>+————————–+——————————————————————–+<br>8 rows in set (0.01 sec)</p>
</blockquote>
<p>此时的输出是正确输出<img src="/images/1490c64f/cppright.png" alt="cpp的正确显示"></p>
<p>此时将连接时设置的字符集合设置为gbk</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mysql_query(m_Mysql, <span class="string">&quot;set names gbk&quot;</span>);<span class="comment">//设置字符编码，避免中文乱码</span></span><br></pre></td></tr></table></figure>

<p>结果如下<img src="/images/1490c64f/gbkerror.png" alt="gbkError"></p>
<p>在此时的情况下若将mysqlserver端的connection编码设置为gbk(connection为编程时mysqlserver返回的字符集编码),会出现以下情况.执行<code>set names &#39;gbk&#39;</code></p>
<p>结果同样是乱码<img src="/images/1490c64f/gbkerror.png" alt="gbkError">,但是如果将student的表的字符编码改为gbk,会如何,执行<code>ALTER TABLE student CONVERT TO CHARACTER SET  gbk</code>，并插入一条数据<img src="/images/1490c64f/insertgbk.png" alt="insertgbk"></p>
<p>那么出现这些情况的原因是什么呢,结合第三次修改显示正确的李四来看,可以得出:</p>
<blockquote>
<p>第一次乱码的原因为:mysqlServer端返回数据的字符集为utf-8,而client端使用gbk编码来接收两种编码之间的转换导致的乱码.</p>
<p>第二次乱码:此时mysqlserver和client字符编码统一但仍然发生乱码,这里结合地三个操作可以知道,student表在最初创建时的编码为utf8,所以插入的张三是使用utf8编码所保存的,这次乱码出现的地点是在mysqlserver端,因为张三原本是utf8编码,但server返回的是gbk,将utf8字符编码的数据直接保存在gbk编码中当然会乱码,在修改了student表的编码后再插入数据不会乱码,证实了这一点.</p>
</blockquote>
<h3 id="END"><a href="#END" class="headerlink" title="END"></a>END</h3><p>最后对于mysql乱码的问题最好的办法就是使用配置文件将编码统一设置为utf8.</p>
<p>目前所能想到的乱码问题就这么多,如果还有其他的情况,欢迎找我py.</p>
]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>muduo-ProcessInfo-and-GzipFile</title>
    <url>/posts/11956f4/</url>
    <content><![CDATA[<p>进程线程信息的获取以及使用zlib库对文件进行压缩</p>
<a id="more"></a>

<h4 id="ProcessInfo"><a href="#ProcessInfo" class="headerlink" title="ProcessInfo"></a>ProcessInfo</h4><blockquote>
<p>是一个命名空间，TODO调用的linux库函数分析</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> ProcessInfo</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">pid_t</span> <span class="title">pid</span><span class="params">()</span></span>;<span class="comment">//获取进程pid</span></span><br><span class="line">  <span class="function"><span class="built_in">string</span> <span class="title">pidString</span><span class="params">()</span></span>;<span class="comment">//将pid转换为字符串</span></span><br><span class="line">  <span class="function"><span class="keyword">uid_t</span> <span class="title">uid</span><span class="params">()</span></span>;<span class="comment">//获取进程uid</span></span><br><span class="line">  <span class="function"><span class="built_in">string</span> <span class="title">username</span><span class="params">()</span></span>;<span class="comment">//获取进程所属用户</span></span><br><span class="line">  <span class="function"><span class="keyword">uid_t</span> <span class="title">euid</span><span class="params">()</span></span>;<span class="comment">//有效用户</span></span><br><span class="line">  <span class="function">Timestamp <span class="title">startTime</span><span class="params">()</span></span>;<span class="comment">//获取进程开始运行时间</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">clockTicksPerSecond</span><span class="params">()</span></span>;<span class="comment">//获取cpu时钟每秒滴答数</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">pageSize</span><span class="params">()</span></span>;<span class="comment">//获取内存页大小</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">isDebugBuild</span><span class="params">()</span></span>;  <span class="comment">// constexpr判断是否处于调试状态</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="built_in">string</span> <span class="title">hostname</span><span class="params">()</span></span>;<span class="comment">//返回主机名</span></span><br><span class="line">  <span class="function"><span class="built_in">string</span> <span class="title">procname</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">StringPiece <span class="title">procname</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; stat)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// read /proc/self/status</span></span><br><span class="line">  <span class="function"><span class="built_in">string</span> <span class="title">procStatus</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// read /proc/self/stat</span></span><br><span class="line">  <span class="function"><span class="built_in">string</span> <span class="title">procStat</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// read /proc/self/task/tid/stat</span></span><br><span class="line">  <span class="function"><span class="built_in">string</span> <span class="title">threadStat</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// readlink /proc/self/exe</span></span><br><span class="line">  <span class="function"><span class="built_in">string</span> <span class="title">exePath</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">openedFiles</span><span class="params">()</span></span>;<span class="comment">//打开文件的个数</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">maxOpenFiles</span><span class="params">()</span></span>;<span class="comment">//最大能打开文件的个数</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">CpuTime</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="keyword">double</span> userSeconds;<span class="comment">//用户时间</span></span><br><span class="line">    <span class="keyword">double</span> systemSeconds;<span class="comment">//cpu时间</span></span><br><span class="line"></span><br><span class="line">    CpuTime() : userSeconds(<span class="number">0.0</span>), systemSeconds(<span class="number">0.0</span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">total</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> userSeconds + systemSeconds; &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="function">CpuTime <span class="title">cpuTime</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">numThreads</span><span class="params">()</span></span>;<span class="comment">//当前进程线程数</span></span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">pid_t</span>&gt; <span class="title">threads</span><span class="params">()</span></span>;</span><br><span class="line">&#125;  <span class="comment">// namespace ProcessInfo</span></span><br></pre></td></tr></table></figure>

<h4 id="scandir"><a href="#scandir" class="headerlink" title="scandir"></a>scandir</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">scandir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *dirp, struct dirent ***namelist,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">int</span> (*filter)(<span class="keyword">const</span> struct dirent *),</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">int</span> (*compar)(<span class="keyword">const</span> struct dirent **, <span class="keyword">const</span> struct dirent **))</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在scandir中会自己调用传入的filter和compar函数</p>
</blockquote>
<h4 id="GzipFile"><a href="#GzipFile" class="headerlink" title="GzipFile"></a>GzipFile</h4><blockquote>
<p>调用zlib库提供的接口对文件进行解压压缩操作。TODO：zlib库分析</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GzipFile</span> :</span> noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  GzipFile(GzipFile&amp;&amp; rhs) <span class="keyword">noexcept</span></span><br><span class="line">    : file_(rhs.file_)</span><br><span class="line">  &#123;</span><br><span class="line">    rhs.file_ = <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~GzipFile()</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (file_)</span><br><span class="line">    &#123;</span><br><span class="line">      ::gzclose(file_);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  GzipFile&amp; <span class="keyword">operator</span>=(GzipFile&amp;&amp; rhs) <span class="keyword">noexcept</span></span><br><span class="line">  &#123;</span><br><span class="line">    swap(rhs);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">valid</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> file_ != <span class="literal">NULL</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(GzipFile&amp; rhs)</span> </span>&#123; <span class="built_in">std</span>::swap(file_, rhs.file_); &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> ZLIB_VERNUM &gt;= 0x1240</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">setBuffer</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123; <span class="keyword">return</span> ::gzbuffer(file_, size) == <span class="number">0</span>; &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// return the number of uncompressed bytes actually read, 0 for eof, -1 for error</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">void</span>* buf, <span class="keyword">int</span> len)</span> </span>&#123; <span class="keyword">return</span> ::gzread(file_, buf, len); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// return the number of uncompressed bytes actually written</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">write</span><span class="params">(StringPiece buf)</span> </span>&#123; <span class="keyword">return</span> ::gzwrite(file_, buf.data(), buf.size()); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// number of uncompressed bytes</span></span><br><span class="line">  <span class="function"><span class="keyword">off_t</span> <span class="title">tell</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> ::gztell(file_); &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> ZLIB_VERNUM &gt;= 0x1240</span></span><br><span class="line">  <span class="comment">// number of compressed bytes</span></span><br><span class="line">  <span class="function"><span class="keyword">off_t</span> <span class="title">offset</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> ::gzoffset(file_); &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// int flush(int f) &#123; return ::gzflush(file_, f); &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> GzipFile <span class="title">openForRead</span><span class="params">(StringArg filename)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> GzipFile(::gzopen(filename.c_str(), <span class="string">&quot;rbe&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> GzipFile <span class="title">openForAppend</span><span class="params">(StringArg filename)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> GzipFile(::gzopen(filename.c_str(), <span class="string">&quot;abe&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> GzipFile <span class="title">openForWriteExclusive</span><span class="params">(StringArg filename)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> GzipFile(::gzopen(filename.c_str(), <span class="string">&quot;wbxe&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> GzipFile <span class="title">openForWriteTruncate</span><span class="params">(StringArg filename)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> GzipFile(::gzopen(filename.c_str(), <span class="string">&quot;wbe&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">GzipFile</span><span class="params">(gzFile file)</span></span></span><br><span class="line"><span class="function">    : <span class="title">file_</span><span class="params">(file)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  gzFile file_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用时调用静态成员函数</p>
</blockquote>
]]></content>
      <categories>
        <category>开源代码</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>muduo</tag>
      </tags>
  </entry>
  <entry>
    <title>muduo-Date-and-TimeZone</title>
    <url>/posts/853b7e88/</url>
    <content><![CDATA[<p>一些时间工具类，年月日和时间戳之间的转换，以及时区的设置。</p>
<a id="more"></a>

<h4 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span> :</span> <span class="keyword">public</span> muduo::copyable</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">YearMonthDay</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="keyword">int</span> year; <span class="comment">// [1900..2500]</span></span><br><span class="line">    <span class="keyword">int</span> month;  <span class="comment">// [1..12]</span></span><br><span class="line">    <span class="keyword">int</span> day;  <span class="comment">// [1..31]</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kDaysPerWeek = <span class="number">7</span>;<span class="comment">//一周7天</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kJulianDayOf1970_01_01;<span class="comment">//距离1970年1月1日的儒略日大小</span></span><br><span class="line"></span><br><span class="line">  Date()</span><br><span class="line">    : julianDayNumber_(<span class="number">0</span>)</span><br><span class="line">  &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 1 &lt;= month &lt;= 12</span></span><br><span class="line">  Date(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day);<span class="comment">//用年月日构造</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Date</span><span class="params">(<span class="keyword">int</span> julianDayNum)</span><span class="comment">//时间戳构造</span></span></span><br><span class="line"><span class="function">    : <span class="title">julianDayNumber_</span><span class="params">(julianDayNum)</span></span></span><br><span class="line"><span class="function">  </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Date</span><span class="params">(<span class="keyword">const</span> struct tm&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Date&amp; that)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::swap(julianDayNumber_, that.julianDayNumber_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">valid</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> julianDayNumber_ &gt; <span class="number">0</span>; &#125;<span class="comment">//判断数据是否有效，时间大于0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="built_in">string</span> <span class="title">toIsoString</span><span class="params">()</span> <span class="keyword">const</span></span>;<span class="comment">//将儒略日转换为年月日字符串</span></span><br><span class="line"></span><br><span class="line">  <span class="function">struct YearMonthDay <span class="title">yearMonthDay</span><span class="params">()</span> <span class="keyword">const</span></span>;<span class="comment">//将儒略日转换为年月日</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">year</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> yearMonthDay().year;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">month</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> yearMonthDay().month;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">day</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> yearMonthDay().day;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// [0, 1, ..., 6] =&gt; [Sunday, Monday, ..., Saturday ]</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">weekDay</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (julianDayNumber_+<span class="number">1</span>) % kDaysPerWeek;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">julianDayNumber</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> julianDayNumber_; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> julianDayNumber_;<span class="comment">//以儒略日计算</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>具体算法不做记录</p>
</blockquote>
<h4 id="TimeZone"><a href="#TimeZone" class="headerlink" title="TimeZone"></a>TimeZone</h4><blockquote>
<p>主要是时区之间的转换</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TimeZone for 1970~2030</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeZone</span> :</span> <span class="keyword">public</span> muduo::copyable</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">TimeZone</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* zonefile)</span></span>;<span class="comment">//zonefile是unix系统中的时区列表（unix一切皆文件），位于/usr/share/zoneinfo/</span></span><br><span class="line">  TimeZone(<span class="keyword">int</span> eastOfUtc, <span class="keyword">const</span> <span class="keyword">char</span>* tzname);  <span class="comment">// a fixed timezone</span></span><br><span class="line">  TimeZone() = <span class="keyword">default</span>;  <span class="comment">// an invalid timezone</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// default copy ctor/assignment/dtor are Okay.</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">valid</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="comment">// &#x27;explicit operator bool() const&#x27; in C++11</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">bool</span>&gt;(data_);<span class="comment">//Date向bool的隐式转换</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">struct tm <span class="title">toLocalTime</span><span class="params">(<span class="keyword">time_t</span> secondsSinceEpoch)</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">time_t</span> <span class="title">fromLocalTime</span><span class="params">(<span class="keyword">const</span> struct tm&amp;)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// gmtime(3)</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> struct tm <span class="title">toUtcTime</span><span class="params">(<span class="keyword">time_t</span> secondsSinceEpoch, <span class="keyword">bool</span> yday = <span class="literal">false</span>)</span></span>;</span><br><span class="line">  <span class="comment">// timegm(3)</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">time_t</span> <span class="title">fromUtcTime</span><span class="params">(<span class="keyword">const</span> struct tm&amp;)</span></span>;</span><br><span class="line">  <span class="comment">// year in [1900..2500], month in [1..12], day in [1..31]</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">time_t</span> <span class="title">fromUtcTime</span><span class="params">(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">int</span> hour, <span class="keyword">int</span> minute, <span class="keyword">int</span> seconds)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Data</span>;</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Data&gt; data_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>具体未详看</p>
</blockquote>
<p>TODO:待回看</p>
]]></content>
      <categories>
        <category>开源代码</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>muduo</tag>
      </tags>
  </entry>
  <entry>
    <title>muduo-日志库</title>
    <url>/posts/5975a6bc/</url>
    <content><![CDATA[<p>muduo中封装的日志相关操作，涉及文件:Logging.h，Logging.cc，LogStream.h，LogStream.cc，LogFile.h，LogFile.cc，FileUtil.h，FileUtil.cc，StringPiece.h</p>
<a id="more"></a>

<h4 id="Logger"><a href="#Logger" class="headerlink" title="Logger"></a>Logger</h4><p><img src="/images/UML/Logger.png" alt="Logger"></p>
<blockquote>
<p>Logger类含有两个内部类，一个是Impl类，一个是SourceFile类。</p>
</blockquote>
<p>使用Logger输出日志信息非常简单，只需使用代码所提供的宏即可，下面以LOG_INFO为例:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_INFO <span class="meta-keyword">if</span> (muduo::Logger::logLevel() &lt;= muduo::Logger::INFO) \</span></span><br><span class="line">  muduo::Logger(__FILE__, __LINE__).stream()</span><br><span class="line"><span class="comment">//使用示例</span></span><br><span class="line"> LOG_INFO &lt;&lt; <span class="string">&quot;Hello CST&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>日志输出：20200708 08:09:58.590748Z 16287 INFO Hello CST - Logging_test.cc:126</p>
<p>执行流程:</p>
<blockquote>
<p>logLevel函数是一个静态成员函数，调用其判断日志等级是否打印当前日志，假设条件成立会打印当前日志。LOG_INFO展开为 muduo::Logger(<strong>FILE</strong>, <strong>LINE</strong>).stream()&lt;&lt;”Hello CST”;先调用Logger类的构造函数，而后Logger类用一部分参数来构造Impl类，然后将一系列字符格式化到Impl类中LogStream类成员变量的buffer_中，最后在Logger的析构函数中打印日志。调用关系Logger() =&gt; Impl() =&gt; LogStream() =&gt; operator&lt;&lt;()FixedBuffer =&gt; g_output() =&gt; g_flush()</p>
</blockquote>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><blockquote>
<p>列举一个</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Logger::Logger(SourceFile file, <span class="keyword">int</span> line)</span><br><span class="line">  : impl_(INFO, <span class="number">0</span>, file, line)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LOG_INFO宏定义展开，将参数设置为 Logger::Logger(<strong>FILE</strong>, <strong>LINE</strong>),FILE和LINE两个宏会被自动展开为文件名和当前代码行号，对于</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> N&gt;</span><br><span class="line">SourceFile(<span class="keyword">const</span> <span class="keyword">char</span> (&amp;arr)[N])</span><br></pre></td></tr></table></figure>

<p>中的N，编译器会根据展开的FILE字符串长度来进行实例化。</p>
<h4 id="其余函数"><a href="#其余函数" class="headerlink" title="其余函数"></a>其余函数</h4><blockquote>
<p>相比起来其余函数都比较简单，此处大致说说其作用即可</p>
</blockquote>
<p>stream函数返回内部类impl_变量的LogStream对象。</p>
<p>logLevel函数返回当前日志等级</p>
<p>setLogLevel函数设置当前日志等级</p>
<p>setOutput函数设置日志打印函数，怎么打印，打印在哪</p>
<p>setFlush函数设置日志刷新方式<br>setTimeZone函数设置时区</p>
<h4 id="Impl"><a href="#Impl" class="headerlink" title="Impl"></a>Impl</h4><p><img src="/images/UML/Impl.png" alt="Impl"></p>
<blockquote>
<p>Impl构造函将时间，线程id日志等级缓存到LogStream类对象中，如果设置了错误码则将错误码一并缓存。</p>
<p>formatTime格式化时间</p>
<p>finish在尾部加上文件名和行号</p>
</blockquote>
<h4 id="Fmt"><a href="#Fmt" class="headerlink" title="Fmt"></a>Fmt</h4><blockquote>
<p>格式化输出字符串模板类</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fmt</span> // :</span> noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  Fmt(<span class="keyword">const</span> <span class="keyword">char</span>* fmt, T val);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">data</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> buf_; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> length_; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">char</span> buf_[<span class="number">32</span>];</span><br><span class="line">  <span class="keyword">int</span> length_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参数fmt是格式控制符，构造函数利用传入的格式将val的值按照该格式输出到buf_中</p>
</blockquote>
<p>另外还在LogStream.cc文件中显示实例化了Fmt类</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Explicit instantiations</span></span><br><span class="line"><span class="function"><span class="keyword">template</span> <span class="title">Fmt::Fmt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* fmt, <span class="keyword">char</span>)</span></span>;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">template</span> <span class="title">Fmt::Fmt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* fmt, <span class="keyword">double</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="FixedBuffer"><a href="#FixedBuffer" class="headerlink" title="FixedBuffer"></a>FixedBuffer</h4><p>FixedBuffer中存储的是字符</p>
<blockquote>
<p>设计的一个数据缓冲区，data_存放数据，cur_指向数据末端，并且每当插入数据cur_会自己改变。cookieStart和cookieEnd函数并未实现所以这两个函数和setCookie函数可以暂时不用理会。</p>
</blockquote>
<h4 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h4><blockquote>
<p>append：往缓冲中添加数据</p>
<p>data：返回数据起始地址<br>length：返回当前保存数据的长度<br>current：返回cur_指针的位置</p>
<p>avail：返回剩余缓冲区的大小<br>add：移动cur_指针</p>
<p>reset：重置cur_指针为数据开头的位置<br>bzero：清空缓冲区</p>
<p>debugString：截断缓冲区</p>
<p>toString：将缓冲区内容格式化为string对象返回<br>toStringPiece：将缓冲区内容格式化为StringPiece对象返回<br>end：返回data_最后的位置</p>
</blockquote>
<h4 id="LogStream"><a href="#LogStream" class="headerlink" title="LogStream"></a>LogStream</h4><blockquote>
<p>封装的一个数据流</p>
</blockquote>
<p>提供一系列&lt;&lt;重载操作，若传入的数据大小小于4个字节或其他条件则会将其转化为int类型，再次调用&lt;&lt;操作，不过调用的操作会变成int类型数据的重载操作。</p>
<blockquote>
<p>self&amp; operator&lt;&lt;(const void*);将指针转换为16进制存入</p>
</blockquote>
<h4 id="简单函数"><a href="#简单函数" class="headerlink" title="简单函数"></a>简单函数</h4><blockquote>
<p>append：直接向buffer_中添加数据<br>resetBuffer：重置缓冲区</p>
<p>staticCheck：编译期断言，检查数据</p>
</blockquote>
<h4 id="formatInteger"><a href="#formatInteger" class="headerlink" title="formatInteger"></a>formatInteger</h4><blockquote>
<p>将整形类的其他非字符数据类型，转换为字符类型，存入FixedBuffer缓冲区</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LogStream::formatInteger</span><span class="params">(T v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (buffer_.avail() &gt;= kMaxNumericSize)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">size_t</span> len = convert(buffer_.current(), v);</span><br><span class="line">    buffer_.add(len);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">convert</span><span class="params">(<span class="keyword">char</span> buf[], T value)</span><span class="comment">//将其他数据转换为字符的函数，采用int转char类似的算法，即取模和除10</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  T i = value;</span><br><span class="line">  <span class="keyword">char</span>* p = buf;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">int</span> lsd = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(i % <span class="number">10</span>);</span><br><span class="line">    i /= <span class="number">10</span>;</span><br><span class="line">    *p++ = zero[lsd];</span><br><span class="line">  &#125; <span class="keyword">while</span> (i != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (value &lt; <span class="number">0</span>)<span class="comment">//判断是否为负数</span></span><br><span class="line">  &#123;</span><br><span class="line">    *p++ = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  *p = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">  <span class="built_in">std</span>::reverse(buf, p);<span class="comment">//因为求出的数据和原来的数据相反，所以需要反转</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> p - buf;<span class="comment">//返回增加了的长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="LogFile"><a href="#LogFile" class="headerlink" title="LogFile"></a>LogFile</h4><p><img src="/images/UML/LogFile.png" alt="LogFile"></p>
<blockquote>
<p>创建日志文件，名称为进程名+时间+进程id+进程所属用户+.log，时间为UTC时间。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogFile</span> :</span> noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  LogFile(<span class="keyword">const</span> <span class="built_in">string</span>&amp; basename,</span><br><span class="line">          <span class="keyword">off_t</span> rollSize,</span><br><span class="line">          <span class="keyword">bool</span> threadSafe = <span class="literal">true</span>,</span><br><span class="line">          <span class="keyword">int</span> flushInterval = <span class="number">3</span>,</span><br><span class="line">          <span class="keyword">int</span> checkEveryN = <span class="number">1024</span>);</span><br><span class="line">  ~LogFile();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">append</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* logline, <span class="keyword">int</span> len)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">rollFile</span><span class="params">()</span></span>;<span class="comment">//滚动日志</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">append_unlocked</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* logline, <span class="keyword">int</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="built_in">string</span> <span class="title">getLogFileName</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; basename, <span class="keyword">time_t</span>* now)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">string</span> basename_;<span class="comment">//文件名</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">off_t</span> rollSize_;<span class="comment">//单个日志文件的大小，达到rollSize_便新建日志文件</span></span><br><span class="line">  <span class="comment">//日志滚动条件：1.新的一天开始新建文件，2.日志文件达到最大的大小</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> flushInterval_;<span class="comment">//日志写入的间隔时间</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> checkEveryN_;<span class="comment">//与count_相比较，判断是否需要滚动日志</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> count_;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;MutexLock&gt; mutex_;</span><br><span class="line">  <span class="keyword">time_t</span> startOfPeriod_;<span class="comment">//开始记录日志的时间，始终会被调整到0点时间</span></span><br><span class="line">  <span class="keyword">time_t</span> lastRoll_;<span class="comment">//上一次新建文件的时间</span></span><br><span class="line">  <span class="keyword">time_t</span> lastFlush_;<span class="comment">//上一次日志写入的时间</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;FileUtil::AppendFile&gt; file_;<span class="comment">//文件指针</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> kRollPerSeconds_ = <span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>;<span class="comment">//一天的秒数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="rollFile"><a href="#rollFile" class="headerlink" title="rollFile"></a>rollFile</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">LogFile::rollFile</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">time_t</span> now = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">string</span> filename = getLogFileName(basename_, &amp;now);</span><br><span class="line">  <span class="keyword">time_t</span> start = now / kRollPerSeconds_ * kRollPerSeconds_;<span class="comment">//将时间格式化为0点，除以kRollPerSeconds_除去0点后多余的数据，再乘kRollPerSeconds_变成当天0点时间</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (now &gt; lastRoll_)</span><br><span class="line">  &#123;</span><br><span class="line">    lastRoll_ = now;</span><br><span class="line">    lastFlush_ = now;</span><br><span class="line">    startOfPeriod_ = start;<span class="comment">//设置起始时间，后续在滚动日志时比较</span></span><br><span class="line">    file_.reset(<span class="keyword">new</span> FileUtil::AppendFile(filename));</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="append-unlocked"><a href="#append-unlocked" class="headerlink" title="append_unlocked"></a>append_unlocked</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LogFile::append_unlocked</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* logline, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  file_-&gt;append(logline, len);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (file_-&gt;writtenBytes() &gt; rollSize_)</span><br><span class="line">  &#123;</span><br><span class="line">    rollFile();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    ++count_;</span><br><span class="line">    <span class="keyword">if</span> (count_ &gt;= checkEveryN_)</span><br><span class="line">    &#123;</span><br><span class="line">      count_ = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">time_t</span> now = ::time(<span class="literal">NULL</span>);</span><br><span class="line">      <span class="keyword">time_t</span> thisPeriod_ = now / kRollPerSeconds_ * kRollPerSeconds_;</span><br><span class="line">      <span class="keyword">if</span> (thisPeriod_ != startOfPeriod_)<span class="comment">//判断是否为第二天0点，不相等则是第二天</span></span><br><span class="line">      &#123;</span><br><span class="line">        rollFile();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (now - lastFlush_ &gt; flushInterval_)</span><br><span class="line">      &#123;</span><br><span class="line">        lastFlush_ = now;</span><br><span class="line">        file_-&gt;flush();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>append:调用append_unlocked向文件缓冲区中添加内容<br>flush:手动刷新文件缓冲区</p>
<p>getLogFileName:设置日志文件名字</p>
</blockquote>
<h4 id="AppendFile"><a href="#AppendFile" class="headerlink" title="AppendFile"></a>AppendFile</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// not thread safe，非线程安全</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppendFile</span> :</span> noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">AppendFile</span><span class="params">(StringArg filename)</span></span>;</span><br><span class="line"></span><br><span class="line">  ~AppendFile();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">append</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* logline, <span class="keyword">size_t</span> len)</span></span>;<span class="comment">//将logline中的内容写入文件中</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span></span>;<span class="comment">//刷新文件流</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">off_t</span> <span class="title">writtenBytes</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> writtenBytes_; &#125;<span class="comment">//返回写入的字节数</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">write</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* logline, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line">  FILE* fp_;</span><br><span class="line">  <span class="keyword">char</span> buffer_[<span class="number">64</span>*<span class="number">1024</span>];<span class="comment">//文件缓冲区</span></span><br><span class="line">  <span class="keyword">off_t</span> writtenBytes_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="StringPiece"><a href="#StringPiece" class="headerlink" title="StringPiece"></a>StringPiece</h3><blockquote>
<p>是谷歌提供的一个字符串类，内存开销小，不重新开辟空间来拷贝传入的字符串，直接使用指针指向，支持多类型参数构造,既可以使用const char*也可以使用std::string。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>:<span class="comment">//成员变量</span></span><br><span class="line"> <span class="keyword">const</span> <span class="keyword">char</span>*   ptr_;<span class="comment">//字符串指针</span></span><br><span class="line"> <span class="keyword">int</span>           length_;<span class="comment">//字符串长度</span></span><br></pre></td></tr></table></figure>

<h4 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h4><blockquote>
<p>StringPiece提供了多个接口的构造函数</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">StringPiece()</span><br><span class="line">    : ptr_(<span class="literal">NULL</span>), length_(<span class="number">0</span>) &#123; &#125;<span class="comment">//默认构造函数</span></span><br><span class="line">  StringPiece(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span><br><span class="line">    : ptr_(str), length_(<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="built_in">strlen</span>(ptr_))) &#123; &#125;</span><br><span class="line">  StringPiece(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>* str)</span><br><span class="line">    : ptr_(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;(str)),</span><br><span class="line">      length_(<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="built_in">strlen</span>(ptr_))) &#123; &#125;</span><br><span class="line">  StringPiece(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str)</span><br><span class="line">    : ptr_(str.data()), length_(<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(str.size())) &#123; &#125;</span><br><span class="line">  StringPiece(<span class="keyword">const</span> <span class="keyword">char</span>* offset, <span class="keyword">int</span> len)<span class="comment">//传入一个地址和要构造字符串的长度</span></span><br><span class="line">    : ptr_(offset), length_(len) &#123; &#125;</span><br></pre></td></tr></table></figure>

<h4 id="cmp"><a href="#cmp" class="headerlink" title="cmp"></a>cmp</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STRINGPIECE_BINARY_PREDICATE(cmp,auxcmp)                             \</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="keyword">operator</span> <span class="title">cmp</span> <span class="params">(<span class="keyword">const</span> StringPiece&amp; x)</span> <span class="keyword">const</span> </span>&#123;                           \</span><br><span class="line">    <span class="keyword">int</span> r = <span class="built_in">memcmp</span>(ptr_, x.ptr_, length_ &lt; x.length_ ? length_ : x.length_); \</span><br><span class="line">    <span class="keyword">return</span> ((r auxcmp <span class="number">0</span>) || ((r == <span class="number">0</span>) &amp;&amp; (length_ cmp x.length_)));          \</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//宏函数</span></span><br><span class="line">  STRINGPIECE_BINARY_PREDICATE(&lt;,  &lt;);</span><br><span class="line">  STRINGPIECE_BINARY_PREDICATE(&lt;=, &lt;);</span><br><span class="line">  STRINGPIECE_BINARY_PREDICATE(&gt;=, &gt;);</span><br><span class="line">  STRINGPIECE_BINARY_PREDICATE(&gt;,  &gt;);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> STRINGPIECE_BINARY_PREDICATE</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>采用主从比较运算符来和类成员ptr_进行比较，先调用memcmp进行内存比较，长度为较短的那个字符串的长度，而后对r进行比较运算，采用从比较符，或运算有短路机制，以&lt;,&lt;为例，若r&lt;0，则可以直接返回真，表示ptr_小于x，若大于0进行后面的与运算，一样与运算有短路机制，r==0不成立直接返回假，ptr_大于x，若等于0，继续比较两个字符串长度，如果ptr-的长度校园x的长度，返回真，ptr_小于x，反之ptr_大于x。</p>
</blockquote>
<p>其余函数较简单，便不再列举</p>
<h4 id="模板萃取技术"><a href="#模板萃取技术" class="headerlink" title="模板萃取技术"></a>模板萃取技术</h4><p>TODO:待补充</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_TYPE_TRAITS</span></span><br><span class="line"><span class="comment">// This makes vector&lt;StringPiece&gt; really fast for some STL implementations#这使得vector&lt;StringPiece&gt;对于一些STL实现来说非常快</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="class"><span class="keyword">struct</span> __<span class="title">type_traits</span>&lt;muduo::StringPiece&gt; &#123;</span><span class="comment">//__type_traits类型特性结构体</span></span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_default_constructor;<span class="comment">//模板传入的类（muduo::StringPiece）是否有不重要的构造，有则将其定义为__true_type</span></span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_copy_constructor;<span class="comment">//...是否有有拷贝函数...</span></span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_assignment_operator;<span class="comment">//...是否有拷贝函数...</span></span><br><span class="line">  <span class="keyword">typedef</span> __true_type    has_trivial_destructor;<span class="comment">//...是否有拥有析构函数..</span></span><br><span class="line">  <span class="keyword">typedef</span> __true_type    is_POD_type;<span class="comment">//该类是一个POD数据类型，即与C兼容的数据类型，上述条件满足就是一个POD数据类型</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>traits是c++模板编程中使用的一种技术，主要功能：</p>
<p>把功能相同而参数不同的函数抽象出来，通过traits将不同的参数的相同属性提取出来，在函数中利用这些用traits提取的属性，使得函数对不同的参数表现一致。</p>
<p>c++11 中 type_traits</p>
<p>通过type_traits可以实现在编译期计算、查询、判断、转换和选择，增强了泛型编程的能力，也增强了程序的弹性，使得我们在编译期就能做到优化改进甚至排错，能进一步提高代码质量。</p>
</blockquote>
]]></content>
      <categories>
        <category>开源代码</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>muduo</tag>
      </tags>
  </entry>
  <entry>
    <title>muduo-ThreadLocal-and-ThreadLocalSingleton</title>
    <url>/posts/78a962ab/</url>
    <content><![CDATA[<h3 id="线程特定数据"><a href="#线程特定数据" class="headerlink" title="线程特定数据"></a>线程特定数据</h3><p>线程特定数据（thread-specific data，或 TSD），也称线程私有数据（thread-private date）。有这样一个图</p>
<a id="more"></a>

<p><img src="/images/thread-specific.png" alt="thread-specific"></p>
<p>在同一个进程中TSD的key名称相同，而对于不同的线程key指向的内存地址则不同，所以其可以保存不同的值作为线程私有数据。使用TSD的原因有两点：</p>
<p>1.有时需要维护基于线程的数据，而使用线程id作为数组索引并不理想，因为线程id大多不连续且值过大。</p>
<p>2.TSD提供了基于进程的接口实现多线程环境的机制，即进程中key的名称相同，而线程中指向的内容不同，linux中errno就是TSD的一个典型例子。（详见APUE第十二章线程控制第六节线程特定数据）</p>
<h4 id="POSIX提供的一系列函数接口"><a href="#POSIX提供的一系列函数接口" class="headerlink" title="POSIX提供的一系列函数接口"></a>POSIX提供的一系列函数接口</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_key_create</span><span class="params">(<span class="keyword">pthread_key_t</span> *keyp,<span class="keyword">void</span>(*destructor)(<span class="keyword">void</span>*))</span></span>;<span class="comment">//创建一个键并将其存储在keyp指向的内存当中，这个键可以被进程中所有的线程调用，但每个线程可以把这个键与不同的线程特定数据地址相关联。keyp创建成功时，每个线程的数据地址设置为空值。destructor为keyp相关联的析构函数，当线程退出时，若key已被置于空值，即调用了pthread_key_delete，destructor会被自动调用。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_key_delete</span><span class="params">(<span class="keyword">pthread_key_t</span> key)</span></span>;<span class="comment">//取消key与线程特定数据之间的关联，但不会激活key相关联的析构函数。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">pthread_getspecific</span><span class="params">(<span class="keyword">pthread_key_t</span> key)</span></span>;<span class="comment">//返回当前线程与key相关联的数据，若没有关联返回null</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_setspecific</span><span class="params">(<span class="keyword">pthread_key_t</span> key,<span class="keyword">const</span> <span class="keyword">void</span>* value)</span></span>;<span class="comment">//设置当前线程与key关联的数据</span></span><br></pre></td></tr></table></figure>

<h4 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span> :</span> noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  ThreadLocal()</span><br><span class="line">  &#123;</span><br><span class="line">    MCHECK(pthread_key_create(&amp;pkey_, &amp;ThreadLocal::destructor));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~ThreadLocal()</span><br><span class="line">  &#123;</span><br><span class="line">    MCHECK(pthread_key_delete(pkey_));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">T&amp; <span class="title">value</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    T* perThreadValue = <span class="keyword">static_cast</span>&lt;T*&gt;(pthread_getspecific(pkey_));</span><br><span class="line">    <span class="keyword">if</span> (!perThreadValue)<span class="comment">//若线程没有关联数据则设置一个关联</span></span><br><span class="line">    &#123;</span><br><span class="line">      T* newObj = <span class="keyword">new</span> T();</span><br><span class="line">      MCHECK(pthread_setspecific(pkey_, newObj));</span><br><span class="line">      perThreadValue = newObj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *perThreadValue;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">destructor</span><span class="params">(<span class="keyword">void</span> *x)</span><span class="comment">//析构函数</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    T* obj = <span class="keyword">static_cast</span>&lt;T*&gt;(x);</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">char</span> T_must_be_complete_type[<span class="keyword">sizeof</span>(T) == <span class="number">0</span> ? <span class="number">-1</span> : <span class="number">1</span>];</span><br><span class="line">    T_must_be_complete_type dummy; (<span class="keyword">void</span>) dummy;</span><br><span class="line">    <span class="keyword">delete</span> obj;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">pthread_key_t</span> pkey_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以定一个全局的ThreadLocal对象或者在main函数中定义，每个线程通过调用value函数来设置线程特定数据的关联或获取线程特定数据地址。不同线程调用value返回的值是不一样的，其指向的内存地址则不一样。在muduo中作者给出了两个示例，一个是多个ThreadLocal对象多个线程（ThreadLocal_test.cc），一个是单例ThreadLocal对象多个线程共用（SingletonThreadLocal_test.cc），虽然ThreadLocal对象对象只有一个但其管理的pkey_所关联的线程特定数据却可以不止一个。</p>
</blockquote>
<h4 id="ThreadLocalSingleton"><a href="#ThreadLocalSingleton" class="headerlink" title="ThreadLocalSingleton"></a>ThreadLocalSingleton</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalSingleton</span> :</span> noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  ThreadLocalSingleton() = <span class="keyword">delete</span>;</span><br><span class="line">  ~ThreadLocalSingleton() = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> T&amp; <span class="title">instance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!t_value_)</span><br><span class="line">    &#123;</span><br><span class="line">      t_value_ = <span class="keyword">new</span> T();</span><br><span class="line">      deleter_.<span class="built_in">set</span>(t_value_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *t_value_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> T* <span class="title">pointer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t_value_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">destructor</span><span class="params">(<span class="keyword">void</span>* obj)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    assert(obj == t_value_);</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">char</span> T_must_be_complete_type[<span class="keyword">sizeof</span>(T) == <span class="number">0</span> ? <span class="number">-1</span> : <span class="number">1</span>];</span><br><span class="line">    T_must_be_complete_type dummy; (<span class="keyword">void</span>) dummy;</span><br><span class="line">    <span class="keyword">delete</span> t_value_;</span><br><span class="line">    t_value_ = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Deleter</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    Deleter()</span><br><span class="line">    &#123;</span><br><span class="line">      pthread_key_create(&amp;pkey_, &amp;ThreadLocalSingleton::destructor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Deleter()</span><br><span class="line">    &#123;</span><br><span class="line">      pthread_key_delete(pkey_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(T* newObj)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      assert(pthread_getspecific(pkey_) == <span class="literal">NULL</span>);</span><br><span class="line">      pthread_setspecific(pkey_, newObj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pthread_key_t</span> pkey_;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> __thread T* t_value_;</span><br><span class="line">  <span class="keyword">static</span> Deleter deleter_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">__thread T* ThreadLocalSingleton&lt;T&gt;::t_value_ = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> ThreadLocalSingleton&lt;T&gt;::Deleter ThreadLocalSingleton&lt;T&gt;::deleter_;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个类就相当与SingletonThreadLocal_test.cc中<code>#define STL muduo::Singleton\&lt;muduo::ThreadLocal\ &gt;::instance().value()</code>，只能构造一个ThreadLocal对象，但其中pkey_所关联的线程数据可以不只一个。</p>
</blockquote>
]]></content>
      <categories>
        <category>开源代码</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>muduo</tag>
      </tags>
  </entry>
  <entry>
    <title>muduo-ThreadPool-and-Singleton</title>
    <url>/posts/7e079676/</url>
    <content><![CDATA[<p>线程池和线程单例类模板以及SFINAE机制</p>
<a id="more"></a>

<h4 id="ThreadPool"><a href="#ThreadPool" class="headerlink" title="ThreadPool"></a>ThreadPool</h4><p><img src="/images/UML/ThreadPool.png" alt="ThreadPool"></p>
<blockquote>
<p>线程池的本质是一个生产者消费者模型，产生任务的线程是生产者，线程池中的线程是消费者。当然，这不是绝对的，线程池中的线程处理一个任务以后可能会产生一个新的关联任务，那么此时这个工作线程又是生产者的角色。通常采用队列来实现线程池。</p>
</blockquote>
<p>定义一个函数包装器包装一类函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::function&lt;<span class="keyword">void</span> ()&gt; Task;</span><br></pre></td></tr></table></figure>

<p>ThreadPool定义了两个条件变量，分别用来通知生产者和消费者。notFull_用于通知生产者线程任务队列不为空（消费者线程为唤醒生产者线程），notEmpty_用于通知消费者线程有任务可以执行（生产者线程为唤醒消费者线程），两个条件变量共用一个互斥量mutex_。threadInitCallback_为线程执行调用的初始化函数，按照需要进行设置调用。threads_存放线程指针，queue_为任务队列，maxQueueSize_为最大任务数，running_标志是否对线程池进行销毁。</p>
<h4 id="start"><a href="#start" class="headerlink" title="start"></a>start</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadPool::start</span><span class="params">(<span class="keyword">int</span> numThreads)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  assert(threads_.empty());</span><br><span class="line">  running_ = <span class="literal">true</span>;</span><br><span class="line">  threads_.reserve(numThreads);<span class="comment">//重新设置vector的大小</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numThreads; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">char</span> id[<span class="number">32</span>];</span><br><span class="line">    <span class="built_in">snprintf</span>(id, <span class="keyword">sizeof</span> id, <span class="string">&quot;%d&quot;</span>, i+<span class="number">1</span>);</span><br><span class="line">    threads_.emplace_back(<span class="keyword">new</span> muduo::Thread(</span><br><span class="line">          <span class="built_in">std</span>::bind(&amp;ThreadPool::runInThread, <span class="keyword">this</span>), name_+id));<span class="comment">//构建线程池，创建numThreads个消费者线程</span></span><br><span class="line">    threads_[i]-&gt;start();<span class="comment">//启动每个消费者线程 Thread::start()</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (numThreads == <span class="number">0</span> &amp;&amp; threadInitCallback_)<span class="comment">//按照自己的需要进行线程初始化设置</span></span><br><span class="line">  &#123;</span><br><span class="line">    threadInitCallback_();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="stop"><a href="#stop" class="headerlink" title="stop"></a>stop</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadPool::stop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">  running_ = <span class="literal">false</span>;<span class="comment">//将running_置为false并唤醒所有等待线程</span></span><br><span class="line">  notEmpty_.notifyAll();</span><br><span class="line">  notFull_.notifyAll();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; thr : threads_)</span><br><span class="line">  &#123;</span><br><span class="line">    thr-&gt;join();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="run"><a href="#run" class="headerlink" title="run"></a>run</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadPool::run</span><span class="params">(Task task)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (threads_.empty())<span class="comment">//如果没有可用线程，直接在当前线程执行任务</span></span><br><span class="line">  &#123;</span><br><span class="line">    task();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    MutexLockGuard lock(mutex_);</span><br><span class="line">    <span class="keyword">while</span> (isFull() &amp;&amp; running_)</span><br><span class="line">    &#123;</span><br><span class="line">      notFull_.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!running_) <span class="keyword">return</span>;</span><br><span class="line">    assert(!isFull());<span class="comment">//当任务队列大小大于maxQueueSize_时返回ture取反为false程序断言，意思为产生的任务队列大小不能大于初始设置的认为队列大小</span></span><br><span class="line"></span><br><span class="line">    queue_.push_back(<span class="built_in">std</span>::move(task));</span><br><span class="line">    notEmpty_.notify();<span class="comment">//唤醒一个消费者线程</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="isFull"><a href="#isFull" class="headerlink" title="isFull"></a>isFull</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ThreadPool::isFull</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//assert在条件为false时断言</span></span><br><span class="line">  mutex_.assertLocked();</span><br><span class="line">  <span class="keyword">return</span> maxQueueSize_ &gt; <span class="number">0</span> &amp;&amp; queue_.size() &gt;= maxQueueSize_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="runInThread"><a href="#runInThread" class="headerlink" title="runInThread"></a>runInThread</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//简化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadPool::runInThread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (threadInitCallback_)</span><br><span class="line">    &#123;</span><br><span class="line">      threadInitCallback_();<span class="comment">//如果设置了线程初始化函数则执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (running_)<span class="comment">//标志为true则表示线程池还在运行没有销毁</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function">Task <span class="title">task</span><span class="params">(take())</span></span>;<span class="comment">//从任务队列取出一个任务</span></span><br><span class="line">      <span class="keyword">if</span> (task)<span class="comment">//有任务则执行</span></span><br><span class="line">      &#123;</span><br><span class="line">        task();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (<span class="keyword">const</span> Exception&amp; ex)</span><br><span class="line">  &#123;...&#125;</span><br><span class="line">  <span class="keyword">catch</span> (<span class="keyword">const</span> <span class="built_in">std</span>::exception&amp; ex)</span><br><span class="line">  &#123;...&#125;</span><br><span class="line">  <span class="keyword">catch</span> (...)</span><br><span class="line">  &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="take"><a href="#take" class="headerlink" title="take"></a>take</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ThreadPool::Task <span class="title">ThreadPool::take</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">  <span class="comment">// always use a while-loop, due to spurious wakeup</span></span><br><span class="line">  <span class="keyword">while</span> (queue_.empty() &amp;&amp; running_)<span class="comment">//若任务队列为空且线程池仍在运行，则唤醒生产者</span></span><br><span class="line">  &#123;</span><br><span class="line">    notEmpty_.wait();</span><br><span class="line">  &#125;</span><br><span class="line">  Task task;</span><br><span class="line">  <span class="keyword">if</span> (!queue_.empty())</span><br><span class="line">  &#123;</span><br><span class="line">    task = queue_.front();</span><br><span class="line">    queue_.pop_front();</span><br><span class="line">    <span class="keyword">if</span> (maxQueueSize_ &gt; <span class="number">0</span>)<span class="comment">//如果设置的任务队列大于0则通知生产者进行生产，生产者被唤醒后判断条件是否进行生产</span></span><br><span class="line">    &#123;</span><br><span class="line">      notFull_.notify();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="muduo作者提供的测试"><a href="#muduo作者提供的测试" class="headerlink" title="muduo作者提供的测试"></a>muduo作者提供的测试</h4><h5 id="test"><a href="#test" class="headerlink" title="test"></a>test</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> maxSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  LOG_WARN &lt;&lt; <span class="string">&quot;Test ThreadPool with max queue size = &quot;</span> &lt;&lt; maxSize;</span><br><span class="line">  <span class="function">muduo::ThreadPool <span class="title">pool</span><span class="params">(<span class="string">&quot;MainThreadPool&quot;</span>)</span></span>;</span><br><span class="line">  pool.setMaxQueueSize(maxSize);</span><br><span class="line">  pool.start(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">  LOG_WARN &lt;&lt; <span class="string">&quot;Adding&quot;</span>;</span><br><span class="line">  pool.run(print);</span><br><span class="line">  pool.run(print);<span class="comment">//在调用 pool.stop()之前这个线程会一直执行</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">32</span>];</span><br><span class="line">    <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span> buf, <span class="string">&quot;task %d&quot;</span>, i);</span><br><span class="line">    pool.run(<span class="built_in">std</span>::bind(printString, <span class="built_in">std</span>::<span class="built_in">string</span>(buf)));</span><br><span class="line">  &#125;</span><br><span class="line">  LOG_WARN &lt;&lt; <span class="string">&quot;Done&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">muduo::CountDownLatch <span class="title">latch</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">  pool.run(<span class="built_in">std</span>::bind(&amp;muduo::CountDownLatch::countDown, &amp;latch));</span><br><span class="line">  latch.wait();</span><br><span class="line">  pool.stop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Singleton"><a href="#Singleton" class="headerlink" title="Singleton"></a>Singleton</h3><blockquote>
<p>在多个线程中保证一个类只创建一次</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> :</span> noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  Singleton() = <span class="keyword">delete</span>;</span><br><span class="line">  ~Singleton() = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> T&amp; <span class="title">instance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    pthread_once(&amp;ponce_, &amp;Singleton::init);</span><br><span class="line">    assert(value_ != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> *value_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    value_ = <span class="keyword">new</span> T();</span><br><span class="line">    <span class="keyword">if</span> (!detail::has_no_destroy&lt;T&gt;::value)</span><br><span class="line">    &#123;</span><br><span class="line">      ::atexit(destroy);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">char</span> T_must_be_complete_type[<span class="keyword">sizeof</span>(T) == <span class="number">0</span> ? <span class="number">-1</span> : <span class="number">1</span>];</span><br><span class="line">    T_must_be_complete_type dummy; (<span class="keyword">void</span>) dummy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> value_;</span><br><span class="line">    value_ = <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">pthread_once_t</span> ponce_;</span><br><span class="line">  <span class="keyword">static</span> T*             value_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">pthread_once_t</span> Singleton&lt;T&gt;::ponce_ = PTHREAD_ONCE_INIT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T* Singleton&lt;T&gt;::value_ = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p><a href="https://www.allhw.top/2020/06/02/FlamingoServer%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB-base%E7%9B%AE%E5%BD%95/#%E5%8D%95%E4%BE%8B%E6%A8%A1%E6%9D%BF%E7%B1%BB"><a href="https://www.allhw.top/posts/4f56f208/#%E5%8D%95%E4%BE%8B%E6%A8%A1%E6%9D%BF%E7%B1%BB">之前的一个单例模板类</a></a></p>
<p>此处若有两个线程同时调用Singleton::Instance()会出现创建出两个类的情况:</p>
<blockquote>
<p>第一个线程执行到Instance函数的函数体内刚判断完条件准备执行value_ = new T()来创建一个类时切换到第二个线程，假设第二个线程一直执行到创建结束后切换到第一个线程，此时第一个线程继续执行又创建了一个类但是由于 value_是static变量只存在一个所以第二个线程设置的值会被覆盖，造成内存泄漏。</p>
</blockquote>
<h4 id="pthread-once"><a href="#pthread-once" class="headerlink" title="pthread_once"></a>pthread_once</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line">int pthread_once(pthread_once_t *once_control, void (*init_routine) (void))；</span><br></pre></td></tr></table></figure>

<blockquote>
<p>功能：pthread_once函数使用初值为PTHREAD_ONCE_INIT的once_control变量保证init_routine()函数在本进程执行序列中仅执行一次。</p>
</blockquote>
<h4 id="atexit"><a href="#atexit" class="headerlink" title="atexit"></a>atexit</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">atexit</span><span class="params">(<span class="keyword">void</span> (*function)(<span class="keyword">void</span>))</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>功 能: 注册终止函数(即main执行结束后调用的函数)</p>
</blockquote>
<h4 id="将运行期的错误移至编译期检查"><a href="#将运行期的错误移至编译期检查" class="headerlink" title="将运行期的错误移至编译期检查"></a>将运行期的错误移至编译期检查</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> T_must_be_complete_type[<span class="keyword">sizeof</span>(T) == <span class="number">0</span> ? <span class="number">-1</span> : <span class="number">1</span>];</span><br><span class="line">T_must_be_complete_type dummy; (<span class="keyword">void</span>) dummy;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>sizeof的值在编译期便决定，c++中不能定义一个大小为-1的数组，若定义了在编译期便会报错。这样做的目标是为了防止将空类传入模板进行实例化，</p>
<p>GCC对于incomplete type使用sizeof时，会返回0(当前直接会编译出错).那什么又叫做incomplete type呢，就是那些声明了，但没有定义的类型</p>
</blockquote>
<h4 id="SFINAE机制"><a href="#SFINAE机制" class="headerlink" title="SFINAE机制"></a>SFINAE机制</h4><blockquote>
<p>SFINAE机制是模板元编程中的一种手法，在boost和标准库中有着大量的使用。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> detail</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">has_no_destroy</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> C&gt; <span class="function"><span class="keyword">static</span> <span class="keyword">char</span> <span class="title">test</span><span class="params">(<span class="keyword">decltype</span>(&amp;C::no_destroy))</span></span>;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> C&gt; <span class="function"><span class="keyword">static</span> <span class="keyword">int32_t</span> <span class="title">test</span><span class="params">(...)</span></span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">bool</span> value = <span class="keyword">sizeof</span>(test&lt;T&gt;(<span class="number">0</span>)) == <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;  <span class="comment">// namespace detail</span></span><br><span class="line"></span><br><span class="line">detail::has_no_destroy&lt;T&gt;::value</span><br></pre></td></tr></table></figure>

<blockquote>
<p>c++中模板的实例化会从多个模板中找出一个相匹配的模板来进行实例化且若有匹配的模板那么之前所匹配失败的模板即使有报错也不会停止编译，如这里的test(0)，进行实例化首先匹配static char test(decltype(&amp;C::no_destroy)若C类型不存在no_destroy函数则匹配失败且若只有这一个模板则会报错，接着便会向下继续匹配static int32_t test(…)是一个可变参数函数接受所有参数，模板匹配成功不报错。至于这个匹配机制为和如此，原因是：当前实例化的数据没有no_destroy函数不代表其他数据没有该函数，所以模板是正确的，并且T这个类型正确匹配到了一个模板因而不会报错。</p>
</blockquote>
<blockquote>
<p>对于sizeof，其若对函数进行求值，得出的大小为函数返回值的大小，如 int32_t test(…);，sizeof这个函数得到的值为4</p>
</blockquote>
<blockquote>
<p>对于可变参数函数，在C中编译器要求可变参数函数必须有一个提供了数据类型的参数，例如:int func(type a,…);这样是可行的，而int func(…)这样是不可行的，而在c++中要求并没有这么严格int func(…)也是可行的。</p>
</blockquote>
]]></content>
      <categories>
        <category>开源代码</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>muduo</tag>
      </tags>
  </entry>
  <entry>
    <title>muduo-BlockingQueue-and-BoundedBlockingQueue</title>
    <url>/posts/2da75404/</url>
    <content><![CDATA[<p>BlockingQueue是一个无界缓存区使用队列deque来实现,BoundedBlockingQueue是一个有界缓冲区使用环形队列来实现.这两个缓冲区通常用于生产者消费者模型.</p>
<a id="more"></a>

<h4 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h4><p><img src="/images/UML/BlockingQueue.png" alt="BlockingQueue"></p>
<blockquote>
<p>take函数通常为消费者线程所调用,若队列中没有数据供消耗take便一直调用wait函数等待生产者线程生产数据;put函数多为生产者线程所调用,每当生产者生产出一个数据便通知唤醒一个消费者线程.BlockingQueue提供了两个put函数,一个是const的引用,一个是右值引用(内存优化,避免拷贝,需要传入一个右值在,若原来的值不为右值可以使用std::move来将左值转换为右值)</p>
</blockquote>
<h4 id="BoundedBlockingQueue"><a href="#BoundedBlockingQueue" class="headerlink" title="BoundedBlockingQueue"></a>BoundedBlockingQueue</h4><p><img src="/images/UML/BoundedBlockingQueue.png" alt="BoundedBlockingQueue"></p>
<blockquote>
<p>BoundedBlockingQueue与BlockingQueue不同的是BoundedBlockingQueue有界使用环形队列,多了几个用于判断队列是否满(full)和真实大小(capacity)的操作</p>
</blockquote>
<h3 id="使用模型"><a href="#使用模型" class="headerlink" title="使用模型"></a>使用模型</h3><h4 id="producer"><a href="#producer" class="headerlink" title="producer"></a>producer</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(flag)</span><br><span class="line">&#123;</span><br><span class="line">     muduo::BoundedBlockingQueue&lt;T&gt;::put(date);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="consumer"><a href="#consumer" class="headerlink" title="consumer"></a>consumer</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(flag)</span><br><span class="line">&#123;</span><br><span class="line">     muduo::BoundedBlockingQueue&lt;T&gt;::take();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="muduo提供的示例"><a href="#muduo提供的示例" class="headerlink" title="muduo提供的示例"></a>muduo提供的示例</h3><blockquote>
<p>简化版本</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  Test(<span class="keyword">int</span> numThreads)</span><br><span class="line">    : latch_(numThreads)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numThreads; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">char</span> name[<span class="number">32</span>];</span><br><span class="line">      <span class="built_in">snprintf</span>(name, <span class="keyword">sizeof</span> name, <span class="string">&quot;work thread %d&quot;</span>, i);</span><br><span class="line">      threads_.emplace_back(<span class="keyword">new</span> muduo::Thread(</span><br><span class="line">            <span class="built_in">std</span>::bind(&amp;Test::threadFunc, <span class="keyword">this</span>), muduo::<span class="built_in">string</span>(name)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; thr : threads_)</span><br><span class="line">    &#123;</span><br><span class="line">      thr-&gt;start();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="keyword">int</span> times)</span><span class="comment">//producer</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    latch_.wait();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; times; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">char</span> buf[<span class="number">32</span>];</span><br><span class="line">      <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span> buf, <span class="string">&quot;hello %d&quot;</span>, i);</span><br><span class="line">      queue_.put(buf);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">joinAll</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; threads_.size(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      queue_.put(<span class="string">&quot;stop&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; thr : threads_)</span><br><span class="line">    &#123;</span><br><span class="line">      thr-&gt;join();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">threadFunc</span><span class="params">()</span><span class="comment">//consumer</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    latch_.countDown();</span><br><span class="line">    <span class="keyword">bool</span> running = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (running)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">d</span><span class="params">(queue_.take())</span></span>;</span><br><span class="line">      running = (d != <span class="string">&quot;stop&quot;</span>);<span class="comment">//等于stop时退出</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  muduo::BlockingQueue&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; queue_;</span><br><span class="line">  muduo::CountDownLatch latch_;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;muduo::Thread&gt;&gt; threads_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">Test <span class="title">t</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">  t.run(<span class="number">100</span>);</span><br><span class="line">  t.joinAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>创建5个消费者线程,消费者线程创建完成后挂起等待唤醒,而生产者线程调用CountDownLatch::wait等待所有消费者线程初始化完毕后开始生产数据,每生产一个数据便唤醒一个消费者线程.当要结束消费者线程时,往队列里添加5个stop数据,当队列中有数据后消费者线程被唤醒读取到stop执行操作结束函数.有多少个消费者线程就应该往队列里添加多少个stop</p>
</blockquote>
]]></content>
      <categories>
        <category>开源代码</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>muduo</tag>
      </tags>
  </entry>
  <entry>
    <title>muduo-Mutex-and-Condition</title>
    <url>/posts/da26fa19/</url>
    <content><![CDATA[<p>封装Linux系统底层的条件变量和互斥量的一系列操作</p>
<a id="more"></a>

<h3 id="Mutex"><a href="#Mutex" class="headerlink" title="Mutex"></a>Mutex</h3><h4 id="UnassignGuard"><a href="#UnassignGuard" class="headerlink" title="UnassignGuard"></a>UnassignGuard</h4><p><img src="/images/UML/UnassignGuard.png" alt="UnassignGuard"></p>
<blockquote>
<p>设置和取消owner_的拥有者线程id</p>
</blockquote>
<h4 id="MutexLockGuard"><a href="#MutexLockGuard" class="headerlink" title="MutexLockGuard"></a>MutexLockGuard</h4><p><img src="/images/UML/MutexLockGuard.png" alt="MutexLockGuard"></p>
<blockquote>
<p>使用RAII技术封装的MutexLock</p>
</blockquote>
<h4 id="MutexLock"><a href="#MutexLock" class="headerlink" title="MutexLock"></a>MutexLock</h4><p><img src="/images/UML/MutexLock.png" alt="MutexLock"></p>
<blockquote>
<p>初始化一个pthread_mutex_t互斥量并提供一系列操作</p>
<p>bool isLockedByThisThread() const:判断当前线程是否拥有mutex_互斥量</p>
<p>void assertLocked() const:调用isLockedByThisThread函数进行断言</p>
<p>void lock() :加锁<br>void unlock() :解锁</p>
<p>pthread_mutex_t* getPthreadMutex() :返回mutex_互斥量</p>
</blockquote>
<h3 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h3><p><img src="/images/UML/Condition.png" alt="Condition"></p>
<h4 id="waitForSeconds"><a href="#waitForSeconds" class="headerlink" title="waitForSeconds"></a>waitForSeconds</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> muduo::Condition::waitForSeconds(<span class="keyword">double</span> seconds)</span><br><span class="line">&#123;<span class="comment">//等待一个信号量seconds*kNanoSecondsPerSecond微妙</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">abstime</span>;</span></span><br><span class="line">  clock_gettime(CLOCK_REALTIME, &amp;abstime);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int64_t</span> kNanoSecondsPerSecond = <span class="number">1000000000</span>;</span><br><span class="line">  <span class="keyword">int64_t</span> nanoseconds = <span class="keyword">static_cast</span>&lt;<span class="keyword">int64_t</span>&gt;(seconds * kNanoSecondsPerSecond);</span><br><span class="line"></span><br><span class="line">  abstime.tv_sec += <span class="keyword">static_cast</span>&lt;<span class="keyword">time_t</span>&gt;((abstime.tv_nsec + nanoseconds) / kNanoSecondsPerSecond);</span><br><span class="line">  abstime.tv_nsec = <span class="keyword">static_cast</span>&lt;<span class="keyword">long</span>&gt;((abstime.tv_nsec + nanoseconds) % kNanoSecondsPerSecond);</span><br><span class="line"></span><br><span class="line">  <span class="function">MutexLock::UnassignGuard <span class="title">ug</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> ETIMEDOUT == pthread_cond_timedwait(&amp;pcond_, mutex_.getPthreadMutex(), &amp;abstime);<span class="comment">//若和ETIMEDOUT相等则超时</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>void wait():释放mutex_互斥量而后等待条件变量</p>
<p>void notify():唤醒一个线程<br>void notifyAll():唤醒所有等待线程</p>
</blockquote>
]]></content>
      <categories>
        <category>开源代码</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>muduo</tag>
      </tags>
  </entry>
  <entry>
    <title>muduo-Thread-and-CountDownLatch</title>
    <url>/posts/95cd817b/</url>
    <content><![CDATA[<h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h4><p><a href="http://clang.llvm.org/docs/ThreadSafetyAnalysis.html"><a href="http://clang.llvm.org/docs/ThreadSafetyAnalysis.html">Clang 9文档 —- 线程安全分析</a></a></p>
<p><a href="https://nshipster.com/__attribute__/"><a href="https://nshipster.com/__attribute__/"><strong>attribute</strong> @Mattt</a></a></p>
<a id="more"></a>

<h3 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h3><p><img src="/images/UML/Thread.png" alt="Thread"></p>
<p>Thread类是作者基于对象编程封装的一个线程类和目前的std::thread相类似.使用时提供一个线程函数即可.Thread类同样继承于noncopyable，其不可拷贝复制.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::function&lt;<span class="keyword">void</span> ()&gt; ThreadFunc;</span><br></pre></td></tr></table></figure>

<p>将一个void()型的函数重定义为ThreadFunc.std::function是一个函数包装器,引进于boost库.</p>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//explicit Thread(ThreadFunc, const string&amp; name = string()); </span></span><br><span class="line"><span class="comment">/*使用explicit关键字可以阻止不应该允许的经过转换构造函数进行的隐式转换的发生</span></span><br><span class="line"><span class="comment">*当构造函数是单个参数时调用AAA=XXX(两个不同的类)，且恰好XXX的类型正好是AAA单参数构造器的参数类型， 这时候编译器就自动调用这个构造器， 创建一个AAA的对象。</span></span><br><span class="line"><span class="comment">*详见:https://baike.baidu.com/item/explicit/4941869?fr=aladdin</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Thread::Thread(ThreadFunc func, <span class="keyword">const</span> <span class="built_in">string</span>&amp; n)</span><br><span class="line">  : started_(<span class="literal">false</span>),</span><br><span class="line">    joined_(<span class="literal">false</span>),</span><br><span class="line">    pthreadId_(<span class="number">0</span>),</span><br><span class="line">    tid_(<span class="number">0</span>),</span><br><span class="line">    func_(<span class="built_in">std</span>::move(func)),<span class="comment">//std::move对象移动，不进行拷贝动作</span></span><br><span class="line">    name_(n),</span><br><span class="line">    latch_(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">  setDefaultName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="start"><a href="#start" class="headerlink" title="start"></a>start</h4><blockquote>
<p>start函数是Thread类中的一个重要函数作用是启动一个线程来执行传入的函数</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Thread::start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  assert(!started_);</span><br><span class="line">  started_ = <span class="literal">true</span>;</span><br><span class="line">  detail::ThreadData* data = <span class="keyword">new</span> detail::ThreadData(func_, name_, &amp;tid_, &amp;latch_);</span><br><span class="line">  <span class="keyword">if</span> (pthread_create(&amp;pthreadId_, <span class="literal">NULL</span>, &amp;detail::startThread, data))<span class="comment">//pthread_create成功返回0,失败返回errno其为非0值</span></span><br><span class="line"><span class="comment">/*此处必须使用这个类外的函数来作为线程执行函数传参，而后传入类，因为c++在函数参数传递时有this指针做干扰</span></span><br><span class="line"><span class="comment">void* startThread(void* obj)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  ThreadData* data = static_cast&lt;ThreadData*&gt;(obj);</span></span><br><span class="line"><span class="comment">  data-&gt;runInThread();</span></span><br><span class="line"><span class="comment">  delete data;</span></span><br><span class="line"><span class="comment">  return NULL;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  &#123;</span><br><span class="line">    started_ = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">delete</span> data; <span class="comment">// or no delete?</span></span><br><span class="line">    LOG_SYSFATAL &lt;&lt; <span class="string">&quot;Failed in pthread_create&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    latch_.wait();</span><br><span class="line">    assert(tid_ &gt; <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>start函数利用传入的func_函数构造一个结构体并封装好一系列的函数执行流程,而后再创建一个线程调用startThread函数，而startThread函数中则调用,封装好的结构体中的函数.start函数会进入休眠状态等待线程创建成功并成功执行,其使用的是latch_里的条件变量,构造函数初始化时latch_的成员变量count_值为1,在latch_的成员函数wait中若count_一直大于0,则start所在的线程会进入休眠状态等待唤醒,当runInThread函数成功执行时会调用函数使count_减一并唤醒主线程判断条件是否继续休眠,从而可以使主线程跳出循环,继续执行后续代码</p>
</blockquote>
<h4 id="Thread类的其他成员"><a href="#Thread类的其他成员" class="headerlink" title="Thread类的其他成员"></a>Thread类的其他成员</h4><p>函数:</p>
<blockquote>
<p>join:阻塞等待子线程结束,不获取其返回值</p>
<p>started:返回线程运行标志状态</p>
<p>tid:返回线程id</p>
<p>name:返回程序设置的线程名称</p>
<p>setDefaultName:设置线程的名称</p>
<p>numCreated:返回已经启动的线程个数</p>
</blockquote>
<p>变量:</p>
<blockquote>
<p>bool started_:线程运行标志<br>bool joined_:回收线程标志<br>pthread_t pthreadId_:进程内线程的id<br>pid_t tid_:线程全局id<br>ThreadFunc func_:线程执行函数<br>string name_:线程名称<br>CountDownLatch latch_:一个倒计时门闩类</p>
<p>static AtomicInt32 numCreated_:启动线程计数</p>
</blockquote>
<h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p><img src="/images/UML/CountDownLatch.png" alt="CountDownLatch"></p>
<blockquote>
<p>CountDownLatch类</p>
<p>既可以用于所有子线程等待主线程发起 “起跑” :在子线程中调用wait等待,主线程调用countDown判断是否唤醒子线程<br>也可以用于主线程等待子线程初始化完毕才开始工作:在主线程中调用wait等待,子线程调用countDown判断是否唤醒主线程</p>
</blockquote>
<h4 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">CountDownLatch::CountDownLatch(<span class="keyword">int</span> count)</span><br><span class="line">  : mutex_(),<span class="comment">//现场调用MutexLock类的构造函数初始化mutex_</span></span><br><span class="line">    condition_(mutex_),</span><br><span class="line">    count_(count)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CountDownLatch::wait</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(mutex_)</span></span>;<span class="comment">//MutexLockGuard使用RAII技术封装</span></span><br><span class="line">  <span class="keyword">while</span> (count_ &gt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    condition_.wait();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>condition_.wait先设置mutex_无拥有者,而后调用pthread_cond_wait</p>
<p>pthread_cond_wait接收一个加了锁的互斥量,pthread_cond_wait对其进行解锁而后将调用pthread_cond_wait函数的线程放在等待条件变量的线程列表上休眠等待唤醒,当pthread_cond_wait被唤醒返回时会对互斥量重新加锁.</p>
</blockquote>
<h4 id="其他成员"><a href="#其他成员" class="headerlink" title="其他成员"></a>其他成员</h4><h5 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h5><blockquote>
<p>void countDown():对成员变量count_进行–操作,判断条件唤醒等待线程</p>
<p>int getCount() const:返回当前count_的值</p>
</blockquote>
<h5 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h5><blockquote>
<p>MutexLock mutex_:作者自己使用pthread_mutex_t封装的一个互斥量<br>Condition condition_ :作者自己封装的一个条件变量</p>
<p>int count_:倒计时变量,用于判断是否唤醒等待线程</p>
</blockquote>
]]></content>
      <categories>
        <category>开源代码</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>muduo</tag>
      </tags>
  </entry>
  <entry>
    <title>muduo-Exception</title>
    <url>/posts/17325df2/</url>
    <content><![CDATA[<p>Exception类继承于标准库的exception类,其作用为处理异常并保存调用堆栈,以供后续错误排查.</p>
<a id="more"></a>

<h3 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h3><p><img src="/images/UML/Exception.png" alt="Exception"></p>
<p>下面是Exception类的声明</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Exception</span> :</span> <span class="keyword">public</span> <span class="built_in">std</span>::exception</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  Exception(<span class="built_in">string</span> what);</span><br><span class="line">  ~Exception() <span class="keyword">noexcept</span> <span class="keyword">override</span> = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// default copy-ctor and operator= are okay.可以使用默认的拷贝构造函数和赋值运算符</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">what</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> message_.c_str();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">stackTrace</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> stack_.c_str();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">string</span> message_;</span><br><span class="line">  <span class="built_in">string</span> stack_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面类的定义中有c++11以后所提供的新语法</p>
<p>noexcept:修饰函数不抛出异常</p>
<p>override:若函数用其修饰,其继承的父类中必须提供同名的虚函数</p>
<p>=default:如果一个 C++ 类没有显式地给出构造函数、析构函数、拷贝构造函数、operator = 这几类函数的实现，在需要它们时，编译器会自动生成；或者，在给出这些函数的声明时，如果没有给出其实现，编译器在链接时就会报错。**=default** 如果标记这类函数，编译器会给出默认实现。</p>
</blockquote>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Exception::Exception(<span class="built_in">string</span> msg)</span><br><span class="line">  : message_(<span class="built_in">std</span>::move(msg)),</span><br><span class="line">    stack_(CurrentThread::stackTrace(<span class="comment">/*demangle=*/</span><span class="literal">false</span>))</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CurrentThread::stackTrace函数在另外一个命名空间所定义</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">stackTrace</span><span class="params">(<span class="keyword">bool</span> demangle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">string</span> <span class="built_in">stack</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> max_frames = <span class="number">200</span>;</span><br><span class="line">  <span class="keyword">void</span>* frame[max_frames];</span><br><span class="line">  <span class="keyword">int</span> nptrs = ::backtrace(frame, max_frames);</span><br><span class="line">  <span class="keyword">char</span>** strings = ::backtrace_symbols(frame, nptrs);</span><br><span class="line">  <span class="keyword">if</span> (strings)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">size_t</span> len = <span class="number">256</span>;</span><br><span class="line">    <span class="keyword">char</span>* demangled = demangle ? <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>*&gt;(::<span class="built_in">malloc</span>(len)) : <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nptrs; ++i)  <span class="comment">// skipping the 0-th, which is this function</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (demangle)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// https://panthema.net/2008/0901-stacktrace-demangled/</span></span><br><span class="line">        <span class="comment">// bin/exception_test(_ZN3Bar4testEv+0x79) [0x401909]</span></span><br><span class="line">        <span class="keyword">char</span>* left_par = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">char</span>* plus = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span>* p = strings[i]; *p; ++p)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (*p == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">            left_par = p;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (*p == <span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">            plus = p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left_par &amp;&amp; plus)</span><br><span class="line">        &#123;</span><br><span class="line">          *plus = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">          <span class="keyword">int</span> status = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">char</span>* ret = abi::__cxa_demangle(left_par+<span class="number">1</span>, demangled, &amp;len, &amp;status);</span><br><span class="line">          *plus = <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">          <span class="keyword">if</span> (status == <span class="number">0</span>)</span><br><span class="line">          &#123;</span><br><span class="line">            demangled = ret;  <span class="comment">// ret could be realloc()</span></span><br><span class="line">            <span class="built_in">stack</span>.append(strings[i], left_par+<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">stack</span>.append(demangled);</span><br><span class="line">            <span class="built_in">stack</span>.append(plus);</span><br><span class="line">            <span class="built_in">stack</span>.push_back(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Fallback to mangled names</span></span><br><span class="line">      <span class="built_in">stack</span>.append(strings[i]);</span><br><span class="line">      <span class="built_in">stack</span>.push_back(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(demangled);</span><br><span class="line">    <span class="built_in">free</span>(strings);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">stack</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>几个主要用到的函数</p>
<blockquote>
<p>backtrace，栈回溯，保存各个栈帧的地址<br>backtrace_symbols，根据地址，转成相应的函数符号<br>abi::__cxa_demangle:c++中的函数符号都经过编译器处理，恢复回来并非原来的函数签名的样子，调用abi::__cxa_demangle可以将其恢复为编写的函数签名</p>
</blockquote>
<h4 id="backtrace"><a href="#backtrace" class="headerlink" title="backtrace"></a>backtrace</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;execinfo.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">backtrace</span><span class="params">(<span class="keyword">void</span> **buffer, <span class="keyword">int</span> size)</span></span>;</span><br></pre></td></tr></table></figure>

<p>第一步调用该函数返回一堆调用函数的地址及地址个数,调用返回示例</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">buffer:</span><br><span class="line"></span><br><span class="line">[<span class="number">0</span>] = &#123;<span class="keyword">void</span> * | <span class="number">0x55aa0653cbfb</span>&#125; <span class="number">0x55aa0653cbfb</span></span><br><span class="line">[<span class="number">1</span>] = &#123;<span class="keyword">void</span> * | <span class="number">0x55aa0653b8bc</span>&#125; <span class="number">0x55aa0653b8bc</span></span><br><span class="line">[<span class="number">2</span>] = &#123;<span class="keyword">void</span> * | <span class="number">0x55aa0653b571</span>&#125; <span class="number">0x55aa0653b571</span></span><br><span class="line">[<span class="number">3</span>] = &#123;<span class="keyword">void</span> * | <span class="number">0x55aa0653b5c3</span>&#125; <span class="number">0x55aa0653b5c3</span></span><br><span class="line">[<span class="number">4</span>] = &#123;<span class="keyword">void</span> * | <span class="number">0x7f8d01a5cb97</span>&#125; <span class="number">0x7f8d01a5cb97</span></span><br><span class="line">[<span class="number">5</span>] = &#123;<span class="keyword">void</span> * | <span class="number">0x55aa0653b45a</span>&#125; <span class="number">0x55aa0653b45a</span></span><br><span class="line"></span><br><span class="line">[<span class="number">6</span>] = &#123;<span class="keyword">void</span> * | <span class="number">0x0</span>&#125; <span class="literal">NULL</span></span><br><span class="line"></span><br><span class="line">size=<span class="number">6</span></span><br></pre></td></tr></table></figure>

<h4 id="backtrace-symbols"><a href="#backtrace-symbols" class="headerlink" title="backtrace_symbols"></a>backtrace_symbols</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;execinfo.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> **<span class="title">backtrace_symbols</span><span class="params">(<span class="keyword">void</span> *<span class="keyword">const</span> *buffer, <span class="keyword">int</span> size)</span></span>;</span><br></pre></td></tr></table></figure>

<p>将函数地址转化为c++编译生成的函数签名</p>
<blockquote>
<p>转换例子</p>
<p>“/home/wxl/date/code/clion/muduo/cmake-build-debug/bin/exception_test(_ZN5muduo13CurrentThread10stackTraceB5cxx11Eb+0x57) [0x55aa0653cbfb]”</p>
</blockquote>
<h4 id="abi-cxa-demangle"><a href="#abi-cxa-demangle" class="headerlink" title="abi::__cxa_demangle"></a>abi::__cxa_demangle</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cxxabi.h&gt;</span></span></span><br><span class="line"><span class="keyword">char</span>* abi::__cxa_demangle(<span class="keyword">const</span> <span class="keyword">char</span>* mangled_name, <span class="keyword">char</span>* output_buffer, <span class="keyword">size_t</span>* length, <span class="keyword">int</span>* status)</span><br></pre></td></tr></table></figure>

<p>将c++编译生成的函数签名反汇编成原来的函数签名</p>
<blockquote>
<p>_ZN3Bar4testESt6vectorINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESaIS6_EE+0x3c经过转换为</p>
<p>Bar::test(std::vector&lt;std::__cxx11::basic_string&lt;char, std::char_traits, std::allocator &gt;, std::allocator&lt;std::__cxx11::basic_string&lt;char, std::char_traits, std::allocator &gt; &gt; &gt;)</p>
</blockquote>
]]></content>
      <categories>
        <category>开源代码</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>muduo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/posts/4a17b156/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<a id="more"></a>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <tags>
        <tag>hello</tag>
      </tags>
  </entry>
  <entry>
    <title>muduo-Atimic-and-Type</title>
    <url>/posts/d72bd296/</url>
    <content><![CDATA[<p>muduo网络库中原子操作的封装和类型转换函数</p>
<h3 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h3><blockquote>
<p>原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何线程切换</p>
</blockquote>
<a id="more"></a>

<p>在代码编写时，写出的一条语句cpu并不是一次就能执行，通常一条c代码会被翻译成多行汇编指令，而cpu执行的最小单位便是一条汇编指令.例如一个i++操作会分成一下几步:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">load eax, i#将内存中的至读入寄存器eax中</span><br><span class="line">add eax, 1#是寄存器加1实现自增1操作		</span><br><span class="line">store x, eax#将寄存器的值写会内存</span><br></pre></td></tr></table></figure>

<p>在但线程或者没有线程切换时代码的执行结果是无误的，而当两个线程同时执行，并对x进行自增操作时,如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#time    Thread 1		Thread 2</span><br><span class="line">	0			load eax, x</span><br><span class="line"> 	1									load eax, x</span><br><span class="line">	2			add eax, 1		</span><br><span class="line">	3									add eax, 1</span><br><span class="line">	4			store x, eax</span><br><span class="line"> 	5									store x, eax</span><br></pre></td></tr></table></figure>

<blockquote>
<p>两个线程分别对x(假设x的初始值为10)进行自增操作，执行结束后x的值应当比原来多2,但若是发生线程切换如上述代码，Thread1将x从内存中取出保存至寄存器(eax值为10)而后发生线程切换，保存Thread1当前调用堆栈切换至Thread2,此时Thread2又将内存中的x取入寄存器(eax值为10),而后又发生线程切换，保持Thread2调用堆栈并恢复Thread1堆栈切换至Thread1,此时Thread1的eax为10,应当继续执行add操作，add操作执行结束后再次发生线程切换，保存THread1调用堆栈并恢复Thread2堆栈切换至Thread2,此时寄存器调用现场为原来保存的Thread2调用现场eax值为10,应当继续执行add操作,add操作执行结束后保持调用现场切换至Thread1,恢复Thread1的堆栈并继续执行将eax(值为11)中的值写回内存，Thread1结束切换至Thread2，恢复Thread2堆栈,eax为11,而后继续执行将值写回内存，Thread2结束.两个线程执行结束后x的值并非是预期的12而是11.若需要得到预期结果要么进行封锁处理使得线程无法切换，但这样开销过大，要么就将load eax;add eax, 1;store x, eax三条指令封装成一个不可分割的原子操作，即要么不执行这三条指令，如果执行就必须将三条指令都执行完成才能进行线程切换.</p>
</blockquote>
<h3 id="AtomicIntegerT"><a href="#AtomicIntegerT" class="headerlink" title="AtomicIntegerT"></a>AtomicIntegerT</h3><p><img src="/images/UML/AtomicIntegerT.png" alt="AtomicIntegerT"></p>
<p>AtomicIntegerT有三个核心函数其他函数均为这三个函数演变而来</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//class AtomicIntegerT : noncopyable //继承于noncopyable不可拷贝不可复制</span></span><br></pre></td></tr></table></figure>

<h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">T <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> __sync_val_compare_and_swap(&amp;value_, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>__sync_val_compare_and_swap</p>
<p>type __sync_val_compare_and_swap (type *ptr, type oldval type newval)</p>
<p>先比较*ptr和oldval的值是否相等，若相等设置 *ptr的值为newval，返回*ptr</p>
</blockquote>
<h4 id="getAndAdd"><a href="#getAndAdd" class="headerlink" title="getAndAdd"></a>getAndAdd</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">T <span class="title">getAndAdd</span><span class="params">(T x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> __sync_fetch_and_add(&amp;value_, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>__sync_fetch_and_add</p>
<p>type __sync_fetch_and_add (type *ptr, type value)</p>
<p>先获取*ptr的值而后加上value所以返回的值是*ptr原来的值</p>
</blockquote>
<h4 id="getAndSet"><a href="#getAndSet" class="headerlink" title="getAndSet"></a>getAndSet</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">T <span class="title">getAndSet</span><span class="params">(T newValue)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> __sync_lock_test_and_set(&amp;value_, newValue);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>__sync_lock_test_and_set</p>
<p>bool __sync_bool_compare_and_swap (type *ptr, type oldval type newval)</p>
<p>先比较*ptr和oldval的值是否相等，若相等设置 *ptr的值为newval，返回true,不相等返回false</p>
<p>上面三个函数调用的函数均为gcc提供的原子操作.</p>
</blockquote>
<h4 id="其余函数"><a href="#其余函数" class="headerlink" title="其余函数"></a>其余函数</h4><blockquote>
<p>T addAndGe(T x):将value_加上x并返回其加上x的值</p>
<p>T incrementAndGet():value_自增1并返回加1后的大小</p>
<p>T incrementAndGet():value_自减1并返回加1后的大小</p>
<p>void add(T x):将value_加上x</p>
<p>void increment():value_自增1不返回<br>void decrement()value_自减1不返回</p>
<p>最后AtomicIntegerT还提供了两个数据类型</p>
<p>typedef detail::AtomicIntegerT<int32_t> AtomicInt32;<br>typedef detail::AtomicIntegerT<int64_t> AtomicInt64;</p>
</blockquote>
<h3 id="Types"><a href="#Types" class="headerlink" title="Types"></a>Types</h3><blockquote>
<p>Types头文件定义了两个类型转换函数</p>
</blockquote>
<h4 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> To, <span class="keyword">typename</span> From&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> To <span class="title">implicit_cast</span><span class="params">(From <span class="keyword">const</span> &amp;f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>目的是便于阅读代码，阅读是看到implicit_cast可知发生了隐式类型转换,例如:</p>
<p>int a;</p>
<p>char b;</p>
<p>a=b;&lt;=&gt;implicit_cast&lt;int,char&gt;(b)//这两个相等价</p>
</blockquote>
<h4 id="向下类型转换"><a href="#向下类型转换" class="headerlink" title="向下类型转换"></a>向下类型转换</h4><blockquote>
<p>派生类转换为基类</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> To, <span class="keyword">typename</span> From&gt;     <span class="comment">// use like this: down_cast&lt;T*&gt;(foo);</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> To <span class="title">down_cast</span><span class="params">(From* f)</span>                   </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>)<span class="comment">//永远为假</span></span><br><span class="line">  &#123;</span><br><span class="line">    implicit_cast&lt;From*, To&gt;(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(NDEBUG) &amp;&amp; !defined(GOOGLE_PROTOBUF_NO_RTTI)<span class="comment">//如果是调试状态并且有开启运行时类型识别</span></span></span><br><span class="line">  assert(f == <span class="literal">NULL</span> || <span class="keyword">dynamic_cast</span>&lt;To&gt;(f) != <span class="literal">NULL</span>);  <span class="comment">// RTTI: debug mode only!，判断能否进行向下转型，空指针可以向下转型</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;To&gt;(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>开源代码</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>muduo</tag>
      </tags>
  </entry>
  <entry>
    <title>muduo网络库-Timestamp类</title>
    <url>/posts/7808c5f/</url>
    <content><![CDATA[<h3 id="源码及教程"><a href="#源码及教程" class="headerlink" title="源码及教程"></a>源码及教程</h3><h4 id="muduo源码-https-github-com-chenshuo-muduo-git"><a href="#muduo源码-https-github-com-chenshuo-muduo-git" class="headerlink" title="muduo源码:https://github.com/chenshuo/muduo.git"></a>muduo源码:<a href="https://github.com/chenshuo/muduo.git">https://github.com/chenshuo/muduo.git</a></h4><h4 id="教程："><a href="#教程：" class="headerlink" title="教程："></a>教程：</h4><h5 id="视频-https-www-bilibili-com-video-BV11b411q7zr-t-2368-amp-p-10"><a href="#视频-https-www-bilibili-com-video-BV11b411q7zr-t-2368-amp-p-10" class="headerlink" title="视频:https://www.bilibili.com/video/BV11b411q7zr?t=2368&amp;p=10"></a>视频:<a href="https://www.bilibili.com/video/BV11b411q7zr?t=2368&amp;p=10">https://www.bilibili.com/video/BV11b411q7zr?t=2368&amp;p=10</a></h5><h5 id="对应配套材料-https-github-com-iceCream1997-muduo-server-learn"><a href="#对应配套材料-https-github-com-iceCream1997-muduo-server-learn" class="headerlink" title="对应配套材料:https://github.com/iceCream1997/muduo_server_learn"></a>对应配套材料:<a href="https://github.com/iceCream1997/muduo_server_learn">https://github.com/iceCream1997/muduo_server_learn</a></h5><h5 id="作者博客-https-www-cnblogs-com-Solstice"><a href="#作者博客-https-www-cnblogs-com-Solstice" class="headerlink" title="作者博客:https://www.cnblogs.com/Solstice/"></a>作者博客:<a href="https://www.cnblogs.com/Solstice/">https://www.cnblogs.com/Solstice/</a></h5><a id="more"></a>

<h3 id="Timestamp"><a href="#Timestamp" class="headerlink" title="Timestamp"></a>Timestamp</h3><blockquote>
<p>Timestamp是一个时间戳转换类，获取unix时间戳并以微妙保存，并按照所需格式输出为年月日等.Tiimestamp公有继承于三个类</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> muduo::copyable,<span class="comment">//继承以表示类不能拷贝</span></span><br><span class="line"><span class="keyword">public</span> boost::equality_comparable&lt;Timestamp&gt;,<span class="comment">//继承使用此类可以只重写operator== ;!=会自动生成</span></span><br><span class="line"><span class="keyword">public</span> boost::less_than_comparable&lt;Timestamp&gt;<span class="comment">//继承使用此类可以只重写operator&lt; ;&lt;= ,&gt;会自动生成</span></span><br></pre></td></tr></table></figure>

<h4 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h4><p><img src="/images/UML/TimeStamp.png" alt="Timestamp"></p>
<h4 id="简单成员函数"><a href="#简单成员函数" class="headerlink" title="简单成员函数"></a>简单成员函数</h4><blockquote>
<p>Timestamp提供了两个构造函数一个无参默认设置微妙时间为0,一个参数为int64_t的构造函数可以使用静态成员函数now来获取时间戳并传入参数进行构造.valid函数用于判断成员变量的有效性(时间必须大于0).两个fromUnixTime函数用于将时间戳转化为微妙保存于成员变量.</p>
</blockquote>
<h4 id="now"><a href="#now" class="headerlink" title="now"></a>now</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//static Timestamp now();</span></span><br><span class="line"><span class="function">Timestamp <span class="title">Timestamp::now</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">  gettimeofday(&amp;tv, <span class="literal">NULL</span>);<span class="comment">//第一个为时间结构体，第二个参数关于时区</span></span><br><span class="line">  <span class="keyword">int64_t</span> seconds = tv.tv_sec;</span><br><span class="line">  <span class="keyword">return</span> Timestamp(seconds * kMicroSecondsPerSecond + tv.tv_usec);<span class="comment">//返回的描述乘上倍数关系并加上返回的微妙数即可得到时间戳的微妙形式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">Timestamp::toString</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">int64_t</span> seconds = microSecondsSinceEpoch_ / kMicroSecondsPerSecond;</span><br><span class="line">  <span class="keyword">int64_t</span> microseconds = microSecondsSinceEpoch_ % kMicroSecondsPerSecond;</span><br><span class="line">  <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf), <span class="string">&quot;%&quot;</span> PRId64 <span class="string">&quot;.%06&quot;</span> PRId64 <span class="string">&quot;&quot;</span>, seconds, microseconds);</span><br><span class="line">  <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>将微妙转换为seconds.microseconds即秒.微妙,PRI是一个宏用于兼容32位平台和64位平台long大小不一样，在64位系统下PRI展开为ll，32位下则展开为l.</p>
<p>输出示例:1593414211.736930</p>
</blockquote>
<h4 id="toFormattedString"><a href="#toFormattedString" class="headerlink" title="toFormattedString"></a>toFormattedString</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">Timestamp::toFormattedString</span><span class="params">(<span class="keyword">bool</span> showMicroseconds)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">64</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">time_t</span> seconds = <span class="keyword">static_cast</span>&lt;<span class="keyword">time_t</span>&gt;(microSecondsSinceEpoch_ / kMicroSecondsPerSecond);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">tm_time</span>;</span></span><br><span class="line">  gmtime_r(&amp;seconds, &amp;tm_time);<span class="comment">//将时间戳转化为年月日，线程安全函数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (showMicroseconds)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">int</span> microseconds = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(microSecondsSinceEpoch_ % kMicroSecondsPerSecond);</span><br><span class="line">    <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf), <span class="string">&quot;%4d%02d%02d %02d:%02d:%02d.%06d&quot;</span>,</span><br><span class="line">             tm_time.tm_year + <span class="number">1900</span>, tm_time.tm_mon + <span class="number">1</span>, tm_time.tm_mday,</span><br><span class="line">             tm_time.tm_hour, tm_time.tm_min, tm_time.tm_sec,</span><br><span class="line">             microseconds);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf), <span class="string">&quot;%4d%02d%02d %02d:%02d:%02d&quot;</span>,</span><br><span class="line">             tm_time.tm_year + <span class="number">1900</span>, tm_time.tm_mon + <span class="number">1</span>, tm_time.tm_mday,</span><br><span class="line">             tm_time.tm_hour, tm_time.tm_min, tm_time.tm_sec);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>showMicroseconds控制是否打印出微妙,输出示例:20200629 07:03:31.736930</p>
</blockquote>
<h4 id="非成员函数"><a href="#非成员函数" class="headerlink" title="非成员函数"></a>非成员函数</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">timeDifference</span><span class="params">(Timestamp high, Timestamp low)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//用于计算两个时间差</span></span><br><span class="line">  <span class="keyword">int64_t</span> diff = high.microSecondsSinceEpoch() - low.microSecondsSinceEpoch();</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(diff) / Timestamp::kMicroSecondsPerSecond;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Timestamp <span class="title">addTime</span><span class="params">(Timestamp timestamp, <span class="keyword">double</span> seconds)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//在原有的时间上加上seconds * Timestamp::kMicroSecondsPerSecond微妙</span></span><br><span class="line">  <span class="keyword">int64_t</span> delta = <span class="keyword">static_cast</span>&lt;<span class="keyword">int64_t</span>&gt;(seconds * Timestamp::kMicroSecondsPerSecond);</span><br><span class="line">  <span class="keyword">return</span> Timestamp(timestamp.microSecondsSinceEpoch() + delta);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="flamingo"><a href="#flamingo" class="headerlink" title="flamingo"></a>flamingo</h3><blockquote>
<p>和muduo不同的是flamingo没有采用boost库因而代码移植性较好，且flamingo可跨平台，其成员函数实现也与muduo有所差异</p>
</blockquote>
<h4 id="now-1"><a href="#now-1" class="headerlink" title="now"></a>now</h4><blockquote>
<p>flamingo使用c++标准库chrono来获取时间对成员变量进行初始化</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//static Timestamp now();</span></span><br><span class="line"><span class="function">Timestamp <span class="title">Timestamp::now</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	chrono::time_point&lt;chrono::system_clock, chrono::microseconds&gt; now = chrono::time_point_cast&lt;chrono::microseconds&gt;(</span><br><span class="line">		chrono::system_clock::now());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int64_t</span> microSeconds = now.time_since_epoch().count();</span><br><span class="line">	<span class="function">Timestamp <span class="title">time</span><span class="params">(microSeconds)</span></span>;</span><br><span class="line">	<span class="keyword">return</span> time;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Timestamp类可以继续用于实现时间轮、日志系统等</p>
</blockquote>
]]></content>
      <categories>
        <category>开源代码</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>muduo</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp中的各种引用</title>
    <url>/posts/55f877b6/</url>
    <content><![CDATA[<p>引用不能引用数组</p>
<h3 id="引用大小测试"><a href="#引用大小测试" class="headerlink" title="引用大小测试"></a>引用大小测试</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> &amp;  a;                                                                                                                                                                                                      </span><br><span class="line">    <span class="keyword">char</span> &amp;  b;  </span><br><span class="line">    <span class="keyword">char</span> &amp; c;<span class="comment">//引用的本质是指针，直接sizeof引用，就是求引用的数据大小</span></span><br><span class="line">	<span class="comment">//引用变量占据8个字节，平台为liunx X86_64</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">10</span>; </span><br><span class="line">    <span class="function"><span class="keyword">int</span> &amp; <span class="title">rnum</span><span class="params">(num)</span></span>;</span><br><span class="line">    <span class="keyword">double</span> db = <span class="number">10.9</span>;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> &amp; <span class="title">rdb</span><span class="params">(db)</span></span>;<span class="comment">//直接作用引用的变量</span></span><br><span class="line">    <span class="comment">//测试引用变量所占的大小</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(rnum) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;<span class="comment">//sizeof直接作用于引用的变量所以大小为该类型数据的值</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(rdb) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(MyClass) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">out:</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">24</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="左值引用"><a href="#左值引用" class="headerlink" title="左值引用"></a>左值引用</h3><h4 id="返回栈中数据"><a href="#返回栈中数据" class="headerlink" title="返回栈中数据"></a>返回栈中数据</h4><h5 id="局部基本数据类型"><a href="#局部基本数据类型" class="headerlink" title="局部基本数据类型"></a>局部基本数据类型</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//该程序运行会产生段错误，原因是访问了已经释放的栈变量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp;  <span class="title">mac</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num=<span class="number">10</span>;</span><br><span class="line">	<span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   	<span class="comment">//用基本数据来接收返回值</span></span><br><span class="line">	<span class="keyword">int</span> i=mac();、</span><br><span class="line">     <span class="comment">//用引用来接收返回值</span></span><br><span class="line">    <span class="keyword">int</span> &amp;p=mac();</span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;p&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">asm</span>:#无关代码已略去</span><br><span class="line"><span class="function">Dump of assembler code <span class="keyword">for</span> function <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">...</span><br><span class="line">   <span class="number">0x0000555555554a3c</span> &lt;+<span class="number">8</span>&gt;:	call   <span class="number">0x555555554955</span> &lt;mac()&gt;</span><br><span class="line">   <span class="number">0x0000555555554a41</span> &lt;+<span class="number">13</span>&gt;:	mov    eax,DWORD PTR [rax]</span><br><span class="line">   <span class="number">0x0000555555554a43</span> &lt;+<span class="number">15</span>&gt;:	mov    DWORD PTR [rbp<span class="number">-0xc</span>],eax</span><br><span class="line">   <span class="number">0x0000555555554a46</span> &lt;+<span class="number">18</span>&gt;:	call   <span class="number">0x555555554955</span> &lt;mac()&gt;</span><br><span class="line">=&gt; <span class="number">0x0000555555554a4b</span> &lt;+<span class="number">23</span>&gt;:	mov    QWORD PTR [rbp<span class="number">-0x8</span>],rax</span><br><span class="line">...</span><br><span class="line">   <span class="number">0x0000555555554aa4</span> &lt;+<span class="number">112</span>&gt;:	ret    </span><br><span class="line">End of assembler dump.</span><br><span class="line"> </span><br><span class="line">       <span class="comment">//实际gcc编译生成的汇编不是如此，此处是使用全局num生成的汇编，</span></span><br><span class="line">Dump of assembler code <span class="keyword">for</span> function mac():</span><br><span class="line">   <span class="number">0x0000555555554955</span> &lt;+<span class="number">0</span>&gt;:	push   rbp</span><br><span class="line">   <span class="number">0x0000555555554956</span> &lt;+<span class="number">1</span>&gt;:	mov    rbp,rsp</span><br><span class="line">   <span class="number">0x0000555555554959</span> &lt;+<span class="number">4</span>&gt;:	mov    DWORD PTR [rip+<span class="number">0x2017d1</span>],<span class="number">0xa</span>        # <span class="number">0x555555756134</span> &lt;num&gt;</span><br><span class="line">   <span class="number">0x0000555555554963</span> &lt;+<span class="number">14</span>&gt;:	lea    rax,[rip+<span class="number">0x2017ca</span>]        # <span class="number">0x555555756134</span> &lt;num&gt;</span><br><span class="line">=&gt; <span class="number">0x000055555555496a</span> &lt;+<span class="number">21</span>&gt;:	pop    rbp</span><br><span class="line">   <span class="number">0x000055555555496b</span> &lt;+<span class="number">22</span>&gt;:	ret    </span><br><span class="line">End of assembler dump.</span><br><span class="line">       vs2015中反汇编mac</span><br><span class="line">       <span class="number">00F</span>721F8 C7 <span class="number">45</span> F4 <span class="number">0</span>A <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> mov         dword ptr [num],<span class="number">0</span>Ah  </span><br><span class="line">    	<span class="keyword">int</span> i = (<span class="keyword">int</span>)&amp;num;</span><br><span class="line"><span class="number">00F</span>721FF <span class="number">8</span>D <span class="number">45</span> F4             lea         eax,[num]  </span><br><span class="line"><span class="number">00F</span>72202 <span class="number">89</span> <span class="number">45</span> E8             mov         dword ptr [i],eax  </span><br><span class="line">     	<span class="keyword">return</span> num;</span><br><span class="line"><span class="number">00F</span>72205 <span class="number">8</span>D <span class="number">45</span> F4             lea         eax,[num]  </span><br><span class="line">gdb中反汇编</span><br><span class="line">    <span class="function">Dump of assembler code <span class="keyword">for</span> function <span class="title">mac</span><span class="params">()</span>:</span></span><br><span class="line">   0x00005555555549e8 &lt;+0&gt;:	push   rbp</span><br><span class="line">   <span class="number">0x00005555555549e9</span> &lt;+<span class="number">1</span>&gt;:	mov    rbp,rsp</span><br><span class="line">   <span class="number">0x00005555555549ec</span> &lt;+<span class="number">4</span>&gt;:	sub    rsp,<span class="number">0x10</span></span><br><span class="line">   <span class="number">0x00005555555549f0</span> &lt;+<span class="number">8</span>&gt;:	mov    rax,QWORD PTR fs:<span class="number">0x28</span></span><br><span class="line">   <span class="number">0x00005555555549f9</span> &lt;+<span class="number">17</span>&gt;:	mov    QWORD PTR [rbp<span class="number">-0x8</span>],rax</span><br><span class="line">   <span class="number">0x00005555555549fd</span> &lt;+<span class="number">21</span>&gt;:	<span class="keyword">xor</span>    eax,eax</span><br><span class="line">   <span class="number">0x00005555555549ff</span> &lt;+<span class="number">23</span>&gt;:	mov    DWORD PTR [rbp<span class="number">-0xc</span>],<span class="number">0xa</span></span><br><span class="line">=&gt; <span class="number">0x0000555555554a06</span> &lt;+<span class="number">30</span>&gt;:	mov    eax,<span class="number">0x0</span></span><br><span class="line">   <span class="number">0x0000555555554a0b</span> &lt;+<span class="number">35</span>&gt;:	mov    rdx,QWORD PTR [rbp<span class="number">-0x8</span>]</span><br><span class="line">   <span class="number">0x0000555555554a0f</span> &lt;+<span class="number">39</span>&gt;:	<span class="keyword">xor</span>    rdx,QWORD PTR fs:<span class="number">0x28</span></span><br><span class="line">   <span class="number">0x0000555555554a18</span> &lt;+<span class="number">48</span>&gt;:	je     <span class="number">0x555555554a1f</span> &lt;mac()+<span class="number">55</span>&gt;</span><br><span class="line">   <span class="number">0x0000555555554a1a</span> &lt;+<span class="number">50</span>&gt;:	call   <span class="number">0x555555554850</span> &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">   <span class="number">0x0000555555554a1f</span> &lt;+<span class="number">55</span>&gt;:	leave  </span><br><span class="line">   <span class="number">0x0000555555554a20</span> &lt;+<span class="number">56</span>&gt;:	ret    </span><br><span class="line">End of assembler dump.gdb中对栈进行了检查</span><br></pre></td></tr></table></figure>

<blockquote>
<p>用基本数据类型接收时:mac函数执行，将临时变量num的地址存入rax寄存器中作为返回值，函数返回后在main函数中取出该地址的值存入变量i中</p>
<p>用引用接收是:mac函数执行，将临时变量num的地址存入rax寄存器中作为返回值，函数返回后在main函数直接将该地址取出存入引用变量当中，之后一系列操作均通过引用变量中保存的地址值来完成，若之后调用一些函数执行，则有可能会覆盖之前mac函数的堆栈，导致数据错误，并且当mac函数执行结束返回后该调用堆栈在系统中已经处于回收状态，是不可用的。</p>
</blockquote>
<h5 id="局部类"><a href="#局部类" class="headerlink" title="局部类"></a>局部类</h5><h6 id="先看一个不用引用作为函数返回值的函数"><a href="#先看一个不用引用作为函数返回值的函数" class="headerlink" title="先看一个不用引用作为函数返回值的函数"></a>先看一个不用引用作为函数返回值的函数</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Struct</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> a,b,c,d;</span><br><span class="line">	<span class="keyword">int</span> aa[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Struct <span class="title">Smac</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Struct test;</span><br><span class="line">	test.a=<span class="number">1</span>;</span><br><span class="line">	test.b=<span class="number">2</span>;</span><br><span class="line">	test.c=<span class="number">3</span>;</span><br><span class="line">	test.d=<span class="number">4</span>;</span><br><span class="line">	<span class="keyword">return</span> test;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Struct p=Smac();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>函数返回时会进行内存复制，详细过程会在后续介绍</p>
</blockquote>
<h6 id="引用作为函数返回值"><a href="#引用作为函数返回值" class="headerlink" title="引用作为函数返回值"></a>引用作为函数返回值</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//程序是错误的</span></span><br><span class="line"><span class="function">Struct&amp; <span class="title">Smac</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Struct test;</span><br><span class="line">	test.a=<span class="number">1</span>;</span><br><span class="line">	test.b=<span class="number">2</span>;</span><br><span class="line">	test.c=<span class="number">3</span>;</span><br><span class="line">	test.d=<span class="number">4</span>;</span><br><span class="line">	<span class="keyword">return</span> test;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Struct p=Smac();</span><br><span class="line">	Struct&amp; pp=Smac();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">asm</span>:</span><br><span class="line"><span class="function">Dump of assembler code <span class="keyword">for</span> function <span class="title">Smac</span><span class="params">()</span>:</span></span><br><span class="line">   0x00005555555547aa &lt;+0&gt;:	push   rbp</span><br><span class="line">   <span class="number">0x00005555555547ab</span> &lt;+<span class="number">1</span>&gt;:	mov    rbp,rsp</span><br><span class="line">   <span class="number">0x00005555555547ae</span> &lt;+<span class="number">4</span>&gt;:	sub    rsp,<span class="number">0x40</span></span><br><span class="line">   <span class="number">0x00005555555547b2</span> &lt;+<span class="number">8</span>&gt;:	mov    rax,QWORD PTR fs:<span class="number">0x28</span></span><br><span class="line">   <span class="number">0x00005555555547bb</span> &lt;+<span class="number">17</span>&gt;:	mov    QWORD PTR [rbp<span class="number">-0x8</span>],rax</span><br><span class="line">   <span class="number">0x00005555555547bf</span> &lt;+<span class="number">21</span>&gt;:	<span class="keyword">xor</span>    eax,eax</span><br><span class="line">   <span class="number">0x00005555555547c1</span> &lt;+<span class="number">23</span>&gt;:	mov    DWORD PTR [rbp<span class="number">-0x40</span>],<span class="number">0x1</span></span><br><span class="line">   <span class="number">0x00005555555547c8</span> &lt;+<span class="number">30</span>&gt;:	mov    DWORD PTR [rbp<span class="number">-0x3c</span>],<span class="number">0x2</span></span><br><span class="line">   <span class="number">0x00005555555547cf</span> &lt;+<span class="number">37</span>&gt;:	mov    DWORD PTR [rbp<span class="number">-0x38</span>],<span class="number">0x3</span></span><br><span class="line">   <span class="number">0x00005555555547d6</span> &lt;+<span class="number">44</span>&gt;:	mov    DWORD PTR [rbp<span class="number">-0x34</span>],<span class="number">0x4</span></span><br><span class="line">   <span class="number">0x00005555555547dd</span> &lt;+<span class="number">51</span>&gt;:	mov    eax,<span class="number">0x0</span><span class="comment">//将0地址放入了返回值，访问时会出现异常，导致程序崩溃</span></span><br><span class="line">   <span class="number">0x00005555555547e2</span> &lt;+<span class="number">56</span>&gt;:	mov    rdx,QWORD PTR [rbp<span class="number">-0x8</span>]</span><br><span class="line">   <span class="number">0x00005555555547e6</span> &lt;+<span class="number">60</span>&gt;:	<span class="keyword">xor</span>    rdx,QWORD PTR fs:<span class="number">0x28</span></span><br><span class="line">   <span class="number">0x00005555555547ef</span> &lt;+<span class="number">69</span>&gt;:	je     <span class="number">0x5555555547f6</span> &lt;Smac()+<span class="number">76</span>&gt;</span><br><span class="line">   <span class="number">0x00005555555547f1</span> &lt;+<span class="number">71</span>&gt;:	call   <span class="number">0x555555554670</span> &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">=&gt; <span class="number">0x00005555555547f6</span> &lt;+<span class="number">76</span>&gt;:	leave  </span><br><span class="line">   <span class="number">0x00005555555547f7</span> &lt;+<span class="number">77</span>&gt;:	ret    </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<h4 id="返回堆中数据"><a href="#返回堆中数据" class="headerlink" title="返回堆中数据"></a>返回堆中数据</h4><h5 id="仅返回引用"><a href="#仅返回引用" class="headerlink" title="仅返回引用"></a>仅返回引用</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Struct</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> a,b,c,d;</span><br><span class="line">	<span class="keyword">int</span> aa[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Struct&amp; <span class="title">Smac</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Struct *test=<span class="keyword">new</span> Struct;</span><br><span class="line">	test-&gt;a=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> *test;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Struct p=Smac();</span><br><span class="line">	Struct&amp; pp=Smac();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">asm</span>:</span><br><span class="line"><span class="function">Dump of assembler code <span class="keyword">for</span> function <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">...</span><br><span class="line">=&gt; <span class="number">0x0000555555554828</span> &lt;+<span class="number">8</span>&gt;:	mov    rax,QWORD PTR fs:<span class="number">0x28</span></span><br><span class="line">   <span class="number">0x0000555555554831</span> &lt;+<span class="number">17</span>&gt;:	mov    QWORD PTR [rbp<span class="number">-0x8</span>],rax</span><br><span class="line">   <span class="number">0x0000555555554835</span> &lt;+<span class="number">21</span>&gt;:	<span class="keyword">xor</span>    eax,eax</span><br><span class="line">   <span class="number">0x0000555555554837</span> &lt;+<span class="number">23</span>&gt;:	call   <span class="number">0x5555555547fa</span> &lt;Smac()&gt;</span><br><span class="line">   <span class="number">0x000055555555483c</span> &lt;+<span class="number">28</span>&gt;:	mov    rcx,rax<span class="comment">//得到分配变量的地址，而后进行一系列内存复制操作</span></span><br><span class="line">   <span class="number">0x000055555555483f</span> &lt;+<span class="number">31</span>&gt;:	mov    rax,QWORD PTR [rcx]</span><br><span class="line">   <span class="number">0x0000555555554842</span> &lt;+<span class="number">34</span>&gt;:	mov    rdx,QWORD PTR [rcx+<span class="number">0x8</span>]</span><br><span class="line">   <span class="number">0x0000555555554846</span> &lt;+<span class="number">38</span>&gt;:	mov    QWORD PTR [rbp<span class="number">-0x40</span>],rax</span><br><span class="line">   <span class="number">0x000055555555484a</span> &lt;+<span class="number">42</span>&gt;:	mov    QWORD PTR [rbp<span class="number">-0x38</span>],rdx</span><br><span class="line">   <span class="number">0x000055555555484e</span> &lt;+<span class="number">46</span>&gt;:	mov    rax,QWORD PTR [rcx+<span class="number">0x10</span>]</span><br><span class="line">   <span class="number">0x0000555555554852</span> &lt;+<span class="number">50</span>&gt;:	mov    rdx,QWORD PTR [rcx+<span class="number">0x18</span>]</span><br><span class="line">   <span class="number">0x0000555555554856</span> &lt;+<span class="number">54</span>&gt;:	mov    QWORD PTR [rbp<span class="number">-0x30</span>],rax</span><br><span class="line">   <span class="number">0x000055555555485a</span> &lt;+<span class="number">58</span>&gt;:	mov    QWORD PTR [rbp<span class="number">-0x28</span>],rdx</span><br><span class="line">   <span class="number">0x000055555555485e</span> &lt;+<span class="number">62</span>&gt;:	mov    rax,QWORD PTR [rcx+<span class="number">0x20</span>]</span><br><span class="line">   <span class="number">0x0000555555554862</span> &lt;+<span class="number">66</span>&gt;:	mov    rdx,QWORD PTR [rcx+<span class="number">0x28</span>]</span><br><span class="line">   <span class="number">0x0000555555554866</span> &lt;+<span class="number">70</span>&gt;:	mov    QWORD PTR [rbp<span class="number">-0x20</span>],rax</span><br><span class="line">   <span class="number">0x000055555555486a</span> &lt;+<span class="number">74</span>&gt;:	mov    QWORD PTR [rbp<span class="number">-0x18</span>],rdx</span><br><span class="line">   <span class="number">0x000055555555486e</span> &lt;+<span class="number">78</span>&gt;:	mov    rax,QWORD PTR [rcx+<span class="number">0x30</span>]</span><br><span class="line">   <span class="number">0x0000555555554872</span> &lt;+<span class="number">82</span>&gt;:	mov    QWORD PTR [rbp<span class="number">-0x10</span>],rax</span><br><span class="line">   <span class="number">0x0000555555554876</span> &lt;+<span class="number">86</span>&gt;:	call   <span class="number">0x5555555547fa</span> &lt;Smac()&gt;</span><br><span class="line">   <span class="number">0x000055555555487b</span> &lt;+<span class="number">91</span>&gt;:	mov    QWORD PTR [rbp<span class="number">-0x48</span>],rax</span><br><span class="line">   <span class="number">0x000055555555487f</span> &lt;+<span class="number">95</span>&gt;:	 mov    eax,<span class="number">0x0</span></span><br><span class="line">   <span class="number">0x0000555555554884</span> &lt;+<span class="number">100</span>&gt;:	mov    rdx,QWORD PTR [rbp<span class="number">-0x8</span>]</span><br><span class="line">   <span class="number">0x0000555555554888</span> &lt;+<span class="number">104</span>&gt;:	<span class="keyword">xor</span>    rdx,QWORD PTR fs:<span class="number">0x28</span></span><br><span class="line">   <span class="number">0x0000555555554891</span> &lt;+<span class="number">113</span>&gt;:	je     <span class="number">0x555555554898</span> &lt;main()+<span class="number">120</span>&gt;</span><br><span class="line">   <span class="number">0x0000555555554893</span> &lt;+<span class="number">115</span>&gt;:	call   <span class="number">0x5555555546c0</span> &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">   <span class="number">0x0000555555554898</span> &lt;+<span class="number">120</span>&gt;:	leave  </span><br><span class="line">   <span class="number">0x0000555555554899</span> &lt;+<span class="number">121</span>&gt;:	ret    </span><br><span class="line">End of assembler dump.</span><br><span class="line"></span><br><span class="line"> Dump of assembler code <span class="keyword">for</span> function Smac():</span><br><span class="line">=&gt; <span class="number">0x00005555555547fa</span> &lt;+<span class="number">0</span>&gt;:	push   rbp</span><br><span class="line">   <span class="number">0x00005555555547fb</span> &lt;+<span class="number">1</span>&gt;:	mov    rbp,rsp</span><br><span class="line">   <span class="number">0x00005555555547fe</span> &lt;+<span class="number">4</span>&gt;:	sub    rsp,<span class="number">0x10</span></span><br><span class="line">   <span class="number">0x0000555555554802</span> &lt;+<span class="number">8</span>&gt;:	mov    edi,<span class="number">0x38</span></span><br><span class="line">   <span class="number">0x0000555555554807</span> &lt;+<span class="number">13</span>&gt;:	call   <span class="number">0x5555555546b0</span> &lt;_Znwm@plt&gt;</span><br><span class="line">   <span class="number">0x000055555555480c</span> &lt;+<span class="number">18</span>&gt;:	mov    QWORD PTR [rbp<span class="number">-0x8</span>],rax</span><br><span class="line">   <span class="number">0x0000555555554810</span> &lt;+<span class="number">22</span>&gt;:	mov    rax,QWORD PTR [rbp<span class="number">-0x8</span>]</span><br><span class="line">   <span class="number">0x0000555555554814</span> &lt;+<span class="number">26</span>&gt;:	mov    DWORD PTR [rax],<span class="number">0x1</span></span><br><span class="line">   <span class="number">0x000055555555481a</span> &lt;+<span class="number">32</span>&gt;:	mov    rax,QWORD PTR [rbp<span class="number">-0x8</span>]</span><br><span class="line">   <span class="number">0x000055555555481e</span> &lt;+<span class="number">36</span>&gt;:	leave  </span><br><span class="line">   <span class="number">0x000055555555481f</span> &lt;+<span class="number">37</span>&gt;:	ret    </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当使用普通变量接收函数返回值时，传出分配变量的地址，而后使用该地址进行内存复制</p>
<p>当使用引用变量时，直接将传出的地址存入即可</p>
</blockquote>
<h4 id="指针引用"><a href="#指针引用" class="headerlink" title="指针引用"></a>指针引用</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> *p=&amp;i;</span><br><span class="line">	<span class="keyword">int</span>*&amp; pp=p;</span><br><span class="line">	<span class="keyword">int</span> num=*pp;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">asm</span>:</span><br><span class="line"><span class="function">Dump of assembler code <span class="keyword">for</span> function <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">   0x00005555555547aa &lt;+0&gt;:	push   rbp</span><br><span class="line">   <span class="number">0x00005555555547ab</span> &lt;+<span class="number">1</span>&gt;:	mov    rbp,rsp</span><br><span class="line">   <span class="number">0x00005555555547ae</span> &lt;+<span class="number">4</span>&gt;:	sub    rsp,<span class="number">0x20</span></span><br><span class="line">   <span class="number">0x00005555555547b2</span> &lt;+<span class="number">8</span>&gt;:	mov    rax,QWORD PTR fs:<span class="number">0x28</span></span><br><span class="line">   <span class="number">0x00005555555547bb</span> &lt;+<span class="number">17</span>&gt;:	mov    QWORD PTR [rbp<span class="number">-0x8</span>],rax</span><br><span class="line">   <span class="number">0x00005555555547bf</span> &lt;+<span class="number">21</span>&gt;:	<span class="keyword">xor</span>    eax,eax</span><br><span class="line">   <span class="number">0x00005555555547c1</span> &lt;+<span class="number">23</span>&gt;:	mov    DWORD PTR [rbp<span class="number">-0x20</span>],<span class="number">0x0</span></span><br><span class="line">   <span class="number">0x00005555555547c8</span> &lt;+<span class="number">30</span>&gt;:	lea    rax,[rbp<span class="number">-0x20</span>]</span><br><span class="line">   <span class="number">0x00005555555547cc</span> &lt;+<span class="number">34</span>&gt;:	mov    QWORD PTR [rbp<span class="number">-0x18</span>],rax</span><br><span class="line">=&gt; <span class="number">0x00005555555547d0</span> &lt;+<span class="number">38</span>&gt;:	lea    rax,[rbp<span class="number">-0x18</span>]</span><br><span class="line">   <span class="number">0x00005555555547d4</span> &lt;+<span class="number">42</span>&gt;:	mov    QWORD PTR [rbp<span class="number">-0x10</span>],rax</span><br><span class="line">   <span class="number">0x00005555555547d8</span> &lt;+<span class="number">46</span>&gt;:	mov    rax,QWORD PTR [rbp<span class="number">-0x10</span>]</span><br><span class="line">   <span class="number">0x00005555555547dc</span> &lt;+<span class="number">50</span>&gt;:	mov    rax,QWORD PTR [rax]</span><br><span class="line">   <span class="number">0x00005555555547df</span> &lt;+<span class="number">53</span>&gt;:	mov    eax,DWORD PTR [rax]</span><br><span class="line">   <span class="number">0x00005555555547e1</span> &lt;+<span class="number">55</span>&gt;:	mov    DWORD PTR [rbp<span class="number">-0x1c</span>],eax</span><br><span class="line">   <span class="number">0x00005555555547e4</span> &lt;+<span class="number">58</span>&gt;:	mov    eax,<span class="number">0x0</span></span><br><span class="line">   <span class="number">0x00005555555547e9</span> &lt;+<span class="number">63</span>&gt;:	mov    rdx,QWORD PTR [rbp<span class="number">-0x8</span>]</span><br><span class="line">   <span class="number">0x00005555555547ed</span> &lt;+<span class="number">67</span>&gt;:	<span class="keyword">xor</span>    rdx,QWORD PTR fs:<span class="number">0x28</span></span><br><span class="line">   <span class="number">0x00005555555547f6</span> &lt;+<span class="number">76</span>&gt;:	je     <span class="number">0x5555555547fd</span> &lt;main()+<span class="number">83</span>&gt;</span><br><span class="line">   <span class="number">0x00005555555547f8</span> &lt;+<span class="number">78</span>&gt;:	call   <span class="number">0x555555554670</span> &lt;__stack_chk_fail@地址plt&gt;</span><br><span class="line">   <span class="number">0x00005555555547fd</span> &lt;+<span class="number">83</span>&gt;:	leave  </span><br><span class="line">   <span class="number">0x00005555555547fe</span> &lt;+<span class="number">84</span>&gt;:	ret    </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>指针的引用相当于一个二级指针，其内的值保存指针的地址</p>
</blockquote>
<h4 id="普通变量引用"><a href="#普通变量引用" class="headerlink" title="普通变量引用"></a>普通变量引用</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> &amp;p=i;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">asm</span>:</span><br><span class="line"> <span class="number">0x00005555555547c8</span> &lt;+<span class="number">30</span>&gt;:	lea    rax,[rbp<span class="number">-0x14</span>] <span class="comment">//i的地址</span></span><br><span class="line">  <span class="number">0x00005555555547cc</span> &lt;+<span class="number">34</span>&gt;:	mov    QWORD PTR [rbp<span class="number">-0x10</span>],rax<span class="comment">//将地址存入p中</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>普通变量的引用相当于一个一级指针，保存引用变量的地址</p>
</blockquote>
<h4 id="引用作为函数参数"><a href="#引用作为函数参数" class="headerlink" title="引用作为函数参数"></a>引用作为函数参数</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mac</span><span class="params">(<span class="keyword">int</span> &amp;i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	i=<span class="number">10</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num=<span class="number">10</span>;</span><br><span class="line">	mac(num);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">asm</span>:</span><br><span class="line"><span class="function">Dump of assembler code <span class="keyword">for</span> function <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">...</span><br><span class="line">   <span class="number">0x00005555555547da</span> &lt;+<span class="number">23</span>&gt;:	mov    DWORD PTR [rbp<span class="number">-0xc</span>],<span class="number">0xa</span></span><br><span class="line">   <span class="number">0x00005555555547e1</span> &lt;+<span class="number">30</span>&gt;:	lea    rax,[rbp<span class="number">-0xc</span>]<span class="comment">//获得参数地址</span></span><br><span class="line">   <span class="number">0x00005555555547e5</span> &lt;+<span class="number">34</span>&gt;:	mov    rdi,rax</span><br><span class="line">   <span class="number">0x00005555555547e8</span> &lt;+<span class="number">37</span>&gt;:	call   <span class="number">0x5555555547aa</span> &lt;mac(<span class="keyword">int</span>&amp;)&gt;</span><br><span class="line">...</span><br><span class="line">   <span class="number">0x0000555555554807</span> &lt;+<span class="number">68</span>&gt;:	ret    </span><br><span class="line">End of assembler dump.</span><br><span class="line"><span class="function">Dump of assembler code <span class="keyword">for</span> function <span class="title">mac</span><span class="params">(<span class="keyword">int</span>&amp;)</span>:</span></span><br><span class="line">...</span><br><span class="line">   <span class="number">0x00005555555547ae</span> &lt;+<span class="number">4</span>&gt;:	mov    QWORD PTR [rbp<span class="number">-0x8</span>],rdi</span><br><span class="line">   <span class="number">0x00005555555547b2</span> &lt;+<span class="number">8</span>&gt;:	mov    rax,QWORD PTR [rbp<span class="number">-0x8</span>]</span><br><span class="line">   <span class="number">0x00005555555547b6</span> &lt;+<span class="number">12</span>&gt;:	mov    DWORD PTR [rax],<span class="number">0xa</span></span><br><span class="line">...</span><br><span class="line">   <span class="number">0x00005555555547c2</span> &lt;+<span class="number">24</span>&gt;:	ret    </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>传递参数时将变量地址保存到rdi寄存器中传参</p>
</blockquote>
<h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num=<span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> *&amp;&amp;p=&amp;num;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">asm</span>:</span><br><span class="line"><span class="function">Dump of assembler code <span class="keyword">for</span> function <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">...</span><br><span class="line">   <span class="number">0x00005555555547c1</span> &lt;+<span class="number">23</span>&gt;:	mov    DWORD PTR [rbp<span class="number">-0x1c</span>],<span class="number">0xa</span></span><br><span class="line">   <span class="number">0x00005555555547c8</span> &lt;+<span class="number">30</span>&gt;:	lea    rax,[rbp<span class="number">-0x1c</span>]<span class="comment">//&amp;num</span></span><br><span class="line">   <span class="number">0x00005555555547cc</span> &lt;+<span class="number">34</span>&gt;:	mov    QWORD PTR [rbp<span class="number">-0x18</span>],rax</span><br><span class="line">   <span class="number">0x00005555555547d0</span> &lt;+<span class="number">38</span>&gt;:	lea    rax,[rbp<span class="number">-0x18</span>]</span><br><span class="line">   <span class="number">0x00005555555547d4</span> &lt;+<span class="number">42</span>&gt;:	mov    QWORD PTR [rbp<span class="number">-0x10</span>],rax</span><br><span class="line">...</span><br><span class="line">   <span class="number">0x00005555555547f2</span> &lt;+<span class="number">72</span>&gt;:	ret    </span><br><span class="line">End of assembler dump.</span><br><span class="line"> (gdb) p p</span><br><span class="line">$<span class="number">21</span> = (<span class="keyword">int</span> *&amp;&amp;) @<span class="number">0x7fffffffddd8</span>: <span class="number">0x7fffffffddd4</span></span><br><span class="line">       <span class="built_in">cout</span>&lt;&lt;p;输出为<span class="number">0x7fffffffddd4</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>右值引用，好比一个二级指针，但不同的是访问p可以直接获得num的地址，因而右值引用保存的是一个地址，为右值，不可更改.右值引用常用于类之间的拷贝、移动；使用右值引用可以减少重复内存拷贝，传递函数指针、普通函数参数等.如std::move(T&amp;&amp; t)).</p>
</blockquote>
<h3 id="复杂引用"><a href="#复杂引用" class="headerlink" title="复杂引用"></a>复杂引用</h3><h4 id="函数指针的引用"><a href="#函数指针的引用" class="headerlink" title="函数指针的引用"></a>函数指针的引用</h4><h5 id="作为函数返回值"><a href="#作为函数返回值" class="headerlink" title="作为函数返回值"></a>作为函数返回值</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>(*&amp; fun(<span class="keyword">int</span> (*&amp;rp)(<span class="keyword">int</span>,<span class="keyword">int</span>)))(<span class="keyword">int</span>, <span class="keyword">int</span>)<span class="comment">//最后的(int, int)为返回类型</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>返回一个函数指针的引用，函数指针指向的函数类型为int(&amp;)(int,int),也是一个返回函数指针引用的函数，类型为int(&amp;)(int,int)</p>
</blockquote>
<h5 id="作为函数参数"><a href="#作为函数参数" class="headerlink" title="作为函数参数"></a>作为函数参数</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span>(* &amp; rp)(<span class="keyword">int</span>,<span class="keyword">int</span>))</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>一个int(*)(int,int)型指针的引用作为函数参数的函数</p>
</blockquote>
<p>int (*&amp;rp)(int,int))</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp连接MySQL数据库相关操作</title>
    <url>/posts/dae3da92/</url>
    <content><![CDATA[<p>一些MySQLc库API</p>
<h4 id="详见-https-dev-mysql-com-doc-refman-5-7-en-mysql-real-connect-html"><a href="#详见-https-dev-mysql-com-doc-refman-5-7-en-mysql-real-connect-html" class="headerlink" title="详见:https://dev.mysql.com/doc/refman/5.7/en/mysql-real-connect.html"></a>详见:<a href="https://dev.mysql.com/doc/refman/5.7/en/mysql-real-connect.html">https://dev.mysql.com/doc/refman/5.7/en/mysql-real-connect.html</a></h4><a id="more"></a>

<h4 id="mysql-init"><a href="#mysql-init" class="headerlink" title="mysql_init"></a>mysql_init</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">MYSQL *<span class="title">mysql_init</span><span class="params">(MYSQL *mysql)</span></span></span><br><span class="line"><span class="function"> <span class="comment">//初始化MYSQL句柄，为指针分配内存，成功返回一个地址，失败返回NULL;</span></span></span><br><span class="line"><span class="function">    MYSQL * mysql</span>;</span><br><span class="line">    mysql = mysql_init(mysql);</span><br></pre></td></tr></table></figure>

<h4 id="mysql-real-connect"><a href="#mysql-real-connect" class="headerlink" title="mysql_real_connect"></a>mysql_real_connect</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">MYSQL *<span class="title">mysql_real_connect</span><span class="params">(MYSQL *mysql, <span class="keyword">const</span> <span class="keyword">char</span> *host, <span class="keyword">const</span> <span class="keyword">char</span> *user, <span class="keyword">const</span> <span class="keyword">char</span> *passwd, <span class="keyword">const</span> <span class="keyword">char</span> *db, <span class="keyword">unsigned</span> <span class="keyword">int</span> port, <span class="keyword">const</span> <span class="keyword">char</span> *unix_socket, <span class="keyword">unsigned</span> <span class="keyword">long</span> client_flag)</span></span></span><br><span class="line"><span class="function">    <span class="comment">//与mysql服务器建立连接，常用示例</span></span></span><br><span class="line"><span class="function">     mysql </span>= mysql_real_connect(mysql,<span class="string">&quot;127.0.0.1&quot;</span>,<span class="string">&quot;root&quot;</span>,<span class="string">&quot;55555&quot;</span>,<span class="string">&quot;flmaingo&quot;</span><span class="comment">/*数据库名称*/</span>,<span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h4 id="mysql-query"><a href="#mysql-query" class="headerlink" title="mysql_query"></a>mysql_query</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mysql_query</span><span class="params">(MYSQL *mysql, <span class="keyword">const</span> <span class="keyword">char</span> *stmt_str)</span></span></span><br><span class="line"><span class="function">    <span class="comment">//执行一个sql语句，成功返回0,失败为非0</span></span></span><br><span class="line"><span class="function">    <span class="title">mysql_query</span><span class="params">(mysql, <span class="string">&quot;set names utf8&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="mysql-store-result"><a href="#mysql-store-result" class="headerlink" title="mysql_store_result"></a>mysql_store_result</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">MYSQL_RES *<span class="title">mysql_store_result</span><span class="params">(MYSQL *mysql)</span></span></span><br><span class="line"><span class="function">    <span class="comment">//返回mysql查询结果集</span></span></span><br><span class="line"><span class="function">     MYSQL_RES* result </span>= <span class="number">0</span>;</span><br><span class="line">	mysql_query(mysql,<span class="string">&quot;show databases&quot;</span>);</span><br><span class="line">    result = mysql_store_result(mysql);</span><br></pre></td></tr></table></figure>

<h4 id="mysql-affected-rows"><a href="#mysql-affected-rows" class="headerlink" title="mysql_affected_rows"></a>mysql_affected_rows</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">my_ulonglong <span class="title">mysql_affected_rows</span><span class="params">(MYSQL *mysql)</span></span></span><br><span class="line"><span class="function">    <span class="comment">//它返回改变结果集中，删除或插入的最后一条语句的行数</span></span></span><br><span class="line"><span class="function">    <span class="keyword">uint64_t</span> rowCount </span>= <span class="number">0</span>;</span><br><span class="line">    mysql_query(mysql,<span class="string">&quot;show databases&quot;</span>);</span><br><span class="line">	rowCount = mysql_affected_rows(mysql);</span><br><span class="line"><span class="comment">//rowCount 的值为有多少个数据库则为几</span></span><br></pre></td></tr></table></figure>

<h4 id="mysql-field-count"><a href="#mysql-field-count" class="headerlink" title="mysql_field_count"></a>mysql_field_count</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">mysql_field_count</span><span class="params">(MYSQL *mysql)</span></span></span><br><span class="line"><span class="function">    <span class="comment">//返回结果集有多少列</span></span></span><br><span class="line"><span class="function">    <span class="keyword">uint32_t</span> fieldCount </span>= <span class="number">0</span>;</span><br><span class="line">	mysql_query(mysql,<span class="string">&quot;show databases&quot;</span>);</span><br><span class="line">    fieldCount = mysql_field_count(mysql);</span><br><span class="line">	<span class="comment">//fieldCount等于1</span></span><br></pre></td></tr></table></figure>

<h4 id="mysql-fetch-fields"><a href="#mysql-fetch-fields" class="headerlink" title="mysql_fetch_fields"></a>mysql_fetch_fields</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">MYSQL_FIELD *<span class="title">mysql_fetch_fields</span><span class="params">(MYSQL_RES *result)</span></span></span><br><span class="line"><span class="function">    <span class="comment">//返回MYSQL_FIELD 结果集的所有结构的数组。每个结构都为结果集的一列提供字段定义。及包括字段数据类型等,即获取表头</span></span></span><br><span class="line"><span class="function">    result </span>= mysql_store_result(mysql);</span><br><span class="line">    MYSQL_FIELD *fields = mysql_fetch_fields(result);</span><br></pre></td></tr></table></figure>

<h4 id="mysql-fetch-row"><a href="#mysql-fetch-row" class="headerlink" title="mysql_fetch_row"></a>mysql_fetch_row</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">MYSQL_ROW <span class="title">mysql_fetch_row</span><span class="params">(MYSQL_RES *result)</span></span></span><br><span class="line"><span class="function">    <span class="comment">//检索结果集的下一行</span></span></span><br><span class="line"><span class="function">    <span class="title">mysql_query</span><span class="params">(mysql,<span class="string">&quot;show databases&quot;</span>)</span></span>;</span><br><span class="line">    result = mysql_store_result(mysql);</span><br><span class="line">    row = mysql_fetch_row(result)</span><br><span class="line">    row为行指针，获取列的值使用row[i]</span><br></pre></td></tr></table></figure>

<h4 id="mysql-fetch-lengths"><a href="#mysql-fetch-lengths" class="headerlink" title="mysql_fetch_lengths"></a>mysql_fetch_lengths</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> *<span class="title">mysql_fetch_lengths</span><span class="params">(MYSQL_RES *result)</span></span></span><br><span class="line"><span class="function">    <span class="comment">//返回结果集中当前行的列的长度</span></span></span><br><span class="line"><span class="function">     <span class="title">mysql_query</span><span class="params">(mysql,<span class="string">&quot;desc t_user&quot;</span>)</span></span>;</span><br><span class="line">    result = mysql_store_result(mysql);</span><br><span class="line">    row = mysql_fetch_row(result);</span><br><span class="line">    ulFieldLength = mysql_fetch_lengths(result);<span class="comment">//row指向字段名的长度strlen(字段名)</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp标准库多线程编程</title>
    <url>/posts/82dd0668/</url>
    <content><![CDATA[<h3 id="更多使用"><a href="#更多使用" class="headerlink" title="更多使用"></a>更多使用</h3><h4 id="参考：https-en-cppreference-com-w"><a href="#参考：https-en-cppreference-com-w" class="headerlink" title="参考：https://en.cppreference.com/w/"></a>参考：<a href="https://en.cppreference.com/w/">https://en.cppreference.com/w/</a></h4><a id="more"></a>

<h3 id="thread类"><a href="#thread类" class="headerlink" title="thread类"></a>thread类</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一个常用的构造函数形式</span></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">Function</span>, <span class="title">class</span>... <span class="title">Args</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">explicit</span> <span class="title">thread</span>( <span class="title">Function</span>&amp;&amp; <span class="title">f</span>, <span class="title">Args</span>&amp;&amp;... <span class="title">args</span> );</span><span class="comment">//参数均为右值引用，其为临时对象不会影响原来的对象</span></span><br><span class="line"><span class="comment">//线程的函数参数必须是一个没有返回值的函数</span></span><br></pre></td></tr></table></figure>

<h4 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;//包含线程头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">thread_local</span> <span class="keyword">int</span> g_num = <span class="number">1</span>;<span class="comment">//定义一个线程变量，对于线程变量，每个线程都会有该变量的一个拷贝，互不干扰。该局部变量一直都在，直到线程退出为止，线程变量在线程执行过程当中必须有效，如此处若在main函数中使用detach将线程置为分离态，main执行结束会销毁g_num变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thredfun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	g_num++;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;thread1 no arg&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;thread1 g_num: &quot;</span>&lt;&lt;g_num&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thredfun2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	g_num++;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;thread2 arg:&quot;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;y&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;thread2 g_num: &quot;</span>&lt;&lt;g_num&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::thread <span class="title">f1</span><span class="params">(thredfun1)</span></span>; </span><br><span class="line">	<span class="function"><span class="built_in">std</span>::thread <span class="title">f2</span><span class="params">(thredfun2,<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">	<span class="comment">//f1.detach();</span></span><br><span class="line">	<span class="comment">//f2.detach();//调用其使线程置为分离态，不用等待其执行结束后返回，若main函数比线程函数先执行结束，则不能在main函数中执行线程分离函数</span></span><br><span class="line">	f1.join();</span><br><span class="line">	f2.join();<span class="comment">//等待线程结束后返回</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;main end&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程资源同步对象"><a href="#线程资源同步对象" class="headerlink" title="线程资源同步对象"></a>线程资源同步对象</h3><h3 id="std-mutex"><a href="#std-mutex" class="headerlink" title="std::mutex"></a>std::mutex</h3><table>
<thead>
<tr>
<th align="left">互斥量</th>
<th align="left">版本</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">mutex</td>
<td align="left">C++11</td>
<td align="left">最基本的互斥量</td>
</tr>
<tr>
<td align="left">timed_mutex</td>
<td align="left">C++11</td>
<td align="left">有超时机制的互斥量</td>
</tr>
<tr>
<td align="left">recursive_mutex</td>
<td align="left">C++11</td>
<td align="left">可重入的互斥量</td>
</tr>
<tr>
<td align="left">recursive_timed_mutex</td>
<td align="left">C++11</td>
<td align="left">结合 timed_mutex 和 recursive_mutex 特点的互斥量</td>
</tr>
<tr>
<td align="left">shared_timed_mutex</td>
<td align="left">C++14</td>
<td align="left">具有超时机制的可共享互斥量</td>
</tr>
<tr>
<td align="left">shared_mutex</td>
<td align="left">C++17</td>
<td align="left">共享的互斥量</td>
</tr>
</tbody></table>
<h4 id="使用RAII技术对mutex的封装"><a href="#使用RAII技术对mutex的封装" class="headerlink" title="使用RAII技术对mutex的封装"></a>使用RAII技术对mutex的封装</h4><table>
<thead>
<tr>
<th>互斥量管理</th>
<th>版本</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>lock_guard</td>
<td>C++11</td>
<td>基于作用域的互斥量管理</td>
</tr>
<tr>
<td>unique_lock</td>
<td>C++11</td>
<td>更加灵活的互斥量管理</td>
</tr>
<tr>
<td>shared_lock</td>
<td>C++14</td>
<td>共享互斥量的管理</td>
</tr>
<tr>
<td>scope_lock</td>
<td>C++17</td>
<td>多互斥量避免死锁的管理</td>
</tr>
</tbody></table>
<p>使用RAII技术在类构造时调用锁的加锁函数，析构时调用函数的解锁函数，成员变量是一个锁的引用,大概为以下意思:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RAII</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span> :</span><br><span class="line">    RAII(mutex&amp; t):mutex_(t)&#123;</span><br><span class="line">        mutex_.lock()</span><br><span class="line">    &#125;</span><br><span class="line">    ~RAII()&#123;</span><br><span class="line">        mutex_.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    mutex&amp; mutex_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>lock_guard使用示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">guard</span><span class="params">(mutex_)</span></span>;<span class="comment">//初始化并加锁，括号内为锁的作用范围</span></span><br><span class="line">	<span class="comment">//在这里放被保护的资源操作</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//出括号guard析构解锁</span></span><br></pre></td></tr></table></figure>

<h3 id="std-condition-variable"><a href="#std-condition-variable" class="headerlink" title="std::condition_variable"></a>std::condition_variable</h3><h4 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">guard</span><span class="params">(mymutex)</span></span>;</span><br><span class="line">		<span class="keyword">while</span> ([<span class="literal">true</span>]<span class="keyword">or</span>[flase])<span class="comment">//此处不能使用if</span></span><br><span class="line">		&#123;				</span><br><span class="line">			<span class="comment">//如果获得了互斥锁，但是条件不合适的话，pthread_cond_wait会释放锁，不往下执行。</span></span><br><span class="line">			<span class="comment">//当发生变化后，条件合适，pthread_cond_wait将直接获得锁。</span></span><br><span class="line">			mycv.wait(guard);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//释放信号量，通知等待线程</span></span><br><span class="line">		mycv.notify_one();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="虚假唤醒"><a href="#虚假唤醒" class="headerlink" title="虚假唤醒"></a>虚假唤醒</h4><p>变量的线程也有可能会醒来。我们将条件变量的这种行为称之为 <strong>虚假唤醒</strong>。因此将条件放在一个 while 循环中意味着光唤醒条件变量不行，还必须条件满足程序才能继续执行正常的逻辑。</p>
<p>另外一种系统调用被中断:<strong>pthread_cond_wait</strong> 是 futex 系统调用，属于阻塞型的系统调用，当系统调用被信号中断的时候，会返回 <strong>-1</strong>，并且把 errno 错误码置为EINTR。很多这种系统调用为了防止被信号中断都会重启系统调用（即再次调用一次这个函数）。但有的系统调用被中断可以系统自己重试，有的不可以重试的，不可以重试的需要调用者自己手动重试。此处使用while循环则相当于调用者自己重试。若不判断条件向下执行，则不符合代码逻辑，即当前条件不满足无法执行后续操作。若使用if则不会重新判断会直接向下执行，若条件不满足则有可能会引起程序的崩溃。</p>
<h3 id="std-atomic"><a href="#std-atomic" class="headerlink" title="std::atomic"></a>std::atomic</h3><h4 id="原子操作类"><a href="#原子操作类" class="headerlink" title="原子操作类"></a>原子操作类</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; value;</span><br><span class="line">    value = <span class="number">99</span>;<span class="comment">//atomic默认禁用拷贝构造函数，所以不不能使用    std::atomic&lt;int&gt; value = 99;但支持赋值操作</span></span><br><span class="line">    <span class="comment">//atomic&amp; operator=( const atomic&amp; ) = delete;禁用拷贝构造函数</span></span><br><span class="line">    <span class="comment">//T operator=( T desired );合法赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;value&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自增1，原子操作</span></span><br><span class="line">    value++;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;value&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>FlamingoServer开源代码阅读-MySql相关操作封装</title>
    <url>/posts/6f363257/</url>
    <content><![CDATA[<h4 id="MySQL官方文档-https-dev-mysql-com-doc-refman-5-7-en-mysql-query-html"><a href="#MySQL官方文档-https-dev-mysql-com-doc-refman-5-7-en-mysql-query-html" class="headerlink" title="MySQL官方文档:https://dev.mysql.com/doc/refman/5.7/en/mysql-query.html"></a>MySQL官方文档:<a href="https://dev.mysql.com/doc/refman/5.7/en/mysql-query.html">https://dev.mysql.com/doc/refman/5.7/en/mysql-query.html</a></h4><a id="more"></a>

<h3 id="Field类"><a href="#Field类" class="headerlink" title="Field类"></a>Field类</h3><h4 id="Field-h"><a href="#Field-h" class="headerlink" title="Field.h"></a>Field.h</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*保存mysql字段，仅保存单行，一个示例结构</span></span><br><span class="line"><span class="comment"> *&#123;m_bNULL = false, m_strValue = &quot;information_schema&quot;, m_strFieldName = &quot;database&quot;, m_iType = Field::DB_TYPE_STRING&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">toLowerString</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>&amp; str)</span><span class="comment">//将字符串转化为小写</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; str.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; str[i] &lt;= <span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            str[i] = str[i] + (<span class="string">&#x27;a&#x27;</span> - <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Field</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">enum</span> DataTypes</span><br><span class="line">        &#123;</span><br><span class="line">            DB_TYPE_UNKNOWN = <span class="number">0x00</span>,</span><br><span class="line">            DB_TYPE_STRING  = <span class="number">0x01</span>,</span><br><span class="line">            DB_TYPE_INTEGER = <span class="number">0x02</span>,</span><br><span class="line">            DB_TYPE_FLOAT   = <span class="number">0x03</span>,</span><br><span class="line">            DB_TYPE_BOOL    = <span class="number">0x04</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Field();</span><br><span class="line">        Field(Field &amp;f);</span><br><span class="line">        Field(<span class="keyword">const</span> <span class="keyword">char</span> *value, <span class="keyword">enum</span> DataTypes type);</span><br><span class="line"></span><br><span class="line">        ~Field();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">enum</span> DataTypes <span class="title">getType</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_iType; &#125;<span class="comment">//返回字段数据类型</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">getString</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span>  m_strValue; &#125;<span class="comment">//返回字段至</span></span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">getCppString</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span>  m_strValue;                    <span class="comment">// std::string s = 0 have undefine result in C++</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">float</span> <span class="title">getFloat</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(atof( m_strValue.c_str())); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">getBool</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span>  atoi(m_strValue.c_str()) &gt; <span class="number">0</span>; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">int32_t</span> <span class="title">getInt32</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span>  <span class="keyword">static_cast</span>&lt;<span class="keyword">int32_t</span>&gt;(atol(m_strValue.c_str())); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">uint8_t</span> <span class="title">getUInt8</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span>  <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(atol(m_strValue.c_str())); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">uint16_t</span> <span class="title">getUInt16</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span>  <span class="keyword">static_cast</span>&lt;<span class="keyword">uint16_t</span>&gt;(atol(m_strValue.c_str())); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">int16_t</span> <span class="title">getInt16</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span>  <span class="keyword">static_cast</span>&lt;<span class="keyword">int16_t</span>&gt;(atol(m_strValue.c_str())); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">uint32_t</span> <span class="title">getUInt32</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span>  <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(atol(m_strValue.c_str())); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">uint64_t</span> <span class="title">getUInt64</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">uint64_t</span> value = <span class="number">0</span>;</span><br><span class="line">            value = atoll(m_strValue.c_str());</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setType</span><span class="params">(<span class="keyword">enum</span> DataTypes type)</span> </span>&#123; m_iType = type; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* value, <span class="keyword">size_t</span> uLen)</span></span>;<span class="comment">//设置字段值</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; strName)</span><span class="comment">//设置表头值</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            m_strFieldName = strName;</span><br><span class="line">            toLowerString(m_strFieldName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> m_strFieldName;<span class="comment">//获取表头</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">isNULL</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> m_bNULL;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">convertValue</span><span class="params">(T&amp; value)</span></span>;<span class="comment">//未实现</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">bool</span>                 m_bNULL;<span class="comment">//该字段是否为空标志</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span>          m_strValue;<span class="comment">//字段值</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span>          m_strFieldName;<span class="comment">//表头，字段名</span></span><br><span class="line">        <span class="keyword">enum</span> DataTypes       m_iType;<span class="comment">//字段类型</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="Field-cpp"><a href="#Field-cpp" class="headerlink" title="Field.cpp"></a>Field.cpp</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Field.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Field::Field() : m_iType(DB_TYPE_UNKNOWN)</span><br><span class="line">&#123;</span><br><span class="line">    m_bNULL = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Field::Field(Field &amp;f)</span><br><span class="line">&#123;</span><br><span class="line">    m_strValue = f.m_strValue;</span><br><span class="line">    m_strFieldName = f.m_strFieldName;</span><br><span class="line"></span><br><span class="line">    m_iType = f.getType();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Field::Field(<span class="keyword">const</span> <span class="keyword">char</span> *value, <span class="keyword">enum</span> Field::DataTypes type) : m_iType(type)</span><br><span class="line">&#123;</span><br><span class="line">    m_strValue = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Field::~Field()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Field::setValue</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *value, <span class="keyword">size_t</span> uLen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//m_strValue = value;</span></span><br><span class="line">    m_strValue.assign(value, uLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="QueryResult类"><a href="#QueryResult类" class="headerlink" title="QueryResult类"></a>QueryResult类</h3><h4 id="QueryResult-h"><a href="#QueryResult-h" class="headerlink" title="QueryResult.h"></a>QueryResult.h</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mysql/mysql.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Field.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">QueryResult</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">uint32_t</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; FieldNames;</span><br><span class="line"></span><br><span class="line">        QueryResult(MYSQL_RES* result, <span class="keyword">uint64_t</span> rowCount, <span class="keyword">uint32_t</span> fieldCount);</span><br><span class="line">        <span class="keyword">virtual</span> ~QueryResult();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">nextRow</span><span class="params">()</span></span>;<span class="comment">//设置m_CurrentRow的每个Field成员的值，并将mysql返回结果集后移到下一行</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">uint32_t</span> <span class="title">getField_idx</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name)</span> <span class="keyword">const</span><span class="comment">//传入字段名，返回其列号</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(FieldNames::const_iterator iter = getFieldNames().begin(); iter != getFieldNames().end(); ++iter)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(iter-&gt;second == name)</span><br><span class="line">                    <span class="keyword">return</span> iter-&gt;first;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">uint32_t</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">Field* <span class="title">fetch</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_CurrentRow; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> Field &amp; <span class="keyword">operator</span> [] (<span class="keyword">int</span> index) <span class="keyword">const</span> </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="keyword">return</span> m_CurrentRow[index];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> Field&amp; <span class="keyword">operator</span> [] (<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name) <span class="keyword">const</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> m_CurrentRow[getField_idx(name)];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">uint32_t</span> <span class="title">getFieldCount</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_FieldCount; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">uint64_t</span> <span class="title">getRowCount</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_RowCount; &#125;</span><br><span class="line">        <span class="function">FieldNames <span class="keyword">const</span>&amp; <span class="title">getFieldNames</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> m_FieldNames; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="keyword">const</span>&amp; <span class="title">getNames</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> m_vtFieldNames;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="keyword">enum</span> Field::DataTypes <span class="title">convertNativeType</span><span class="params">(enum_field_types mysqlType)</span> <span class="keyword">const</span></span>;<span class="comment">//返回字段数据类型</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">endQuery</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        Field *                     m_CurrentRow;<span class="comment">//MySQL返回结果集数组，一个类即为结果集中的一行，只有一行，但为多列</span></span><br><span class="line">        <span class="keyword">uint32_t</span>                    m_FieldCount;<span class="comment">//当前处理行的列数</span></span><br><span class="line">        <span class="keyword">uint64_t</span>                    m_RowCount;<span class="comment">//结果集行数</span></span><br><span class="line">        FieldNames                  m_FieldNames;<span class="comment">//表头map int-string</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;    m_vtFieldNames;<span class="comment">//表头集合,连续数组</span></span><br><span class="line"></span><br><span class="line">		MYSQL_RES*                  m_Result;<span class="comment">//MySQL结果集指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="QueryResult-cpp"><a href="#QueryResult-cpp" class="headerlink" title="QueryResult.cpp"></a>QueryResult.cpp</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;QueryResult.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../base/AsyncLog.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">QueryResult::QueryResult(MYSQL_RES *result, <span class="keyword">uint64_t</span> rowCount, <span class="keyword">uint32_t</span> fieldCount)</span><br><span class="line"> : m_FieldCount(fieldCount), m_RowCount(rowCount)</span><br><span class="line">&#123;</span><br><span class="line">    m_Result = result;</span><br><span class="line">	m_CurrentRow = <span class="keyword">new</span> Field[m_FieldCount];</span><br><span class="line"></span><br><span class="line">     <span class="comment">//返回MYSQL_FIELD 结果集的所有结构的数组。每个结构都为结果集的一列提供字段定义。表头</span></span><br><span class="line">    MYSQL_FIELD *fields = mysql_fetch_fields(m_Result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; m_FieldCount; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span> 这个地方要不要判断为NULL？</span></span><br><span class="line">		<span class="keyword">if</span> (fields[i].name != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_FieldNames[i] = fields[i].name;</span><br><span class="line">            m_vtFieldNames.push_back(fields[i].name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            m_FieldNames[i] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            m_vtFieldNames.push_back(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        m_CurrentRow[i].setType(convertNativeType(fields[i].type));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QueryResult::~QueryResult(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    endQuery();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">QueryResult::nextRow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MYSQL_ROW row;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!m_Result)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检索结果集的下一行，初始返回结过集中的row为NULL：</span></span><br><span class="line">    row = mysql_fetch_row(m_Result);</span><br><span class="line">    <span class="keyword">if</span> (!row)</span><br><span class="line">    &#123;</span><br><span class="line">        endQuery();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> *ulFieldLength;</span><br><span class="line">    <span class="comment">//返回一个字段的长度，即strlen(field)</span></span><br><span class="line">    ulFieldLength = mysql_fetch_lengths(m_Result);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; m_FieldCount; i++)</span><br><span class="line">    &#123;<span class="comment">//按列设置Field结构，每个字段的值</span></span><br><span class="line">        <span class="keyword">if</span>(row[i] == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;<span class="comment">//当前列为空，即无值，将字段内容设置为空</span></span><br><span class="line">            m_CurrentRow[i].m_bNULL = <span class="literal">true</span>;</span><br><span class="line">            m_CurrentRow[i].setValue(<span class="string">&quot;&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            m_CurrentRow[i].m_bNULL = <span class="literal">false</span>;</span><br><span class="line">            m_CurrentRow[i].setValue(row[i], ulFieldLength[i]);<span class="comment">//设置字段值</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        m_CurrentRow[i].setName(m_FieldNames[i]);<span class="comment">//设置表头</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QueryResult::endQuery</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_CurrentRow)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> [] m_CurrentRow;</span><br><span class="line">        m_CurrentRow = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m_Result)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="comment">//LOGI &lt;&lt; &quot;QueryResult::EndQuery, mysql_free_result&quot;;</span></span><br><span class="line">        mysql_free_result(m_Result);</span><br><span class="line">        m_Result = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">enum</span> Field::DataTypes <span class="title">QueryResult::convertNativeType</span><span class="params">(enum_field_types mysqlType)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (mysqlType)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> FIELD_TYPE_TIMESTAMP:</span><br><span class="line">        <span class="keyword">case</span> FIELD_TYPE_DATE:</span><br><span class="line">        <span class="keyword">case</span> FIELD_TYPE_TIME:</span><br><span class="line">        <span class="keyword">case</span> FIELD_TYPE_DATETIME:</span><br><span class="line">        <span class="keyword">case</span> FIELD_TYPE_YEAR:</span><br><span class="line">        <span class="keyword">case</span> FIELD_TYPE_STRING:</span><br><span class="line">        <span class="keyword">case</span> FIELD_TYPE_VAR_STRING:</span><br><span class="line">        <span class="keyword">case</span> FIELD_TYPE_BLOB:</span><br><span class="line">        <span class="keyword">case</span> FIELD_TYPE_SET:</span><br><span class="line">        <span class="keyword">case</span> FIELD_TYPE_NULL:</span><br><span class="line">            <span class="keyword">return</span> Field::DB_TYPE_STRING;</span><br><span class="line">        <span class="keyword">case</span> FIELD_TYPE_TINY:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> FIELD_TYPE_SHORT:</span><br><span class="line">        <span class="keyword">case</span> FIELD_TYPE_LONG:</span><br><span class="line">        <span class="keyword">case</span> FIELD_TYPE_INT24:</span><br><span class="line">        <span class="keyword">case</span> FIELD_TYPE_LONGLONG:</span><br><span class="line">        <span class="keyword">case</span> FIELD_TYPE_ENUM:</span><br><span class="line">            <span class="keyword">return</span> Field::DB_TYPE_INTEGER;</span><br><span class="line">        <span class="keyword">case</span> FIELD_TYPE_DECIMAL:</span><br><span class="line">        <span class="keyword">case</span> FIELD_TYPE_FLOAT:</span><br><span class="line">        <span class="keyword">case</span> FIELD_TYPE_DOUBLE:</span><br><span class="line">            <span class="keyword">return</span> Field::DB_TYPE_FLOAT;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> Field::DB_TYPE_UNKNOWN;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DatabaseMysql"><a href="#DatabaseMysql" class="headerlink" title="DatabaseMysql"></a>DatabaseMysql</h3><h4 id="DatabaseMysql-h"><a href="#DatabaseMysql-h" class="headerlink" title="DatabaseMysql.h"></a>DatabaseMysql.h</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mysql/mysql.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mysql/errmsg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;QueryResult.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_QUERY_LEN   1024</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CDatabaseMysql</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">DatabaseInfo</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">string</span> strHost;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> strUser;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> strPwd;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> strDBName;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	CDatabaseMysql(<span class="keyword">void</span>);</span><br><span class="line">	~CDatabaseMysql(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">initialize</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; host, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; user, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; pwd, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; dbname)</span></span>;</span><br><span class="line">	<span class="function">QueryResult* <span class="title">query</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *sql)</span></span>;</span><br><span class="line">	<span class="function">QueryResult* <span class="title">query</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; sql)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	    <span class="keyword">return</span> query(sql.c_str());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">QueryResult* <span class="title">pquery</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *format,...)</span></span>;<span class="comment">//接受多个参数，而后拼接，执行其拼接出的sql</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">execute</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* sql)</span></span>;<span class="comment">//执行sql，不获取状态，内部有做数据库是否连接判断，如果没有则会重连</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">execute</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* sql, <span class="keyword">uint32_t</span>&amp; uAffectedCount, <span class="keyword">int</span>&amp; nErrno)</span></span>;<span class="comment">//执行sql获取错误码，改变集合中的行号，内部有做数据库是否连接判断，如果没有则会重连</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">pexecute</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *format,...)</span></span>;<span class="comment">//接受多个参数，而后拼接，执行其拼接出的sql</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">uint32_t</span> <span class="title">getInsertID</span><span class="params">()</span></span>;<span class="comment">//返回AUTO_INCREMENT成功插入的第一个自动生成的 值。</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">clearStoredResults</span><span class="params">()</span></span>;<span class="comment">//清除存储结果，清空查询所得的结果集</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int32_t</span> <span class="title">escapeString</span><span class="params">(<span class="keyword">char</span>* szDst, <span class="keyword">const</span> <span class="keyword">char</span>* szSrc, <span class="keyword">uint32_t</span> uSize)</span></span>;<span class="comment">//创建一个合法的SQL字符串以用于SQL语句</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	DatabaseInfo    m_DBInfo;</span><br><span class="line">	MYSQL*          m_Mysql;</span><br><span class="line">	<span class="keyword">bool</span>            m_bInit;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="DatabaseMysql-cpp"><a href="#DatabaseMysql-cpp" class="headerlink" title="DatabaseMysql.cpp"></a>DatabaseMysql.cpp</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;DatabaseMysql.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../base/AsyncLog.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">CDatabaseMysql::CDatabaseMysql(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//m_Mysql = new MYSQL;</span></span><br><span class="line">    m_Mysql = <span class="literal">NULL</span>;</span><br><span class="line">    m_bInit = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CDatabaseMysql::~CDatabaseMysql(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_Mysql != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_bInit)</span><br><span class="line">        &#123;</span><br><span class="line">            mysql_close(m_Mysql);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//delete m_Mysql;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CDatabaseMysql::initialize</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; host, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; user, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; pwd, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; dbname)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//LOGI &lt;&lt; &quot;CDatabaseMysql::Initialize, begin...&quot;;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//ClearStoredResults();</span></span><br><span class="line">    <span class="keyword">if</span> (m_bInit)</span><br><span class="line">    &#123;</span><br><span class="line">        mysql_close(m_Mysql);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_Mysql = mysql_init(m_Mysql);<span class="comment">//MySQL初始化</span></span><br><span class="line">    m_Mysql = mysql_real_connect(m_Mysql, host.c_str(), user.c_str(), pwd.c_str(), dbname.c_str(), <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>);<span class="comment">//和MySQL服务器建立连接</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//ClearStoredResults();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//LOGI &lt;&lt; &quot;mysql info: host=&quot; &lt;&lt; host &lt;&lt; &quot;, user=&quot; &lt;&lt; user &lt;&lt; &quot;, password=&quot; &lt;&lt; pwd &lt;&lt; &quot;, dbname=&quot; &lt;&lt; dbname;</span></span><br><span class="line"></span><br><span class="line">    m_DBInfo.strDBName = dbname;</span><br><span class="line">    m_DBInfo.strHost = host;</span><br><span class="line">    m_DBInfo.strUser = user;</span><br><span class="line">    m_DBInfo.strPwd = pwd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m_Mysql)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//LOGI &lt;&lt; &quot;m_Mysql address &quot; &lt;&lt; (long)m_Mysql;</span></span><br><span class="line">        <span class="comment">//LOGI &lt;&lt; &quot;CDatabaseMysql::Initialize, set names utf8&quot;;</span></span><br><span class="line">        mysql_query(m_Mysql, <span class="string">&quot;set names utf8&quot;</span>);<span class="comment">//执行SQL语句，不能含有0字符</span></span><br><span class="line">        <span class="comment">//mysql_query(m_Mysql, &quot;set names latin1&quot;);</span></span><br><span class="line">        m_bInit = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//LOGE &lt;&lt; &quot;Could not connect to MySQL database at &quot; &lt;&lt; host.c_str()</span></span><br><span class="line">        <span class="comment">//    &lt;&lt; &quot;, &quot; &lt;&lt; mysql_error(m_Mysql);</span></span><br><span class="line">        mysql_close(m_Mysql);<span class="comment">//关闭MySQL连接</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//LOGI &lt;&lt; &quot;CDatabaseMysql::Initialize, init failed!&quot;;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//<span class="doctag">TODO:</span> 这个函数要区分一下空数据集和出错两种情况</span></span><br><span class="line"><span class="function">QueryResult* <span class="title">CDatabaseMysql::query</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* sql)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!m_Mysql)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//LOGI &lt;&lt; &quot;CDatabaseMysql::Query, mysql is disconnected!&quot;;</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">false</span> == initialize(m_DBInfo.strHost, m_DBInfo.strUser,</span><br><span class="line">            m_DBInfo.strPwd, m_DBInfo.strDBName))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!m_Mysql)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    MYSQL_RES* result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint64_t</span> rowCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> fieldCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//LOGI &lt;&lt; sql;</span></span><br><span class="line">        <span class="keyword">int</span> iTempRet = mysql_real_query(m_Mysql, sql, <span class="built_in">strlen</span>(sql));</span><br><span class="line">        <span class="keyword">if</span> (iTempRet)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">int</span> uErrno = mysql_errno(m_Mysql);</span><br><span class="line">            <span class="comment">//LOGI &lt;&lt; &quot;CDatabaseMysql::Query, mysql is abnormal, errno : &quot; &lt;&lt; uErrno;</span></span><br><span class="line">            <span class="keyword">if</span> (CR_SERVER_GONE_ERROR == uErrno)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//LOGI &lt;&lt; &quot;CDatabaseMysql::Query, mysql is disconnected!&quot;;</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">false</span> == initialize(m_DBInfo.strHost, m_DBInfo.strUser,</span><br><span class="line">                    m_DBInfo.strPwd, m_DBInfo.strDBName))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//LOGI &lt;&lt; sql;</span></span><br><span class="line">                iTempRet = mysql_real_query(m_Mysql, sql, <span class="built_in">strlen</span>(sql));</span><br><span class="line">                <span class="keyword">if</span> (iTempRet)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//LOGE &lt;&lt; &quot;SQL: &quot; &lt;&lt; sql ;</span></span><br><span class="line">                    <span class="comment">//LOGE &lt;&lt; &quot;query ERROR: &quot; &lt;&lt; mysql_error(m_Mysql);</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//LOGE &lt;&lt; &quot;SQL: &quot; &lt;&lt; sql ;</span></span><br><span class="line">                <span class="comment">//LOGE &lt;&lt; &quot;query ERROR: &quot; &lt;&lt; mysql_error(m_Mysql);</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//LOGI &lt;&lt; &quot;call mysql_store_result&quot;;</span></span><br><span class="line">        result = mysql_store_result(m_Mysql);<span class="comment">//返回mysql查询结果集</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回改变，删除或插入的最后一条语句的行数,对于 SELECT语句，其 mysql_affected_rows()工作方式类似于mysql_num_rows()</span></span><br><span class="line">        rowCount = mysql_affected_rows(m_Mysql);</span><br><span class="line">        <span class="comment">//返回连接上最新查询的列数</span></span><br><span class="line">        fieldCount = mysql_field_count(m_Mysql);</span><br><span class="line">        <span class="comment">// end guarded block</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!result)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  if (!rowCount)</span></span><br><span class="line">    <span class="comment">//  &#123;</span></span><br><span class="line">          <span class="comment">//LOGI &lt;&lt; &quot;call mysql_free_result&quot;;</span></span><br><span class="line">    <span class="comment">//      mysql_free_result(result);</span></span><br><span class="line">    <span class="comment">//      return NULL;</span></span><br><span class="line">    <span class="comment">//  &#125;</span></span><br><span class="line"></span><br><span class="line">    QueryResult* queryResult = <span class="keyword">new</span> QueryResult(result, rowCount, fieldCount);</span><br><span class="line"></span><br><span class="line">    queryResult-&gt;nextRow();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> queryResult;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">QueryResult* <span class="title">CDatabaseMysql::pquery</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* format, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!format) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    va_list ap;</span><br><span class="line">    <span class="keyword">char</span> szQuery[MAX_QUERY_LEN];</span><br><span class="line">    va_start(ap, format);</span><br><span class="line">    <span class="keyword">int</span> res = vsnprintf(szQuery, MAX_QUERY_LEN, format, ap);</span><br><span class="line">    va_end(ap);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//LOGE &lt;&lt; &quot;SQL Query truncated (and not execute) for format: &quot; &lt;&lt; format;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> query(szQuery);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CDatabaseMysql::execute</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* sql)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!m_Mysql)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> iTempRet = mysql_query(m_Mysql, sql);</span><br><span class="line">        <span class="keyword">if</span> (iTempRet)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">int</span> uErrno = mysql_errno(m_Mysql);</span><br><span class="line">            <span class="comment">//LOGI &lt;&lt; &quot;CDatabaseMysql::Query, mysql is abnormal, errno : &quot; &lt;&lt; uErrno;</span></span><br><span class="line">            <span class="keyword">if</span> (CR_SERVER_GONE_ERROR == uErrno)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//LOGI &lt;&lt; &quot;CDatabaseMysql::Query, mysql is disconnected!&quot;;</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">false</span> == initialize(m_DBInfo.strHost, m_DBInfo.strUser, m_DBInfo.strPwd, m_DBInfo.strDBName))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//LOGI &lt;&lt; sql;</span></span><br><span class="line">                iTempRet = mysql_real_query(m_Mysql, sql, <span class="built_in">strlen</span>(sql));</span><br><span class="line">                <span class="keyword">if</span> (iTempRet)</span><br><span class="line">                &#123;</span><br><span class="line">                    LOGE(<span class="string">&quot;sql error: %s, sql: %s&quot;</span>, mysql_error(m_Mysql), sql);</span><br><span class="line">                    <span class="comment">//LOGE &lt;&lt; &quot;query ERROR: &quot; &lt;&lt; mysql_error(m_Mysql);</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//LOGE &lt;&lt; &quot;SQL: &quot; &lt;&lt; sql;</span></span><br><span class="line">                <span class="comment">//LOGE &lt;&lt; &quot;query ERROR: &quot; &lt;&lt; mysql_error(m_Mysql);</span></span><br><span class="line">                LOGE(<span class="string">&quot;sql error: %s, sql: %s&quot;</span>, mysql_error(m_Mysql), sql);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CDatabaseMysql::execute</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* sql, <span class="keyword">uint32_t</span>&amp; uAffectedCount, <span class="keyword">int</span>&amp; nErrno)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!m_Mysql)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> iTempRet = mysql_query(m_Mysql, sql);</span><br><span class="line">        <span class="keyword">if</span> (iTempRet)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">int</span> uErrno = mysql_errno(m_Mysql);</span><br><span class="line">            <span class="comment">//LOGE &lt;&lt; &quot;CDatabaseMysql::Query, mysql is abnormal, errno : &quot; &lt;&lt; uErrno;</span></span><br><span class="line">            <span class="keyword">if</span> (CR_SERVER_GONE_ERROR == uErrno)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//LOGE &lt;&lt; &quot;CDatabaseMysql::Query, mysql is disconnected!&quot;;</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">false</span> == initialize(m_DBInfo.strHost, m_DBInfo.strUser,</span><br><span class="line">                    m_DBInfo.strPwd, m_DBInfo.strDBName))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//LOGI &lt;&lt; sql;</span></span><br><span class="line">                iTempRet = mysql_query(m_Mysql, sql);</span><br><span class="line">                nErrno = iTempRet;</span><br><span class="line">                <span class="keyword">if</span> (iTempRet)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//LOGE &lt;&lt; &quot;SQL: &quot; &lt;&lt; sql;</span></span><br><span class="line">                    <span class="comment">//LOGE &lt;&lt; &quot;query ERROR: &quot; &lt;&lt; mysql_error(m_Mysql);</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//LOGE &lt;&lt; &quot;SQL: &quot; &lt;&lt; sql;</span></span><br><span class="line">                <span class="comment">//LOGE &lt;&lt; &quot;query ERROR: &quot; &lt;&lt; mysql_error(m_Mysql);</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        uAffectedCount = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(mysql_affected_rows(m_Mysql));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CDatabaseMysql::pexecute</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* format, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!format)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    va_list ap;</span><br><span class="line">    <span class="keyword">char</span> szQuery[MAX_QUERY_LEN];</span><br><span class="line">    va_start(ap, format);</span><br><span class="line">    <span class="keyword">int</span> res = vsnprintf(szQuery, MAX_QUERY_LEN, format, ap);</span><br><span class="line">    va_end(ap);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//LOGE &lt;&lt; &quot;SQL Query truncated (and not execute) for format: &quot; &lt;&lt; format;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!m_Mysql)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> iTempRet = mysql_query(m_Mysql, szQuery);</span><br><span class="line">        <span class="keyword">if</span> (iTempRet)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">int</span> uErrno = mysql_errno(m_Mysql);</span><br><span class="line">            <span class="comment">//LOGE &lt;&lt; &quot;CDatabaseMysql::Query, mysql is abnormal, errno : &quot; &lt;&lt; uErrno;</span></span><br><span class="line">            <span class="keyword">if</span> (CR_SERVER_GONE_ERROR == uErrno)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//LOGE &lt;&lt; &quot;CDatabaseMysql::Query, mysql is disconnected!&quot;;</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">false</span> == initialize(m_DBInfo.strHost, m_DBInfo.strUser,</span><br><span class="line">                    m_DBInfo.strPwd, m_DBInfo.strDBName))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//LOGI &lt;&lt; szQuery;</span></span><br><span class="line">                iTempRet = mysql_query(m_Mysql, szQuery);</span><br><span class="line">                <span class="keyword">if</span> (iTempRet)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//LOGE &lt;&lt; &quot;SQL: &quot; &lt;&lt; szQuery;</span></span><br><span class="line">                    <span class="comment">//LOGE &lt;&lt; &quot;query ERROR: &quot; &lt;&lt; mysql_error(m_Mysql);</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//LOGE &lt;&lt; &quot;SQL: &quot; &lt;&lt; szQuery;</span></span><br><span class="line">                <span class="comment">//LOGE &lt;&lt; &quot;query ERROR: &quot; &lt;&lt; mysql_error(m_Mysql);</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CDatabaseMysql::clearStoredResults</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!m_Mysql)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MYSQL_RES* result = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (!mysql_next_result(m_Mysql))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((result = mysql_store_result(m_Mysql)) != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            mysql_free_result(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">CDatabaseMysql::getInsertID</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">uint32_t</span>)mysql_insert_id(m_Mysql);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">CDatabaseMysql::escapeString</span><span class="params">(<span class="keyword">char</span>* szDst, <span class="keyword">const</span> <span class="keyword">char</span>* szSrc, <span class="keyword">uint32_t</span> uSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//szDst保存语句的容器，szSrc执行语句，uSize：执行语句的长度</span></span><br><span class="line">    <span class="keyword">if</span> (m_Mysql == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (szDst == <span class="literal">NULL</span> || szSrc == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mysql_real_escape_string(m_Mysql, szDst, szSrc, uSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MysqlManager"><a href="#MysqlManager" class="headerlink" title="MysqlManager"></a>MysqlManager</h3><h4 id="MysqlManager-h"><a href="#MysqlManager-h" class="headerlink" title="MysqlManager.h"></a>MysqlManager.h</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../mysqlapi/DatabaseMysql.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXCMDLEN 8192</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">STableField</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	STableField()&#123;&#125;</span><br><span class="line">	STableField(<span class="built_in">std</span>::<span class="built_in">string</span> strName,<span class="built_in">std</span>::<span class="built_in">string</span> strType,<span class="built_in">std</span>::<span class="built_in">string</span> strIndex):</span><br><span class="line">		m_strName(strName),</span><br><span class="line">		m_strType(strType),</span><br><span class="line">		m_strDesc(strIndex)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> m_strName;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> m_strType;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> m_strDesc;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">STableInfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	STableInfo()&#123;&#125;</span><br><span class="line">	STableInfo(<span class="built_in">std</span>::<span class="built_in">string</span> strName)</span><br><span class="line">		:m_strName(strName)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> m_strName;<span class="comment">//表名</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>,STableField&gt; m_mapField;<span class="comment">//string字段名，STableField字段约束语句</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> m_strKeyString;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMysqlManager</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CMysqlManager(<span class="keyword">void</span>);</span><br><span class="line">    <span class="keyword">virtual</span> ~CMysqlManager(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* host, <span class="keyword">const</span> <span class="keyword">char</span>* user, <span class="keyword">const</span> <span class="keyword">char</span>* pwd, <span class="keyword">const</span> <span class="keyword">char</span>* dbname)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">getHost</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_strHost; &#125;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">getUser</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_strUser; &#125;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">getPwd</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_strPassword; &#125;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">getDBName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_strDataBase; &#125;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">getCharSet</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_strCharactSet;  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">isDBExist</span><span class="params">()</span></span>;<span class="comment">//判断数据库是否存在</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">createDB</span><span class="params">()</span></span>;<span class="comment">//创建数据库</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">checkTable</span><span class="params">(<span class="keyword">const</span> STableInfo&amp; table)</span></span>;<span class="comment">//判断表是否存在</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">createTable</span><span class="params">(<span class="keyword">const</span> STableInfo&amp; table)</span></span>;<span class="comment">//创建表</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">updateTable</span><span class="params">(<span class="keyword">const</span> STableInfo&amp; table)</span></span>;<span class="comment">//未定义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;CDatabaseMysql&gt;     m_poConn;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span>                         m_strHost;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span>                         m_strUser;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span>                         m_strPassword;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span>                         m_strDataBase;<span class="comment">//数据库</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span>                         m_strCharactSet;<span class="comment">//字符编码</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;STableInfo&gt;             m_vecTableInfo;<span class="comment">//创建表的语句容器</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="MysqlManager-cpp"><a href="#MysqlManager-cpp" class="headerlink" title="MysqlManager.cpp"></a>MysqlManager.cpp</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;MysqlManager.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../base/AsyncLog.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../base/Singleton.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;MysqlThrdMgr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CMysqlManager::CMysqlManager(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//<span class="doctag">TODO:</span> m_strCharactSet可以放在初始化列表中初始化</span></span><br><span class="line">    m_strCharactSet = <span class="string">&quot;utf8&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化表 </span></span><br><span class="line">	<span class="comment">// 1. t_user </span></span><br><span class="line">	&#123;</span><br><span class="line">		STableInfo info;</span><br><span class="line">		<span class="comment">//name type desc?</span></span><br><span class="line">        info.m_strName = <span class="string">&quot;t_user&quot;</span>;</span><br><span class="line">        info.m_mapField[<span class="string">&quot;f_id&quot;</span>] = &#123; <span class="string">&quot;f_id&quot;</span>, <span class="string">&quot;bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;自增ID&#x27;&quot;</span>, <span class="string">&quot;bigint(20)&quot;</span> &#125;;</span><br><span class="line">        info.m_mapField[<span class="string">&quot;f_user_id&quot;</span>] = &#123; <span class="string">&quot;f_user_id&quot;</span>, <span class="string">&quot;bigint(20) NOT NULL COMMENT &#x27;用户ID&#x27;&quot;</span>, <span class="string">&quot;bigint(20)&quot;</span> &#125;;</span><br><span class="line">        info.m_mapField[<span class="string">&quot;f_username&quot;</span>] = &#123; <span class="string">&quot;f_username&quot;</span>, <span class="string">&quot;varchar(64) NOT NULL COMMENT &#x27;用户名&#x27;&quot;</span>, <span class="string">&quot;varchar(64)&quot;</span> &#125;;</span><br><span class="line">        info.m_mapField[<span class="string">&quot;f_nickname&quot;</span>] = &#123; <span class="string">&quot;f_nickname&quot;</span>, <span class="string">&quot;varchar(64) NOT NULL COMMENT &#x27;用户昵称&#x27;&quot;</span>, <span class="string">&quot;varchar(64)&quot;</span> &#125;;</span><br><span class="line">        info.m_mapField[<span class="string">&quot;f_password&quot;</span>] = &#123; <span class="string">&quot;f_password&quot;</span>, <span class="string">&quot;varchar(64) NOT NULL COMMENT &#x27;用户密码&#x27;&quot;</span>, <span class="string">&quot;varchar(64)&quot;</span> &#125;;</span><br><span class="line">        info.m_mapField[<span class="string">&quot;f_facetype&quot;</span>] = &#123; <span class="string">&quot;f_facetype&quot;</span>, <span class="string">&quot;int(10) DEFAULT 0 COMMENT &#x27;用户头像类型&#x27;&quot;</span>, <span class="string">&quot;int(10)&quot;</span> &#125;;</span><br><span class="line">        info.m_mapField[<span class="string">&quot;f_customface&quot;</span>] = &#123; <span class="string">&quot;f_customface&quot;</span>, <span class="string">&quot;varchar(32) DEFAULT NULL COMMENT &#x27;自定义头像名&#x27;&quot;</span>, <span class="string">&quot;varchar(32)&quot;</span> &#125;;</span><br><span class="line">        info.m_mapField[<span class="string">&quot;f_customfacefmt&quot;</span>] = &#123; <span class="string">&quot;f_customfacefmt&quot;</span>, <span class="string">&quot;varchar(6) DEFAULT NULL COMMENT &#x27;自定义头像格式&#x27;&quot;</span>, <span class="string">&quot;varchar(6)&quot;</span> &#125;;</span><br><span class="line">        info.m_mapField[<span class="string">&quot;f_gender&quot;</span>] = &#123; <span class="string">&quot;f_gender&quot;</span>, <span class="string">&quot;int(2)  DEFAULT 0 COMMENT &#x27;性别&#x27;&quot;</span>, <span class="string">&quot;int(2)&quot;</span> &#125;;</span><br><span class="line">        info.m_mapField[<span class="string">&quot;f_birthday&quot;</span>] = &#123; <span class="string">&quot;f_birthday&quot;</span>, <span class="string">&quot;bigint(20)  DEFAULT 19900101 COMMENT &#x27;生日&#x27;&quot;</span>, <span class="string">&quot;bigint(20)&quot;</span> &#125;;</span><br><span class="line">        info.m_mapField[<span class="string">&quot;f_signature&quot;</span>] = &#123; <span class="string">&quot;f_signature&quot;</span>, <span class="string">&quot;varchar(256) DEFAULT NULL COMMENT &#x27;地址&#x27;&quot;</span>, <span class="string">&quot;varchar(256)&quot;</span> &#125;;</span><br><span class="line">        info.m_mapField[<span class="string">&quot;f_address&quot;</span>] = &#123; <span class="string">&quot;f_address&quot;</span>, <span class="string">&quot;varchar(256) DEFAULT NULL COMMENT &#x27;地址&#x27;&quot;</span>, <span class="string">&quot;varchar(256)&quot;</span> &#125;;</span><br><span class="line">        info.m_mapField[<span class="string">&quot;f_phonenumber&quot;</span>] = &#123; <span class="string">&quot;f_phonenumber&quot;</span>, <span class="string">&quot;varchar(64) DEFAULT NULL COMMENT &#x27;电话&#x27;&quot;</span>, <span class="string">&quot;varchar(64)&quot;</span> &#125;;</span><br><span class="line">        info.m_mapField[<span class="string">&quot;f_mail&quot;</span>] = &#123; <span class="string">&quot;f_mail&quot;</span>, <span class="string">&quot;varchar(256) DEFAULT NULL COMMENT &#x27;邮箱&#x27;&quot;</span>, <span class="string">&quot;varchar(256)&quot;</span> &#125;;</span><br><span class="line">        info.m_mapField[<span class="string">&quot;f_owner_id&quot;</span>] = &#123; <span class="string">&quot;f_owner_id&quot;</span>, <span class="string">&quot;bigint(20) DEFAULT 0 COMMENT &#x27;群账号群主userid&#x27;&quot;</span>, <span class="string">&quot;bigint(20)&quot;</span> &#125;;</span><br><span class="line">        info.m_mapField[<span class="string">&quot;f_teaminfo&quot;</span>] = &#123; <span class="string">&quot;f_teaminfo&quot;</span>, <span class="string">&quot;blob default null comment &#x27;好友分组信息&#x27;&quot;</span>, <span class="string">&quot;blob&quot;</span> &#125;;</span><br><span class="line">        info.m_mapField[<span class="string">&quot;f_register_time&quot;</span>] = &#123; <span class="string">&quot;f_register_time&quot;</span>, <span class="string">&quot;datetime NOT NULL COMMENT &#x27;注册时间&#x27;&quot;</span>, <span class="string">&quot;datetime&quot;</span> &#125;;</span><br><span class="line">        info.m_mapField[<span class="string">&quot;f_remark&quot;</span>] = &#123; <span class="string">&quot;f_remark&quot;</span>, <span class="string">&quot;varchar(64) NULL COMMENT &#x27;备注&#x27;&quot;</span>, <span class="string">&quot;varchar(64)&quot;</span> &#125;;</span><br><span class="line">        info.m_mapField[<span class="string">&quot;f_update_time&quot;</span>] = &#123; <span class="string">&quot;f_update_time&quot;</span>, <span class="string">&quot;timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#x27;更新时间&#x27;&quot;</span>, <span class="string">&quot;timestamp&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">        info.m_strKeyString = <span class="string">&quot;PRIMARY KEY (f_user_id), INDEX f_user_id (f_user_id), KEY  f_id  ( f_id )&quot;</span>;</span><br><span class="line">        m_vecTableInfo.push_back(info);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//info.m_mapField[&quot;AccountID&quot;] = &#123; &quot;AccountID&quot;, &quot;integer NOT NULL AUTO_INCREMENT PRIMARY KEY&quot;, &quot;int(11)&quot; &#125;;</span></span><br><span class="line">		<span class="comment">//info.m_mapField[&quot;MobilePhone&quot;] = &#123; &quot;MobilePhone&quot;, &quot;bigint NOT NULL&quot;, &quot;bigint(20)&quot; &#125;;</span></span><br><span class="line">		<span class="comment">//info.m_mapField[&quot;NickName&quot;] = &#123; &quot;NickName&quot;, &quot;char(65) not null&quot;, &quot;char(65)&quot; &#125;;</span></span><br><span class="line">		<span class="comment">//info.m_mapField[&quot;PassWord&quot;] = &#123; &quot;PassWord&quot;, &quot;char(65) not null&quot;, &quot;char(65)&quot; &#125;;</span></span><br><span class="line">		<span class="comment">////info.m_mapField[&quot;Friend&quot;] = &#123; &quot;Friend&quot;, &quot;blob not null&quot;, &quot;blob&quot; &#125;;</span></span><br><span class="line">  <span class="comment">//      info.m_mapField[&quot;Friend&quot;] = &#123; &quot;Friend&quot;, &quot;blob default null&quot;, &quot;blob&quot; &#125;;</span></span><br><span class="line">		<span class="comment">//info.m_mapField[&quot;PersonInfo&quot;] = &#123; &quot;PersonInfo&quot;, &quot;blob default null&quot;, &quot;blob&quot; &#125;;</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">//info.m_strKeyString = &quot;UNIQUE KEY(MobilePhone)&quot;;</span></span><br><span class="line">		<span class="comment">//m_vecTableInfo.push_back(info);</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. t_user_relationship </span></span><br><span class="line">    &#123;</span><br><span class="line">        STableInfo info;</span><br><span class="line">        <span class="comment">//name type desc?</span></span><br><span class="line">        info.m_strName = <span class="string">&quot;t_user_relationship&quot;</span>;</span><br><span class="line">        info.m_mapField[<span class="string">&quot;f_id&quot;</span>] = &#123; <span class="string">&quot;f_id&quot;</span>, <span class="string">&quot;bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;自增ID&#x27;&quot;</span>, <span class="string">&quot;bigint(20)&quot;</span> &#125;;</span><br><span class="line">        info.m_mapField[<span class="string">&quot;f_user_id1&quot;</span>] = &#123; <span class="string">&quot;f_user_id1&quot;</span>, <span class="string">&quot;bigint(20) NOT NULL COMMENT &#x27;用户ID&#x27;&quot;</span>, <span class="string">&quot;bigint(20)&quot;</span> &#125;;</span><br><span class="line">        info.m_mapField[<span class="string">&quot;f_user_id2&quot;</span>] = &#123; <span class="string">&quot;f_user_id2&quot;</span>, <span class="string">&quot;bigint(20) NOT NULL COMMENT &#x27;用户ID&#x27;&quot;</span>, <span class="string">&quot;bigint(20)&quot;</span> &#125;;</span><br><span class="line">        info.m_mapField[<span class="string">&quot;f_user1_teamname&quot;</span>] = &#123; <span class="string">&quot;f_user1_teamname&quot;</span>, <span class="string">&quot;VARCHAR(32) NOT NULL DEFAULT &#x27;My Friends&#x27; COMMENT &#x27;用户2在用户1的好友分组名称&#x27;&quot;</span>, <span class="string">&quot;VARCHAR(32)&quot;</span> &#125;;</span><br><span class="line">        info.m_mapField[<span class="string">&quot;f_user2_teamname&quot;</span>] = &#123; <span class="string">&quot;f_user2_teamname&quot;</span>, <span class="string">&quot;VARCHAR(32) NOT NULL DEFAULT &#x27;My Friends&#x27; COMMENT &#x27;用户1在用户2的好友分组名称&#x27;&quot;</span>, <span class="string">&quot;VARCHAR(32)&quot;</span> &#125;;</span><br><span class="line">        info.m_mapField[<span class="string">&quot;f_user1_markname&quot;</span>] = &#123; <span class="string">&quot;f_user1_markname&quot;</span>, <span class="string">&quot;VARCHAR(32) COMMENT &#x27;用户2在用户1的备注名称&#x27;&quot;</span>, <span class="string">&quot;VARCHAR(32)&quot;</span> &#125;,</span><br><span class="line">        info.m_mapField[<span class="string">&quot;f_user2_markname&quot;</span>] = &#123; <span class="string">&quot;f_user2_markname&quot;</span>, <span class="string">&quot;VARCHAR(32) COMMENT &#x27;用户1在用户2的备注名称&#x27;&quot;</span>, <span class="string">&quot;VARCHAR(32)&quot;</span> &#125;,</span><br><span class="line">        info.m_mapField[<span class="string">&quot;f_remark&quot;</span>] = &#123; <span class="string">&quot;f_remark&quot;</span>, <span class="string">&quot;varchar(64) NULL COMMENT &#x27;备注&#x27;&quot;</span>, <span class="string">&quot;varchar(64)&quot;</span> &#125;;</span><br><span class="line">        info.m_mapField[<span class="string">&quot;f_update_time&quot;</span>] = &#123; <span class="string">&quot;f_update_time&quot;</span>, <span class="string">&quot;timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#x27;更新时间&#x27;&quot;</span>, <span class="string">&quot;timestamp&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">        info.m_strKeyString = <span class="string">&quot;PRIMARY KEY (f_id), INDEX f_id (f_id)&quot;</span>;</span><br><span class="line">        m_vecTableInfo.push_back(info);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//info.m_mapField[&quot;AccountID&quot;] = &#123; &quot;AccountID&quot;, &quot;integer NOT NULL AUTO_INCREMENT PRIMARY KEY&quot;, &quot;int(11)&quot; &#125;;</span></span><br><span class="line">        <span class="comment">//info.m_mapField[&quot;MobilePhone&quot;] = &#123; &quot;MobilePhone&quot;, &quot;bigint NOT NULL&quot;, &quot;bigint(20)&quot; &#125;;</span></span><br><span class="line">        <span class="comment">//info.m_mapField[&quot;NickName&quot;] = &#123; &quot;NickName&quot;, &quot;char(65) not null&quot;, &quot;char(65)&quot; &#125;;</span></span><br><span class="line">        <span class="comment">//info.m_mapField[&quot;PassWord&quot;] = &#123; &quot;PassWord&quot;, &quot;char(65) not null&quot;, &quot;char(65)&quot; &#125;;</span></span><br><span class="line">        <span class="comment">////info.m_mapField[&quot;Friend&quot;] = &#123; &quot;Friend&quot;, &quot;blob not null&quot;, &quot;blob&quot; &#125;;</span></span><br><span class="line">        <span class="comment">//      info.m_mapField[&quot;Friend&quot;] = &#123; &quot;Friend&quot;, &quot;blob default null&quot;, &quot;blob&quot; &#125;;</span></span><br><span class="line">        <span class="comment">//info.m_mapField[&quot;PersonInfo&quot;] = &#123; &quot;PersonInfo&quot;, &quot;blob default null&quot;, &quot;blob&quot; &#125;;</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//info.m_strKeyString = &quot;UNIQUE KEY(MobilePhone)&quot;;</span></span><br><span class="line">        <span class="comment">//m_vecTableInfo.push_back(info);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3. t_chatmsg </span></span><br><span class="line">	&#123;</span><br><span class="line">		STableInfo chat;</span><br><span class="line">		chat.m_strName = <span class="string">&quot;t_chatmsg&quot;</span>;</span><br><span class="line">		chat.m_mapField[<span class="string">&quot;f_id&quot;</span>] = &#123; <span class="string">&quot;f_id&quot;</span>, <span class="string">&quot;bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;自增ID&#x27;&quot;</span>, <span class="string">&quot;bigint(20)&quot;</span> &#125;;</span><br><span class="line">		chat.m_mapField[<span class="string">&quot;f_senderid&quot;</span>] = &#123; <span class="string">&quot;f_senderid&quot;</span>, <span class="string">&quot;bigint(20) NOT NULL COMMENT &#x27;发送者id&#x27;&quot;</span>, <span class="string">&quot;bigint(20)&quot;</span> &#125;;</span><br><span class="line">		chat.m_mapField[<span class="string">&quot;f_targetid&quot;</span>] = &#123; <span class="string">&quot;f_targetid&quot;</span>, <span class="string">&quot;bigint(20) NOT NULL COMMENT &#x27;接收者id&#x27;&quot;</span>, <span class="string">&quot;bigint(20)&quot;</span> &#125;;</span><br><span class="line">        chat.m_mapField[<span class="string">&quot;f_msgcontent&quot;</span>] = &#123; <span class="string">&quot;f_msgcontent&quot;</span>, <span class="string">&quot;BLOB NOT NULL COMMENT &#x27;聊天内容&#x27;&quot;</span>, <span class="string">&quot;BLOB&quot;</span> &#125;;</span><br><span class="line">        chat.m_mapField[<span class="string">&quot;f_create_time&quot;</span>] = &#123; <span class="string">&quot;f_create_time&quot;</span>, <span class="string">&quot;timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#x27;更新时间&#x27;&quot;</span>, <span class="string">&quot;timestamp&quot;</span> &#125;;</span><br><span class="line">        chat.m_mapField[<span class="string">&quot;f_remark&quot;</span>] = &#123; <span class="string">&quot;f_remark&quot;</span>, <span class="string">&quot;varchar(64) NULL COMMENT &#x27;备注&#x27;&quot;</span>, <span class="string">&quot;varchar(64)&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">        chat.m_strKeyString = <span class="string">&quot;PRIMARY KEY (f_id), INDEX f_id (f_id)&quot;</span>;</span><br><span class="line">		m_vecTableInfo.push_back(chat);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CMysqlManager::~CMysqlManager(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CMysqlManager::init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* host, <span class="keyword">const</span> <span class="keyword">char</span>* user, <span class="keyword">const</span> <span class="keyword">char</span>* pwd, <span class="keyword">const</span> <span class="keyword">char</span>* dbname)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	m_strHost = host;</span><br><span class="line">	m_strUser = user;</span><br><span class="line">    <span class="comment">//数据库密码可能为空</span></span><br><span class="line">    <span class="keyword">if</span> (pwd != <span class="literal">NULL</span>)</span><br><span class="line">	    m_strPassword = pwd;</span><br><span class="line">	m_strDataBase = dbname;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//注意：检查数据库是否存在时，需要将数据库名称设置为空</span></span><br><span class="line">	m_poConn.reset(<span class="keyword">new</span> CDatabaseMysql());</span><br><span class="line">    <span class="keyword">if</span> (!m_poConn-&gt;initialize(m_strHost, m_strUser, m_strPassword, <span class="string">&quot;&quot;</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//LOG_FATAL &lt;&lt; &quot;CMysqlManager::Init failed, please check params(&quot; &lt;&lt; m_strHost &lt;&lt; &quot;, &quot; &lt;&lt; m_strUser &lt;&lt; &quot;, &quot; &lt;&lt; m_strPassword &lt;&lt; &quot;)&quot;;</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">////////////////////// 1. 检查库是否存在 /////////////////////////</span></span><br><span class="line">	<span class="keyword">if</span> (!isDBExist())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!createDB())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//再次确定是否可以连接上数据库</span></span><br><span class="line">    m_poConn.reset(<span class="keyword">new</span> CDatabaseMysql());</span><br><span class="line">	<span class="keyword">if</span> (!m_poConn-&gt;initialize(m_strHost, m_strUser, m_strPassword, m_strDataBase))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//LOG_FATAL &lt;&lt; &quot;CMysqlManager::Init failed, please check params(&quot; &lt;&lt; m_strHost &lt;&lt; &quot;, &quot; &lt;&lt; m_strUser</span></span><br><span class="line">		<span class="comment">//	&lt;&lt; &quot;, &quot; &lt;&lt; m_strPassword &lt;&lt; &quot;, &quot; &lt;&lt; m_strDataBase &lt;&lt; &quot;)&quot;;</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">////////////////////// 2. 检查库中表是否正确 /////////////////////////</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; m_vecTableInfo.size(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		STableInfo table = m_vecTableInfo[i];</span><br><span class="line">		<span class="keyword">if</span> (!checkTable(table))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//LOG_FATAL &lt;&lt; &quot;CMysqlManager::Init, table check failed : &quot; &lt;&lt; table.m_strName;</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">////////////////////// 2. 检查库中表是否正确 /////////////////////////</span></span><br><span class="line"></span><br><span class="line">    m_poConn.reset();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CMysqlManager::isDBExist</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == m_poConn)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	QueryResult* pResult = m_poConn-&gt;query(<span class="string">&quot;show databases&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == pResult)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//LOGI &lt;&lt; &quot;CMysqlManager::_IsDBExist, no database(&quot; &lt;&lt; m_strDataBase &lt;&lt; &quot;)&quot;;</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Field* pRow = pResult-&gt;fetch();</span><br><span class="line">	<span class="keyword">while</span> (pRow != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">string</span> name = pRow[<span class="number">0</span>].getString();</span><br><span class="line">		<span class="keyword">if</span> (name == m_strDataBase)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//LOGI &lt;&lt; &quot;CMysqlManager::_IsDBExist, find database(&quot; &lt;&lt; m_strDataBase &lt;&lt; &quot;)&quot;;</span></span><br><span class="line">			pResult-&gt;endQuery();</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (pResult-&gt;nextRow() == <span class="literal">false</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		pRow = pResult-&gt;fetch();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//LOGI &lt;&lt; &quot;CMysqlManager::_IsDBExist, no database(&quot; &lt;&lt; m_strDataBase &lt;&lt; &quot;)&quot;;</span></span><br><span class="line">	pResult-&gt;endQuery();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> pResult;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CMysqlManager::createDB</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == m_poConn)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">uint32_t</span> uAffectedCount = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> nErrno = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">stringstream</span> ss;</span><br><span class="line">	ss &lt;&lt; <span class="string">&quot;create database &quot;</span> &lt;&lt; m_strDataBase;</span><br><span class="line">	<span class="keyword">if</span> (m_poConn-&gt;execute(ss.str().c_str(), uAffectedCount, nErrno))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (uAffectedCount == <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//LOGI &lt;&lt; &quot;CMysqlManager::_CreateDB, create database &quot; &lt;&lt;</span></span><br><span class="line">			<span class="comment">//	m_strDataBase &lt;&lt; &quot; success&quot;;</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//LOGE &lt;&lt; &quot;CMysqlManager::_CreateDB, create database &quot; &lt;&lt; m_strDataBase &lt;&lt; &quot; failed(&quot;</span></span><br><span class="line">		<span class="comment">//	&lt;&lt; nErrno &lt;&lt; &quot;)&quot;;</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CMysqlManager::checkTable</span><span class="params">(<span class="keyword">const</span> STableInfo&amp; table)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == m_poConn)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (table.m_strName.find_first_not_of(<span class="string">&quot;\t\r\n &quot;</span>) == <span class="built_in">std</span>::<span class="built_in">string</span>::npos)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//LOGW &lt;&lt; &quot;CMysqlManager::_CheckTable, tale info not valid&quot;;</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">stringstream</span> ss;</span><br><span class="line">	ss &lt;&lt; <span class="string">&quot;desc &quot;</span> &lt;&lt; table.m_strName;</span><br><span class="line">	QueryResult* pResult = m_poConn-&gt;query(ss.str());</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == pResult)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//LOGI &lt;&lt; &quot;CMysqlManager::_CheckTable, no table&quot; &lt;&lt; table.m_strName &lt;&lt; &quot;, begin create.....&quot;;</span></span><br><span class="line">		<span class="keyword">if</span> (createTable(table))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//LOGI &lt;&lt; &quot;CMysqlManager::_CheckTable, &quot; &lt;&lt; table.m_strName &lt;&lt; &quot;, end create.....&quot;;</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="comment">// 检查字段是否匹配， 暂时只检查是否存在， 还需进一步看类型是否需要修改 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; mapOldTable;</span><br><span class="line">		Field* pRow = pResult-&gt;fetch();</span><br><span class="line">		<span class="keyword">while</span> (pRow != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">string</span> name = pRow[<span class="number">0</span>].getString();</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">string</span> type = pRow[<span class="number">1</span>].getString();</span><br><span class="line">			mapOldTable[name] = type;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (pResult-&gt;nextRow() == <span class="literal">false</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			pRow = pResult-&gt;fetch();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		pResult-&gt;endQuery();</span><br><span class="line">        <span class="keyword">delete</span> pResult;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, STableField&gt;::const_iterator it = table.m_mapField.begin();</span><br><span class="line">			it != table.m_mapField.end(); ++it)</span><br><span class="line">		&#123;<span class="comment">//检查字段是否正确</span></span><br><span class="line">			STableField field = it-&gt;second;</span><br><span class="line">			<span class="keyword">if</span> (mapOldTable.find(field.m_strName) == mapOldTable.end())</span><br><span class="line">			&#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">stringstream</span> ss;</span><br><span class="line">				ss &lt;&lt; <span class="string">&quot;alter table &quot;</span> &lt;&lt; table.m_strName &lt;&lt; <span class="string">&quot; add column &quot;</span></span><br><span class="line">					&lt;&lt; field.m_strName &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; field.m_strType;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">string</span> sql = ss.str();</span><br><span class="line">				<span class="keyword">if</span> (m_poConn-&gt;execute(sql.c_str()))</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">//LOGI &lt;&lt; sql;</span></span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">//LOGE &lt;&lt; &quot;CMysqlManager::_CheckTable failed : &quot; &lt;&lt; sql;</span></span><br><span class="line">					<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CMysqlManager::createTable</span><span class="params">(<span class="keyword">const</span> STableInfo&amp; table)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (table.m_mapField.size() == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//LOGE &lt;&lt; &quot;CMysqlManager::_CreateTable, table info not valid, &quot; &lt;&lt; table.m_strName;</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stringstream</span> ss;</span><br><span class="line">	ss &lt;&lt; <span class="string">&quot;CREATE TABLE IF NOT EXISTS &quot;</span> &lt;&lt; table.m_strName &lt;&lt; <span class="string">&quot; (&quot;</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, STableField&gt;::const_iterator it = table.m_mapField.begin();</span><br><span class="line">		it != table.m_mapField.end(); ++it)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (it != table.m_mapField.begin())</span><br><span class="line">		&#123;</span><br><span class="line">			ss &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		STableField field = it-&gt;second;</span><br><span class="line">		ss &lt;&lt; field.m_strName &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; field.m_strType;		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (table.m_strKeyString != <span class="string">&quot;&quot;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		ss &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; table.m_strKeyString;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ss &lt;&lt; <span class="string">&quot;)default charset = utf8, ENGINE = InnoDB;&quot;</span>;</span><br><span class="line">	<span class="keyword">if</span> (m_poConn-&gt;execute(ss.str().c_str()))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    LOGE(<span class="string">&quot;Create table error, sql: %s&quot;</span>, ss.str().c_str());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="有了以上的代码便可以对MySQL数据库进行基本的操作"><a href="#有了以上的代码便可以对MySQL数据库进行基本的操作" class="headerlink" title="有了以上的代码便可以对MySQL数据库进行基本的操作"></a>有了以上的代码便可以对MySQL数据库进行基本的操作</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;./base/AsyncLog.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;./mysqlmgr/MysqlManager.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;./mysqlapi/DatabaseMysql.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;./base/Singleton.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CMysqlManager &amp;test=Singleton&lt;CMysqlManager&gt;::Instance();<span class="comment">//使用单例模式</span></span><br><span class="line">    test.init(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="string">&quot;root&quot;</span>,<span class="string">&quot;55555&quot;</span>,<span class="string">&quot;flmaingo&quot;</span>);<span class="comment">//初始化</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hello, World!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行流程：</p>
<p>CMysqlManager类在初始化对象时，构造函数设置mysql字符编码=&gt;</p>
<p>并生成3个STableInfo临时结构体来保存建表语句=&gt;</p>
<p>而后将其push进入私有成员变量m_vecTableInfo(std::vector<STableInfo>)中保存，该变量是一个vertor|=&gt;</p>
<p>之后调用init函数进行初始化设置</p>
<p><strong><u>CMysqlManager::init</u></strong>:[初始化成员变量CDatabaseMysql型的指针m_poConn=&gt;而后调用CDatabaseMysql类的initialize函数]=&gt;</p>
<p>**<u>CDatabaseMysql::initialize</u>**函数:[接收MySQL连接所需的数据并接收一个空的数据库名=&gt;</p>
<p>调用mysql提供的api初始化CDatabaseMysql类的成员变量MYSQL类型的指针m_Mysql=&gt;</p>
<p>和mysql服务器建立连接=&gt;</p>
<p>初始化成员变量DatabaseInfo类型结构的m_DBInfo保存mysql的ip,port,dbname,user=&gt;</p>
<p>设置字符编码]=&gt;</p>
<p>initialize函数调用完成返回CMysqlManager::init函数=&gt;</p>
<p>init函数调用isDBExist函数判断数据库是否存在=&gt;</p>
<p><strong><u>CMysqlManager::isDBExist:</u></strong>{[调用CDatabaseMysql成员函数query执行show databases语句返回一个QueryResult类指针=&gt;</p>
<p><strong><u>CDatabaseMysql::query</u></strong>:[返回一个QueryResult指针执行mysql api获取一个mysql查询结果集，并获取mysql结果集的行数，当前处理指针位置=&gt;</p>
<p>利用三个参数构造一个QueryResult类</p>
<p><strong><u>QueryResult::QueryResult</u></strong>:(用传入的列数初始化成员变量 Field *   m_CurrentRow来保存mysql行数据=&gt;</p>
<p>调用mysql相关api获取数据，得到表头，将其存入QueryResult的m_vtFieldNames中)=&gt;</p>
<p>返回CMysqlManager::query函数调用queryResult::nextRow函数获取一行数据=&gt;</p>
<p>**<u>queryResult::nextRow</u>**：(提取结果集中的一行数据存入成员变量m_CurrentRow中)=&gt;</p>
<p>返回CMysqlManager::query函数=&gt;</p>
<p>返回一个queryResult型指针=&gt;</p>
<p>返回CMysqlManager::isDBExist函数=&gt;</p>
<p>获取QueryResult类成员变量m_CurrentRow中保存的mysql数据，取出数据库名和CMysqlManager::m_strDataBase中保存的数据库相比较，如果不匹配调用QueryResult::nextRow函数或许下一行继续比较，直到结果集为空，或者比较相等时结束循环=&gt;</p>
<p>调用QueryResult::endQuery释放mysql结果集，及QueryResult类的相关资源，返回真假以判断表是否存在]=&gt;</p>
<p>返回CMysqlManager::init函数=&gt;</p>
<p>若数据库不存在调用CMysqlManager::createDB函数创建数据库=&gt;</p>
<p>若存在则调用CMysqlManager::checkTable检查表是否存在=&gt;</p>
<p>若不存在则创建，若存在则检查字段是否存在及其类型是否正确若不正确则修改]}=&gt;</p>
<p>返回CMysqlManager::init函数初始化完成=&gt;</p>
<p>若初始化成功则可以调用成员变量std::shared_ptr<CDatabaseMysql>     m_poConn来执行一系列sql操作</p>
<h3 id="MysqlTask"><a href="#MysqlTask" class="headerlink" title="MysqlTask"></a>MysqlTask</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="comment">//MysqlTask.h纯虚类，未实现，提供接口，可以用来做MySQL连接池</span></span><br><span class="line"><span class="keyword">enum</span> EMysqlError</span><br><span class="line">&#123;</span><br><span class="line">    EME_ERROR = <span class="number">-1</span>,</span><br><span class="line">    EME_OK,</span><br><span class="line">    EME_NOT_EXIST,</span><br><span class="line">    EME_EXIST,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CDatabaseMysql</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IMysqlTask</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    IMysqlTask(<span class="keyword">void</span>) &#123;&#125;;</span><br><span class="line">    <span class="keyword">virtual</span> ~IMysqlTask(<span class="keyword">void</span>) &#123;&#125;;<span class="comment">//继承以释放资源</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(CDatabaseMysql* poConn)</span> </span>= <span class="number">0</span>;<span class="comment">//执行sql函数接口，数据库线程( CMysqlThrd::mainLoop)做查询</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">reply</span><span class="params">()</span> </span>= <span class="number">0</span>;<span class="comment">//获取数据接口，逻辑线程(CMysqlThrdMgr::processReplyTask)获取结果</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123; <span class="keyword">delete</span> <span class="keyword">this</span>; &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="TaskList"><a href="#TaskList" class="headerlink" title="TaskList"></a>TaskList</h3><h4 id="TaskList-h"><a href="#TaskList-h" class="headerlink" title="TaskList.h"></a>TaskList.h</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;MysqlTask.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TASK_NUM 1000</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTaskList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CTaskList();</span><br><span class="line">    ~CTaskList(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">push</span><span class="params">(IMysqlTask* poTask)</span></span>;                  <span class="comment">// 逻辑线程修改 </span></span><br><span class="line">    <span class="function">IMysqlTask* <span class="title">pop</span><span class="params">()</span></span>;				                <span class="comment">// 数据库线程修改 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">uint16_t</span>            m_uReadIndex;               <span class="comment">// 数据库线程修改 </span></span><br><span class="line">	<span class="keyword">uint16_t</span>            m_uWriteIndex;              <span class="comment">// 逻辑线程修改   </span></span><br><span class="line">	IMysqlTask*         m_pTaskNode[MAX_TASK_NUM];  <span class="comment">//一个环形队列，将要执行的MySQL操作，用一个IMysqlTask来保存，而后push进入m_pTaskNode池</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="TaskList-cpp"><a href="#TaskList-cpp" class="headerlink" title="TaskList.cpp"></a>TaskList.cpp</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;TaskList.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../base/AsyncLog.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">CTaskList::CTaskList() : m_uReadIndex(<span class="number">0</span>), m_uWriteIndex(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">memset</span>(m_pTaskNode, <span class="number">0</span>, <span class="keyword">sizeof</span>(m_pTaskNode));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CTaskList::~CTaskList(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_TASK_NUM; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">delete</span> m_pTaskNode[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CTaskList::push</span><span class="params">(IMysqlTask* poTask)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">uint16_t</span> usNextIndex = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint16_t</span>&gt;((m_uWriteIndex + <span class="number">1</span>) % MAX_TASK_NUM);</span><br><span class="line">	<span class="keyword">if</span> (usNextIndex == m_uReadIndex)<span class="comment">//池满</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// getchar();</span></span><br><span class="line">		<span class="comment">//LOGE &lt;&lt; &quot;mysql task list full (read : &quot; &lt;&lt; m_uReadIndex &lt;&lt; &quot;, write : &quot; &lt;&lt; m_uWriteIndex &lt;&lt; &quot;)&quot;;</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	m_pTaskNode[m_uWriteIndex] = poTask;</span><br><span class="line">	m_uWriteIndex = usNextIndex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">IMysqlTask* <span class="title">CTaskList::pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (m_uWriteIndex == m_uReadIndex)<span class="comment">//池为空</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	IMysqlTask* pTask = m_pTaskNode[m_uReadIndex];</span><br><span class="line">	m_uReadIndex = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint16_t</span>&gt;((m_uReadIndex + <span class="number">1</span>) % MAX_TASK_NUM);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> pTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MysqlThrd"><a href="#MysqlThrd" class="headerlink" title="MysqlThrd"></a>MysqlThrd</h3><h4 id="MysqlThrd-h"><a href="#MysqlThrd-h" class="headerlink" title="MysqlThrd.h"></a>MysqlThrd.h</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../mysqlapi/DatabaseMysql.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;MysqlTask.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;TaskList.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMysqlThrd</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CMysqlThrd(<span class="keyword">void</span>);</span><br><span class="line">    ~CMysqlThrd(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">start</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; host, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; user, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; pwd, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; dbname)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">addTask</span><span class="params">(IMysqlTask* poTask)</span><span class="comment">//向任务队列(sql执行队列)中添加任务</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> m_oTask.push(poTask);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">IMysqlTask* <span class="title">getReplyTask</span><span class="params">(<span class="keyword">void</span>)</span><span class="comment">//取出任务执行结果      </span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> m_oReplyTask.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">mainLoop</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">uninit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">bool</span>				                 m_bTerminate;<span class="comment">//线程是否运行标志</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="built_in">std</span>::thread&gt;         m_pThread;<span class="comment">//线程指针</span></span><br><span class="line">    <span class="keyword">bool</span>                                 m_bStart;<span class="comment">//线程启动标志</span></span><br><span class="line">	CDatabaseMysql*                      m_poConn;<span class="comment">//sql操作类指针</span></span><br><span class="line">    CTaskList                            m_oTask;<span class="comment">//待执行队列</span></span><br><span class="line">    CTaskList                            m_oReplyTask;<span class="comment">//查询结果集队列</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">std</span>::mutex                           mutex_;</span><br><span class="line">	<span class="built_in">std</span>::condition_variable              cond_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="MysqlThrd-cpp"><a href="#MysqlThrd-cpp" class="headerlink" title="MysqlThrd.cpp"></a>MysqlThrd.cpp</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;MysqlThrd.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt; //for std::bind</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../base/AsyncLog.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CMysqlThrd::CMysqlThrd(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	m_bTerminate	= <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    m_bStart        = <span class="literal">false</span>;</span><br><span class="line">    m_poConn        = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CMysqlThrd::~CMysqlThrd(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMysqlThrd::Run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	mainLoop();</span><br><span class="line">	uninit();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> != m_pThread)</span><br><span class="line">	&#123;</span><br><span class="line">		m_pThread-&gt;join();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CMysqlThrd::start</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; host, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; user, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; pwd, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; dbname)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	m_poConn = <span class="keyword">new</span> CDatabaseMysql();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == m_poConn)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//LOG_FATAL &lt;&lt; &quot;CMysqlThrd::Start, Cannot open database&quot;;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (m_poConn-&gt;initialize(host, user, pwd, dbname) == <span class="literal">false</span>)<span class="comment">//连接数据库</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMysqlThrd::stop</span><span class="params">()</span><span class="comment">//停止数据库线程</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (m_bTerminate)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	m_bTerminate = <span class="literal">true</span>;</span><br><span class="line">	m_pThread-&gt;join();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CMysqlThrd::init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_bStart)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动线程</span></span><br><span class="line">	m_pThread.reset(<span class="keyword">new</span> <span class="built_in">std</span>::thread(<span class="built_in">std</span>::bind(&amp;CMysqlThrd::mainLoop, <span class="keyword">this</span>)));<span class="comment">//启动数据库执行线程，并阻塞等待其启动成功后返回</span></span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">		<span class="keyword">while</span> (m_bStart == <span class="literal">false</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cond_.wait(lock);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMysqlThrd::uninit</span><span class="params">()</span><span class="comment">//释放资源转移到了CMysqlThrdMgr::processReplyTask，该函数调用，纯虚类的release函数释放资源</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//m_poConn-&gt;Close();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMysqlThrd::mainLoop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	m_bStart = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">		cond_.notify_all();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    IMysqlTask* poTask;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(!m_bTerminate)<span class="comment">//不停的从执行队列中取出SQL执行，而后将结果push到查询好的结果集中</span></span><br><span class="line">	&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span> != (poTask = m_oTask.pop()))<span class="comment">//从逻辑线程产生的SQL执行队列中取出一个来执行SQL</span></span><br><span class="line">        &#123;</span><br><span class="line">            poTask-&gt;execute(m_poConn);</span><br><span class="line">            m_oReplyTask.push(poTask);<span class="comment">//放入查询好的结果集到队列，以供逻辑线程获取</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::milliseconds(<span class="number">1000</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MysqlThrdMgr"><a href="#MysqlThrdMgr" class="headerlink" title="MysqlThrdMgr"></a>MysqlThrdMgr</h3><h4 id="MysqlThrdMgr-h"><a href="#MysqlThrdMgr-h" class="headerlink" title="MysqlThrdMgr.h"></a>MysqlThrdMgr.h</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;MysqlTask.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;MysqlThrd.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMysqlThrdMgr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CMysqlThrdMgr(<span class="keyword">void</span>);</span><br><span class="line">    <span class="keyword">virtual</span> ~CMysqlThrdMgr(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; host, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; user, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; pwd, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; dbname)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">addTask</span><span class="params">(<span class="keyword">uint32_t</span> dwHashID, IMysqlTask* poTask)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">addTask</span><span class="params">(IMysqlTask* poTask)</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> m_aoMysqlThreads[m_dwThreadsCount].addTask(poTask); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">uint32_t</span> <span class="title">getTableHashID</span><span class="params">(<span class="keyword">uint32_t</span> dwHashID)</span> <span class="keyword">const</span> </span></span><br><span class="line"><span class="function">    </span>&#123; <span class="comment">//选择线程</span></span><br><span class="line">        <span class="keyword">return</span> dwHashID % m_dwThreadsCount; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">processReplyTask</span><span class="params">(<span class="keyword">int32_t</span> nCount)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">uint32_t</span> <span class="title">getThreadsCount</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> m_dwThreadsCount; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">uint32_t</span> m_dwThreadsCount = <span class="number">9</span>;<span class="comment">//用于hash选择线程，所以比线程数少了一，但取模能取0-9十个</span></span><br><span class="line">	CMysqlThrd            m_aoMysqlThreads[m_dwThreadsCount+<span class="number">1</span>];<span class="comment">//逻辑线程队列，循环队列</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="MysqlThrdMgr-cpp"><a href="#MysqlThrdMgr-cpp" class="headerlink" title="MysqlThrdMgr.cpp"></a>MysqlThrdMgr.cpp</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;MysqlThrdMgr.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../base/AsyncLog.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">CMysqlThrdMgr::CMysqlThrdMgr(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CMysqlThrdMgr::~CMysqlThrdMgr(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CMysqlThrdMgr::addTask</span><span class="params">( <span class="keyword">uint32_t</span> dwHashID, IMysqlTask* poTask )</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//添加任务</span></span><br><span class="line">    <span class="comment">//LOG_DEBUG &lt;&lt; &quot;CMysqlThrdMgr::AddTask, HashID = &quot; &lt;&lt; dwHashID;</span></span><br><span class="line">	<span class="keyword">uint32_t</span> btIndex = getTableHashID(dwHashID);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (btIndex &gt;= m_dwThreadsCount)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> m_aoMysqlThreads[btIndex].addTask(poTask);<span class="comment">//选择0-9号线程中的一个添加任务</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CMysqlThrdMgr::init</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; host, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; user, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; pwd, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; dbname)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//启动10个任务线程(逻辑线程)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; m_dwThreadsCount+<span class="number">1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">false</span> == m_aoMysqlThreads[i].start(host, user, pwd, dbname))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CMysqlThrdMgr::processReplyTask</span><span class="params">(<span class="keyword">int32_t</span> nCount )</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//取出任务执行结果</span></span><br><span class="line">    <span class="keyword">bool</span> bResult = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; m_dwThreadsCount + <span class="number">1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        IMysqlTask* poTask = m_aoMysqlThreads[i].getReplyTask();</span><br><span class="line">		<span class="keyword">int32_t</span> dwProcessedNbr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (((nCount == <span class="number">-1</span>) || (dwProcessedNbr &lt; nCount)) &amp;&amp; (<span class="literal">NULL</span> != poTask))</span><br><span class="line">        &#123;</span><br><span class="line">            poTask-&gt;reply();</span><br><span class="line">            poTask-&gt;release();<span class="comment">//释放资源，释放CMysqlThrd::m_poConn指针</span></span><br><span class="line">            poTask = m_aoMysqlThreads[i].getReplyTask();</span><br><span class="line">            ++dwProcessedNbr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dwProcessedNbr == nCount)</span><br><span class="line">        &#123;</span><br><span class="line">            bResult = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="大致思想"><a href="#大致思想" class="headerlink" title="大致思想"></a>大致思想</h4><p>一个数据库执行线程，10个逻辑线程。逻辑线程只负责添加任务和取出任务执行结果，数据库执行线程负责调用</p>
<p>纯虚类(IMysqlTask)的函数执行任务，并将结果放入结果队列当中</p>
]]></content>
      <categories>
        <category>开源代码</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>mysql</tag>
        <tag>Flamingo</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp指针和引用的区别</title>
    <url>/posts/b159982d/</url>
    <content><![CDATA[<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> * <span class="title">mac</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> *i=<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">macp</span><span class="params">(<span class="keyword">int</span> *n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;*n&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> *p=&amp;i;</span><br><span class="line">	<span class="keyword">int</span> *pp=mac();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*p);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*pp);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h4 id="汇编代码"><a href="#汇编代码" class="headerlink" title="汇编代码"></a>汇编代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   0x00005555555549e4 &lt;+0&gt;:	push   rbp</span><br><span class="line">   0x00005555555549e5 &lt;+1&gt;:	mov    rbp,rsp</span><br><span class="line">   0x00005555555549e8 &lt;+4&gt;:	sub    rsp,0x20</span><br><span class="line">   0x00005555555549ec &lt;+8&gt;:	mov    rax,QWORD PTR fs:0x28</span><br><span class="line">   0x00005555555549f5 &lt;+17&gt;:	mov    QWORD PTR [rbp-0x8],rax</span><br><span class="line">   0x00005555555549f9 &lt;+21&gt;:	xor    eax,eax</span><br><span class="line">   0x00005555555549fb &lt;+23&gt;:	mov    DWORD PTR [rbp-0x1c],0xa</span><br><span class="line">&#x3D;&gt; 0x0000555555554a02 &lt;+30&gt;:	lea    rax,[rbp-0x1c]</span><br><span class="line">   0x0000555555554a06 &lt;+34&gt;:	mov    QWORD PTR [rbp-0x18],rax</span><br><span class="line">   0x0000555555554a0a &lt;+38&gt;:	call   0x55555555498a &lt;mac()&gt;</span><br><span class="line">   0x0000555555554a0f &lt;+43&gt;:	mov    QWORD PTR [rbp-0x10],rax</span><br><span class="line">   0x0000555555554a13 &lt;+47&gt;:	mov    rax,QWORD PTR [rbp-0x18]</span><br><span class="line">   0x0000555555554a17 &lt;+51&gt;:	mov    eax,DWORD PTR [rax]</span><br><span class="line">   0x0000555555554a19 &lt;+53&gt;:	mov    esi,eax</span><br><span class="line">   0x0000555555554a1b &lt;+55&gt;:	lea    rdi,[rip+0x123]        # 0x555555554b45</span><br><span class="line">   0x0000555555554a22 &lt;+62&gt;:	mov    eax,0x0</span><br><span class="line">   0x0000555555554a27 &lt;+67&gt;:	call   0x555555554800 &lt;printf@plt&gt;</span><br><span class="line">   0x0000555555554a2c &lt;+72&gt;:	mov    rax,QWORD PTR [rbp-0x10]</span><br><span class="line">   0x0000555555554a30 &lt;+76&gt;:	mov    eax,DWORD PTR [rax]</span><br><span class="line">   0x0000555555554a32 &lt;+78&gt;:	mov    esi,eax</span><br><span class="line">   0x0000555555554a34 &lt;+80&gt;:	lea    rdi,[rip+0x10a]        # 0x555555554b45</span><br><span class="line">   0x0000555555554a3b &lt;+87&gt;:	mov    eax,0x0</span><br><span class="line">   0x0000555555554a40 &lt;+92&gt;:	call   0x555555554800 &lt;printf@plt&gt;</span><br><span class="line">   0x0000555555554a45 &lt;+97&gt;:	mov    eax,0x0</span><br><span class="line">   0x0000555555554a4a &lt;+102&gt;:	mov    rdx,QWORD PTR [rbp-0x8]</span><br><span class="line">   0x0000555555554a4e &lt;+106&gt;:	xor    rdx,QWORD PTR fs:0x28</span><br><span class="line">   0x0000555555554a57 &lt;+115&gt;:	je     0x555555554a5e &lt;main()+122&gt;</span><br><span class="line">   0x0000555555554a59 &lt;+117&gt;:	call   0x555555554840 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">   0x0000555555554a5e &lt;+122&gt;:	leave  </span><br><span class="line">   0x0000555555554a5f &lt;+123&gt;:	ret    </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<h4 id="指针赋值"><a href="#指针赋值" class="headerlink" title="指针赋值"></a>指针赋值</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int *p&#x3D;&amp;i;</span><br><span class="line">   0x0000555555554a02 &lt;+30&gt;:	lea    rax,[rbp-0x1c]</span><br><span class="line">   0x0000555555554a06 &lt;+34&gt;:	mov    QWORD PTR [rbp-0x18],rax</span><br><span class="line">   [rbp-0x1c]为i的首地址，lea指令取其地址而后放入rax中</span><br><span class="line">   [rbp-0x18]为指针p的首地址，将rax中的值复制到其中完成指针的赋值</span><br></pre></td></tr></table></figure>

<h4 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h4><h5 id="mac函数汇编代码"><a href="#mac函数汇编代码" class="headerlink" title="mac函数汇编代码"></a>mac函数汇编代码</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Dump of assembler code for function mac():</span><br><span class="line">&#x3D;&gt; 0x000055555555498a &lt;+0&gt;:	push   rbp</span><br><span class="line">   0x000055555555498b &lt;+1&gt;:	mov    rbp,rsp</span><br><span class="line">   0x000055555555498e &lt;+4&gt;:	sub    rsp,0x10</span><br><span class="line">   0x0000555555554992 &lt;+8&gt;:	mov    edi,0x4</span><br><span class="line">   0x0000555555554997 &lt;+13&gt;:	call   0x555555554820 &lt;_Znwm@plt&gt;</span><br><span class="line">   0x000055555555499c &lt;+18&gt;:	mov    DWORD PTR [rax],0xa</span><br><span class="line">   0x00005555555549a2 &lt;+24&gt;:	mov    QWORD PTR [rbp-0x8],rax</span><br><span class="line">   0x00005555555549a6 &lt;+28&gt;:	mov    rax,QWORD PTR [rbp-0x8]</span><br><span class="line">   0x00005555555549aa &lt;+32&gt;:	leave  </span><br><span class="line">   0x00005555555549ab &lt;+33&gt;:	ret    </span><br><span class="line">End of assembler dump.</span><br><span class="line"></span><br><span class="line">mov    rax,QWORD PTR [rbp-0x8] 将返回值存入rax寄存器中</span><br><span class="line">mov    QWORD PTR [rbp-0x10],rax 将返回值复制到指针pp中</span><br></pre></td></tr></table></figure>

<h4 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0000555555554a13 &lt;+47&gt;:	mov    rax,QWORD PTR [rbp-0x18]&#x2F;&#x2F;将指针中保存的地址放入rax中</span><br><span class="line">0x0000555555554a17 &lt;+51&gt;:	mov    eax,DWORD PTR [rax]&#x2F;&#x2F;取出值</span><br><span class="line">0x0000555555554a19 &lt;+53&gt;:	mov    esi,eax&#x2F;&#x2F;利用地址取出值，该参数传递方法为寄存器传递</span><br><span class="line">0x0000555555554a1b &lt;+55&gt;:	lea    rdi,[rip+0x123]        # 0x555555554b45</span><br><span class="line">0x0000555555554a22 &lt;+62&gt;:	mov    eax,0x0</span><br><span class="line">0x0000555555554a27 &lt;+67&gt;:	call   0x555555554800 &lt;printf@plt&gt;</span><br></pre></td></tr></table></figure>

<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp;  <span class="title">mac</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> *i=<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">return</span> *i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">macp</span><span class="params">(<span class="keyword">int</span> &amp;n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i= <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> &amp;p=i;</span><br><span class="line">	p=mac();</span><br><span class="line">	macp(p);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,p);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="汇编代码-1"><a href="#汇编代码-1" class="headerlink" title="汇编代码"></a>汇编代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) disassemble </span><br><span class="line">Dump of assembler code for function main():</span><br><span class="line">   0x00005555555549e4 &lt;+0&gt;:	push   rbp</span><br><span class="line">   0x00005555555549e5 &lt;+1&gt;:	mov    rbp,rsp</span><br><span class="line">   0x00005555555549e8 &lt;+4&gt;:	sub    rsp,0x20</span><br><span class="line">   0x00005555555549ec &lt;+8&gt;:	mov    rax,QWORD PTR fs:0x28</span><br><span class="line">   0x00005555555549f5 &lt;+17&gt;:	mov    QWORD PTR [rbp-0x8],rax</span><br><span class="line">   0x00005555555549f9 &lt;+21&gt;:	xor    eax,eax</span><br><span class="line">&#x3D;&gt; 0x00005555555549fb &lt;+23&gt;:	mov    DWORD PTR [rbp-0x14],0xa</span><br><span class="line">   0x0000555555554a02 &lt;+30&gt;:	lea    rax,[rbp-0x14]</span><br><span class="line">   0x0000555555554a06 &lt;+34&gt;:	mov    QWORD PTR [rbp-0x10],rax</span><br><span class="line">   0x0000555555554a0a &lt;+38&gt;:	call   0x55555555498a &lt;mac()&gt;</span><br><span class="line">   0x0000555555554a0f &lt;+43&gt;:	mov    edx,DWORD PTR [rax]</span><br><span class="line">   0x0000555555554a11 &lt;+45&gt;:	mov    rax,QWORD PTR [rbp-0x10]</span><br><span class="line">   0x0000555555554a15 &lt;+49&gt;:	mov    DWORD PTR [rax],edx</span><br><span class="line">   0x0000555555554a17 &lt;+51&gt;:	mov    rax,QWORD PTR [rbp-0x10]</span><br><span class="line">   0x0000555555554a1b &lt;+55&gt;:	mov    rdi,rax</span><br><span class="line">   0x0000555555554a1e &lt;+58&gt;:	call   0x5555555549ac &lt;macp(int&amp;)&gt;</span><br><span class="line">   0x0000555555554a23 &lt;+63&gt;:	mov    rax,QWORD PTR [rbp-0x10]</span><br><span class="line">   0x0000555555554a27 &lt;+67&gt;:	mov    eax,DWORD PTR [rax]</span><br><span class="line">   0x0000555555554a29 &lt;+69&gt;:	mov    esi,eax</span><br><span class="line">   0x0000555555554a2b &lt;+71&gt;:	lea    rdi,[rip+0x113]        # 0x555555554b45</span><br><span class="line">   0x0000555555554a32 &lt;+78&gt;:	mov    eax,0x0</span><br><span class="line">   0x0000555555554a37 &lt;+83&gt;:	call   0x555555554800 &lt;printf@plt&gt;</span><br><span class="line">   0x0000555555554a3c &lt;+88&gt;:	mov    eax,0x0</span><br><span class="line">   0x0000555555554a41 &lt;+93&gt;:	mov    rcx,QWORD PTR [rbp-0x8]</span><br><span class="line">   0x0000555555554a45 &lt;+97&gt;:	xor    rcx,QWORD PTR fs:0x28</span><br><span class="line">   0x0000555555554a4e &lt;+106&gt;:	je     0x555555554a55 &lt;main()+113&gt;</span><br><span class="line">   0x0000555555554a50 &lt;+108&gt;:	call   0x555555554840 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">   0x0000555555554a55 &lt;+113&gt;:	leave  </span><br><span class="line">   0x0000555555554a56 &lt;+114&gt;:	ret    </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<h4 id="引用初始化赋值"><a href="#引用初始化赋值" class="headerlink" title="引用初始化赋值"></a>引用初始化赋值</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0000555555554a02 &lt;+30&gt;:	lea    rax,[rbp-0x14]</span><br><span class="line">0x0000555555554a06 &lt;+34&gt;:	mov    QWORD PTR [rbp-0x10],rax</span><br><span class="line">对比指针赋值可以看出引用的赋值和指针的赋值是相同的方法</span><br></pre></td></tr></table></figure>

<h4 id="函数返回值-1"><a href="#函数返回值-1" class="headerlink" title="函数返回值"></a>函数返回值</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   mac函数汇编</span><br><span class="line">   Dump of assembler code for function mac():</span><br><span class="line">   0x000055555555498a &lt;+0&gt;:	push   rbp</span><br><span class="line">   0x000055555555498b &lt;+1&gt;:	mov    rbp,rsp</span><br><span class="line">   0x000055555555498e &lt;+4&gt;:	sub    rsp,0x10</span><br><span class="line">   0x0000555555554992 &lt;+8&gt;:	mov    edi,0x4</span><br><span class="line">   0x0000555555554997 &lt;+13&gt;:	call   0x555555554820 &lt;_Znwm@plt&gt;</span><br><span class="line">   0x000055555555499c &lt;+18&gt;:	mov    DWORD PTR [rax],0xa</span><br><span class="line">   0x00005555555549a2 &lt;+24&gt;:	mov    QWORD PTR [rbp-0x8],rax</span><br><span class="line">   0x00005555555549a6 &lt;+28&gt;:	mov    rax,QWORD PTR [rbp-0x8]&#x2F;&#x2F;将变量地址存入rax作为函数返回值</span><br><span class="line">&#x3D;&gt; 0x00005555555549aa &lt;+32&gt;:	leave  </span><br><span class="line">   0x00005555555549ab &lt;+33&gt;:	ret    </span><br><span class="line">End of assembler dump.</span><br><span class="line">   </span><br><span class="line">   0x0000555555554a0a &lt;+38&gt;:	call   0x55555555498a &lt;mac()&gt;</span><br><span class="line">   0x0000555555554a0f &lt;+43&gt;:	mov    edx,DWORD PTR [rax]&#x2F;&#x2F;取出rax中地址空间的值</span><br><span class="line">   0x0000555555554a11 &lt;+45&gt;:	mov    rax,QWORD PTR [rbp-0x10]&#x2F;&#x2F;将p引用中保存的值取出，该值为变量i的地址</span><br><span class="line">   (gdb) info registers eax</span><br><span class="line">	eax            0xffffddcc	-8756</span><br><span class="line">	(gdb) p $rbp-0x14</span><br><span class="line">	$3 &#x3D; (void *) 0x7fffffffddcc</span><br><span class="line">   0x0000555555554a15 &lt;+49&gt;:	mov    DWORD PTR [rax],edx&#x2F;&#x2F;赋值给变量i</span><br><span class="line">   和指针相对比可得:指针是直接改变其保存的变量地址，引用是通过保存的变量地址给被引用的变量赋值</span><br></pre></td></tr></table></figure>

<h4 id="另外一种函数返回值"><a href="#另外一种函数返回值" class="headerlink" title="另外一种函数返回值"></a>另外一种函数返回值</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">函数原型</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int num;</span><br><span class="line">int&amp;  mac()</span><br><span class="line">&#123;</span><br><span class="line">	num&#x3D;10;</span><br><span class="line">	return num;</span><br><span class="line">	#不能返回栈中元素的引用，因为函数调用结束后栈空间会释放，此处只是举例</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int i&#x3D; 10;</span><br><span class="line">	int &amp;p&#x3D;i;</span><br><span class="line">	p&#x3D;mac();</span><br><span class="line">	cout&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">汇编</span><br><span class="line">Dump of assembler code for function main():</span><br><span class="line">   0x0000555555554911 &lt;+0&gt;:	push   rbp</span><br><span class="line">   0x0000555555554912 &lt;+1&gt;:	mov    rbp,rsp</span><br><span class="line">   0x0000555555554915 &lt;+4&gt;:	sub    rsp,0x20</span><br><span class="line">   0x0000555555554919 &lt;+8&gt;:	mov    rax,QWORD PTR fs:0x28</span><br><span class="line">   0x0000555555554922 &lt;+17&gt;:	mov    QWORD PTR [rbp-0x8],rax</span><br><span class="line">   0x0000555555554926 &lt;+21&gt;:	xor    eax,eax</span><br><span class="line">&#x3D;&gt; 0x0000555555554928 &lt;+23&gt;:	mov    DWORD PTR [rbp-0x14],0xa</span><br><span class="line">   0x000055555555492f &lt;+30&gt;:	lea    rax,[rbp-0x14]</span><br><span class="line">   0x0000555555554933 &lt;+34&gt;:	mov    QWORD PTR [rbp-0x10],rax</span><br><span class="line">   0x0000555555554937 &lt;+38&gt;:	call   0x5555555548fa &lt;mac()&gt;</span><br><span class="line">   0x000055555555493c &lt;+43&gt;:	mov    edx,DWORD PTR [rax]</span><br><span class="line">   0x000055555555493e &lt;+45&gt;:	mov    rax,QWORD PTR [rbp-0x10]</span><br><span class="line">   0x0000555555554942 &lt;+49&gt;:	mov    DWORD PTR [rax],edx</span><br><span class="line">   0x0000555555554944 &lt;+51&gt;:	mov    eax,DWORD PTR [rbp-0x14]</span><br><span class="line">   0x0000555555554947 &lt;+54&gt;:	mov    esi,eax</span><br><span class="line">   0x0000555555554949 &lt;+56&gt;:	lea    rdi,[rip+0x2006d0]        # 0x555555755020 &lt;_ZSt4cout@@GLIBCXX_3.4&gt;</span><br><span class="line">   0x0000555555554950 &lt;+63&gt;:	call   0x5555555547d0 &lt;_ZNSolsEi@plt&gt;</span><br><span class="line">   0x0000555555554955 &lt;+68&gt;:	mov    rdx,rax</span><br><span class="line">   0x0000555555554958 &lt;+71&gt;:	mov    rax,QWORD PTR [rip+0x200671]        # 0x555555754fd0</span><br><span class="line">   0x000055555555495f &lt;+78&gt;:	mov    rsi,rax</span><br><span class="line">   0x0000555555554962 &lt;+81&gt;:	mov    rdi,rdx</span><br><span class="line">   0x0000555555554965 &lt;+84&gt;:	call   0x5555555547a0 &lt;_ZNSolsEPFRSoS_E@plt&gt;</span><br><span class="line">   0x000055555555496a &lt;+89&gt;:	mov    eax,0x0</span><br><span class="line">   0x000055555555496f &lt;+94&gt;:	mov    rcx,QWORD PTR [rbp-0x8]</span><br><span class="line">   0x0000555555554973 &lt;+98&gt;:	xor    rcx,QWORD PTR fs:0x28</span><br><span class="line">   0x000055555555497c &lt;+107&gt;:	je     0x555555554983 &lt;main()+114&gt;</span><br><span class="line">   0x000055555555497e &lt;+109&gt;:	call   0x5555555547b0 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">   0x0000555555554983 &lt;+114&gt;:	leave  </span><br><span class="line">   0x0000555555554984 &lt;+115&gt;:	ret    </span><br><span class="line">End of assembler dump.</span><br><span class="line"></span><br><span class="line">Dump of assembler code for function mac():</span><br><span class="line">   0x00005555555548fa &lt;+0&gt;:	push   rbp</span><br><span class="line">   0x00005555555548fb &lt;+1&gt;:	mov    rbp,rsp</span><br><span class="line">   0x00005555555548fe &lt;+4&gt;:	mov    DWORD PTR [rip+0x20082c],0xe        # 0x555555755134 &lt;num&gt;</span><br><span class="line">   0x0000555555554908 &lt;+14&gt;:	lea    rax,[rip+0x200825]        # 0x555555755134 &lt;num&gt;</span><br><span class="line">   0x000055555555490f &lt;+21&gt;:	pop    rbp</span><br><span class="line">   0x0000555555554910 &lt;+22&gt;:	ret    </span><br><span class="line">End of assembler dump.</span><br><span class="line"></span><br><span class="line"> 0x0000555555554908 &lt;+14&gt;:	lea    rax,[rip+0x200825]        # 0x555555755134 &lt;num&gt;</span><br><span class="line"> 和之前相同同样是将地址放入rax中为后进行相同的操作</span><br></pre></td></tr></table></figure>

<h4 id="函数参数-1"><a href="#函数参数-1" class="headerlink" title="函数参数"></a>函数参数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0000555555554a17 &lt;+51&gt;:	mov    rax,QWORD PTR [rbp-0x10]</span><br><span class="line">0x0000555555554a1b &lt;+55&gt;:	mov    rdi,rax</span><br><span class="line">0x0000555555554a1e &lt;+58&gt;:	call   0x5555555549ac &lt;macp(int&amp;)&gt;</span><br><span class="line">对比可发现引用直接用其保存的地址将值取出，没有将地址取出保存至寄存器，而后利用寄存器取出值，即没有解引用这    一步</span><br></pre></td></tr></table></figure>

<h3 id="自增等操作"><a href="#自增等操作" class="headerlink" title="自增等操作"></a>自增等操作</h3><p>引用是弱化的指针，有很多相似的地方，不同的是当指针进行++操作时改变的是其保存的地址值，而引用则要通过地址寻找被引用的变量并改边其值</p>
<h4 id="例如"><a href="#例如" class="headerlink" title="例如"></a>例如</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int i&#x3D;10;</span><br><span class="line">	int *p&#x3D;&amp;i;</span><br><span class="line">	int &amp;pp&#x3D;i;</span><br><span class="line">	p++;</span><br><span class="line">	pp++;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dump of assembler code for function main():</span><br><span class="line">   0x00005555555547aa &lt;+0&gt;:	push   rbp</span><br><span class="line">   0x00005555555547ab &lt;+1&gt;:	mov    rbp,rsp</span><br><span class="line">   0x00005555555547ae &lt;+4&gt;:	sub    rsp,0x20</span><br><span class="line">   0x00005555555547b2 &lt;+8&gt;:	mov    rax,QWORD PTR fs:0x28</span><br><span class="line">   0x00005555555547bb &lt;+17&gt;:	mov    QWORD PTR [rbp-0x8],rax</span><br><span class="line">   0x00005555555547bf &lt;+21&gt;:	xor    eax,eax</span><br><span class="line">   0x00005555555547c1 &lt;+23&gt;:	mov    DWORD PTR [rbp-0x1c],0xa</span><br><span class="line">   0x00005555555547c8 &lt;+30&gt;:	lea    rax,[rbp-0x1c]</span><br><span class="line">   0x00005555555547cc &lt;+34&gt;:	mov    QWORD PTR [rbp-0x18],rax</span><br><span class="line">   0x00005555555547d0 &lt;+38&gt;:	lea    rax,[rbp-0x1c]</span><br><span class="line">   0x00005555555547d4 &lt;+42&gt;:	mov    QWORD PTR [rbp-0x10],rax</span><br><span class="line">   0x00005555555547d8 &lt;+46&gt;:	add    QWORD PTR [rbp-0x18],0x4</span><br><span class="line">   0x00005555555547dd &lt;+51&gt;:	mov    rax,QWORD PTR [rbp-0x10]</span><br><span class="line">   0x00005555555547e1 &lt;+55&gt;:	mov    eax,DWORD PTR [rax]</span><br><span class="line">   0x00005555555547e3 &lt;+57&gt;:	lea    edx,[rax+0x1]</span><br><span class="line">   0x00005555555547e6 &lt;+60&gt;:	mov    rax,QWORD PTR [rbp-0x10]</span><br><span class="line">   0x00005555555547ea &lt;+64&gt;:	mov    DWORD PTR [rax],edx</span><br><span class="line">   0x00005555555547ec &lt;+66&gt;:	mov    eax,0x0</span><br><span class="line">   0x00005555555547f1 &lt;+71&gt;:	mov    rcx,QWORD PTR [rbp-0x8]</span><br><span class="line">   0x00005555555547f5 &lt;+75&gt;:	xor    rcx,QWORD PTR fs:0x28</span><br><span class="line">   0x00005555555547fe &lt;+84&gt;:	je     0x555555554805 &lt;main()+91&gt;</span><br><span class="line">   0x0000555555554800 &lt;+86&gt;:	call   0x555555554670 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">   0x0000555555554805 &lt;+91&gt;:	leave  </span><br><span class="line">   0x0000555555554806 &lt;+92&gt;:	ret    </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<h4 id="指针-1"><a href="#指针-1" class="headerlink" title="指针++"></a>指针++</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 0x00005555555547d8 &lt;+46&gt;:	add    QWORD PTR [rbp-0x18],0x4</span><br><span class="line">直接改变其保存的地址值，进行+4操作</span><br></pre></td></tr></table></figure>

<h4 id="引用-1"><a href="#引用-1" class="headerlink" title="引用++"></a>引用++</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x00005555555547dd &lt;+51&gt;:	mov    rax,QWORD PTR [rbp-0x10]</span><br><span class="line">0x00005555555547e1 &lt;+55&gt;:	mov    eax,DWORD PTR [rax]</span><br><span class="line">0x00005555555547e3 &lt;+57&gt;:	lea    edx,[rax+0x1]&#x2F;&#x2F;这里edx等于11</span><br><span class="line">0x00005555555547e6 &lt;+60&gt;:	mov    rax,QWORD PTR [rbp-0x10] &#x2F;&#x2F;取回i的地址</span><br><span class="line">0x00005555555547ea &lt;+64&gt;:	mov    DWORD PTR [rax],edx&#x2F;&#x2F;赋值</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>FlamingoServer开源代码阅读--base目录</title>
    <url>/posts/4f56f208/</url>
    <content><![CDATA[<h4 id="项目代码地址-https-github-com-balloonwj-flamingo"><a href="#项目代码地址-https-github-com-balloonwj-flamingo" class="headerlink" title="项目代码地址:https://github.com/balloonwj/flamingo"></a>项目代码地址:<a href="https://github.com/balloonwj/flamingo">https://github.com/balloonwj/flamingo</a></h4><a id="more"></a>

<h3 id="异步日志类"><a href="#异步日志类" class="headerlink" title="异步日志类"></a>异步日志类</h3><p>同步日志：写入日志的线程和当前运行线程相同</p>
<p>异步日志：单独的日志写入线程，效率更高</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @desc:   异步日志类，AsyncLog.h</span></span><br><span class="line"><span class="comment"> * @author: zhangyl</span></span><br><span class="line"><span class="comment"> * @date:   2019.04.13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __ASYNC_LOG_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __ASYNC_LOG_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_API</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> LOG_LEVEL</span><br><span class="line">&#123;</span><br><span class="line">    LOG_LEVEL_TRACE,</span><br><span class="line">    LOG_LEVEL_DEBUG,</span><br><span class="line">    LOG_LEVEL_INFO,</span><br><span class="line">    LOG_LEVEL_WARNING,</span><br><span class="line">    LOG_LEVEL_ERROR,    <span class="comment">//用于业务错误</span></span><br><span class="line">    LOG_LEVEL_SYSERROR, <span class="comment">//用于技术框架本身的错误</span></span><br><span class="line">    LOG_LEVEL_FATAL,    <span class="comment">//FATAL 级别的日志会让在程序输出日志后退出</span></span><br><span class="line">    LOG_LEVEL_CRITICAL  <span class="comment">//CRITICAL 日志不受日志级别控制，总是输出</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGT(...)    CAsyncLog::output(LOG_LEVEL_TRACE, __FILE__, __LINE__, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGD(...)    CAsyncLog::output(LOG_LEVEL_DEBUG, __FILE__, __LINE__, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGI(...)    CAsyncLog::output(LOG_LEVEL_INFO, __FILE__, __LINE__, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGW(...)    CAsyncLog::output(LOG_LEVEL_WARNING, __FILE__, __LINE__,__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGE(...)    CAsyncLog::output(LOG_LEVEL_ERROR, __FILE__, __LINE__, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGSYSE(...) CAsyncLog::output(LOG_LEVEL_SYSERROR, __FILE__, __LINE__, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGF(...)    CAsyncLog::output(LOG_LEVEL_FATAL, __FILE__, __LINE__, __VA_ARGS__)        <span class="comment">//为了让FATAL级别的日志能立即crash程序，采取同步写日志的方法</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGC(...)    CAsyncLog::output(LOG_LEVEL_CRITICAL, __FILE__, __LINE__, __VA_ARGS__)     <span class="comment">//关键信息，无视日志级别，总是输出</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用于输出数据包的二进制格式</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_DEBUG_BIN(buf, buflength) CAsyncLog::outputBinary(buf, buflength)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LOG_API</span> <span class="title">CAsyncLog</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pszLogFileName = <span class="literal">nullptr</span>, <span class="keyword">bool</span> bTruncateLongLine = <span class="literal">false</span>, <span class="keyword">int64_t</span> nRollSize = <span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">uninit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setLevel</span><span class="params">(LOG_LEVEL nLevel)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">isRunning</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不输出线程ID号和所在函数签名、行号</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">output</span><span class="params">(<span class="keyword">long</span> nLevel, <span class="keyword">const</span> <span class="keyword">char</span>* pszFmt, ...)</span></span>;</span><br><span class="line">    <span class="comment">//输出线程ID号和所在函数签名、行号</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">output</span><span class="params">(<span class="keyword">long</span> nLevel, <span class="keyword">const</span> <span class="keyword">char</span>* pszFileName, <span class="keyword">int</span> nLineNo, <span class="keyword">const</span> <span class="keyword">char</span>* pszFmt, ...)</span></span>;</span><br><span class="line">    <span class="comment">//二进制写日志</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">outputBinary</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>* buffer, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    CAsyncLog() = <span class="keyword">delete</span>;</span><br><span class="line">    ~CAsyncLog() = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    CAsyncLog(<span class="keyword">const</span> CAsyncLog&amp; rhs) = <span class="keyword">delete</span>;</span><br><span class="line">    CAsyncLog&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> CAsyncLog&amp; rhs) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">makeLinePrefix</span><span class="params">(<span class="keyword">long</span> nLevel, <span class="built_in">std</span>::<span class="built_in">string</span>&amp; strPrefix)</span></span>;<span class="comment">//构造日志前缀：日志等级，时间，当前线程、进程信息</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getTime</span><span class="params">(<span class="keyword">char</span>* pszTime, <span class="keyword">int</span> nTimeStrLength)</span></span>;<span class="comment">//获取当前时间</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">createNewFile</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pszLogFileName)</span></span>;<span class="comment">//创建一个新的日志文件</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">writeToFile</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; data)</span></span>;<span class="comment">//将一行日志写入文件</span></span><br><span class="line">    <span class="comment">//让程序主动崩溃</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">crash</span><span class="params">()</span></span>;<span class="comment">//构造段错误，导致程序崩溃</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">ullto4Str</span><span class="params">(<span class="keyword">int</span> n)</span></span>;<span class="comment">//将数字按照特定格式转化为字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">char</span>* <span class="title">formLog</span><span class="params">(<span class="keyword">int</span>&amp; index, <span class="keyword">char</span>* szbuf, <span class="keyword">size_t</span> size_buf, <span class="keyword">unsigned</span> <span class="keyword">char</span>* buffer, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeThreadProc</span><span class="params">()</span></span>;<span class="comment">//日志线程</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span>		                        m_bToFile;			    <span class="comment">//日志写入文件还是写到控制台</span></span><br><span class="line">    <span class="keyword">static</span> FILE*                            m_hLogFile;             <span class="comment">//日志文件名</span></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">string</span>                      m_strFileName;          <span class="comment">//磁盘日志文件名前缀</span></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">string</span>                      m_strFileNamePID;    <span class="comment">//文件名中的进程id</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span>                             m_bTruncateLongLog;     <span class="comment">//长日志是否截断</span></span><br><span class="line">    <span class="keyword">static</span> LOG_LEVEL                        m_nCurrentLevel;        <span class="comment">//当前日志级别</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int64_t</span>                          m_nFileRollSize;        <span class="comment">//单个日志文件的最大字节数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int64_t</span>                          m_nCurrentWrittenSize;  <span class="comment">//已经写入的字节数目</span></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;           m_listLinesToWrite;     <span class="comment">//待写入的日志</span></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="built_in">std</span>::thread&gt;     m_spWriteThread;        <span class="comment">//日志线程托管</span></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">std</span>::mutex                       m_mutexWrite;           <span class="comment">//锁</span></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">std</span>::condition_variable          m_cvWrite;              <span class="comment">//条件变量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span>                             m_bExit;                <span class="comment">//退出标志</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span>                             m_bRunning;             <span class="comment">//运行标志</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_LINE_LENGTH   256</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFAULT_ROLL_SIZE 10 * 1024 * 1024</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> CAsyncLog::m_bTruncateLongLog = <span class="literal">false</span>;</span><br><span class="line">FILE* CAsyncLog::m_hLogFile = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> CAsyncLog::m_strFileName = <span class="string">&quot;default&quot;</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> CAsyncLog::m_strFileNamePID = <span class="string">&quot;&quot;</span>;</span><br><span class="line">LOG_LEVEL CAsyncLog::m_nCurrentLevel = LOG_LEVEL_INFO;</span><br><span class="line"><span class="keyword">int64_t</span> CAsyncLog::m_nFileRollSize = DEFAULT_ROLL_SIZE;</span><br><span class="line"><span class="keyword">int64_t</span> CAsyncLog::m_nCurrentWrittenSize = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; CAsyncLog::m_listLinesToWrite;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="built_in">std</span>::thread&gt; CAsyncLog::m_spWriteThread;</span><br><span class="line"><span class="built_in">std</span>::mutex CAsyncLog::m_mutexWrite;</span><br><span class="line"><span class="built_in">std</span>::condition_variable CAsyncLog::m_cvWrite;</span><br><span class="line"><span class="keyword">bool</span> CAsyncLog::CAsyncLog::m_bExit = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">bool</span> CAsyncLog::m_bRunning = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// !__ASYNC_LOG_H__</span></span></span><br></pre></td></tr></table></figure>

<h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">	CAsyncLog::init(<span class="string">&quot;log&quot;</span>);</span><br><span class="line">    LOGI(<span class="string">&quot;main&quot;</span>);</span><br><span class="line">    CAsyncLog::uninit();</span><br><span class="line">调用流程：</span><br><span class="line">    调用init函数初始化=&gt;output进行日志输出=&gt;output调用makeLinePrefix构造日志头=&gt;output处理可变参数列表=&gt;将数     据放入待打印队列=&gt;唤醒日志打印线程=&gt;打印并写入日志=&gt;线程阻塞等待唤醒=&gt;uninit回收释放资源</span><br></pre></td></tr></table></figure>

<h4 id="init"><a href="#init" class="headerlink" title="init"></a>init</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化设置 m_bTruncateLongLog(长日志是否截断)为false</span></span><br><span class="line"><span class="comment"> *  m_nFileRollSize(单个日志文件的最大字节数)为DEFAULT_ROLL_SIZE 10 * 1024 * 1024</span></span><br><span class="line"><span class="comment"> * m_strFileName(磁盘日志文件名前缀)</span></span><br><span class="line"><span class="comment"> * m_strFileNamePID(当前进程id)</span></span><br><span class="line"><span class="comment"> * 并开启打印日志线程</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CAsyncLog::init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pszLogFileName<span class="comment">/* = nullptr*/</span>, <span class="keyword">bool</span> bTruncateLongLine<span class="comment">/* = false*/</span>, <span class="keyword">int64_t</span> nRollSize<span class="comment">/* = 10 * 1024 * 1024*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_bTruncateLongLog = bTruncateLongLine;</span><br><span class="line">    m_nFileRollSize = nRollSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pszLogFileName == <span class="literal">nullptr</span> || pszLogFileName[<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_strFileName.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        m_strFileName = pszLogFileName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取进程id，这样快速看到同一个进程的不同日志文件</span></span><br><span class="line">    <span class="keyword">char</span> szPID[<span class="number">8</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> WIN32</span></span><br><span class="line">    <span class="built_in">snprintf</span>(szPID, <span class="keyword">sizeof</span>(szPID), <span class="string">&quot;%05d&quot;</span>, (<span class="keyword">int</span>)::GetCurrentProcessId());</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="built_in">snprintf</span>(szPID, <span class="keyword">sizeof</span>(szPID), <span class="string">&quot;%05d&quot;</span>, (<span class="keyword">int</span>)::getpid());</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    m_strFileNamePID = szPID;</span><br><span class="line"></span><br><span class="line">    m_spWriteThread.reset(<span class="keyword">new</span> <span class="built_in">std</span>::thread(writeThreadProc));<span class="comment">//创建线程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="uninit"><a href="#uninit" class="headerlink" title="uninit"></a>uninit</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CAsyncLog::uninit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_bExit = <span class="literal">true</span>;<span class="comment">//设置退出标志位</span></span><br><span class="line"></span><br><span class="line">    m_cvWrite.notify_one();<span class="comment">//唤醒线程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m_spWriteThread-&gt;joinable())<span class="comment">//等待线程将任务队列打印完成结束</span></span><br><span class="line">        m_spWriteThread-&gt;join();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(m_hLogFile != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fclose(m_hLogFile);</span><br><span class="line">        m_hLogFile = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="setLevel"><a href="#setLevel" class="headerlink" title="setLevel"></a>setLevel</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CAsyncLog::setLevel</span><span class="params">(LOG_LEVEL nLevel)</span><span class="comment">//设置当前日志打印级别</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nLevel &lt; LOG_LEVEL_TRACE || nLevel &gt; LOG_LEVEL_FATAL)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    m_nCurrentLevel = nLevel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="isRunning"><a href="#isRunning" class="headerlink" title="isRunning"></a>isRunning</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CAsyncLog::isRunning</span><span class="params">()</span><span class="comment">//判断日志打印线程是否正在运行</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_bRunning;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="output"><a href="#output" class="headerlink" title="output"></a>output</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不输出线程ID号和所在函数签名、行号</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CAsyncLog::output</span><span class="params">(<span class="keyword">long</span> nLevel, <span class="keyword">const</span> <span class="keyword">char</span>* pszFmt, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nLevel != LOG_LEVEL_CRITICAL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nLevel &lt; m_nCurrentLevel)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> strLine;</span><br><span class="line">    makeLinePrefix(nLevel, strLine);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//log正文</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> strLogMsg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先计算一下不定参数的长度，以便于分配空间</span></span><br><span class="line">    va_list ap;</span><br><span class="line">    va_start(ap, pszFmt);</span><br><span class="line">    <span class="keyword">int</span> nLogMsgLength = vsnprintf(<span class="literal">NULL</span>, <span class="number">0</span>, pszFmt, ap);</span><br><span class="line">    va_end(ap);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//容量必须算上最后一个\0</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">int</span>)strLogMsg.capacity() &lt; nLogMsgLength + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        strLogMsg.resize(nLogMsgLength + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    va_list aq;</span><br><span class="line">    va_start(aq, pszFmt);</span><br><span class="line">    vsnprintf((<span class="keyword">char</span>*)strLogMsg.data(), strLogMsg.capacity(), pszFmt, aq);</span><br><span class="line">    va_end(aq);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//string内容正确但length不对，恢复一下其length,此时其length为0,无法输出</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> strMsgFormal;</span><br><span class="line">    strMsgFormal.append(strLogMsg.c_str(), nLogMsgLength);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果日志开启截断，长日志只取前MAX_LINE_LENGTH个字符</span></span><br><span class="line">    <span class="keyword">if</span> (m_bTruncateLongLog)</span><br><span class="line">        strMsgFormal = strMsgFormal.substr(<span class="number">0</span>, MAX_LINE_LENGTH);</span><br><span class="line"></span><br><span class="line">    strLine += strMsgFormal;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不是输出到控制台才会在每一行末尾加一个换行符</span></span><br><span class="line">    <span class="keyword">if</span> (!m_strFileName.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        strLine += <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nLevel != LOG_LEVEL_FATAL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock_guard</span><span class="params">(m_mutexWrite)</span></span>;</span><br><span class="line">        m_listLinesToWrite.push_back(strLine);</span><br><span class="line">        m_cvWrite.notify_one();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//为了让FATAL级别的日志能立即crash程序，采取同步写日志的方法</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; strLine &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _WIN32</span></span><br><span class="line">        OutputDebugStringA(strLine.c_str());</span><br><span class="line">        OutputDebugStringA(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!m_strFileName.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (m_hLogFile == <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//新建文件,文件名格式为name.时间.pid.log</span></span><br><span class="line">                <span class="keyword">char</span> szNow[<span class="number">64</span>];</span><br><span class="line">                <span class="keyword">time_t</span> now = time(<span class="literal">NULL</span>);</span><br><span class="line">                tm time;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _WIN32</span></span><br><span class="line">                localtime_s(&amp;time, &amp;now);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">                localtime_r(&amp;now, &amp;time);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                strftime(szNow, <span class="keyword">sizeof</span>(szNow), <span class="string">&quot;%Y%m%d%H%M%S&quot;</span>, &amp;time);</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">strNewFileName</span><span class="params">(m_strFileName)</span></span>;</span><br><span class="line">                strNewFileName += <span class="string">&quot;.&quot;</span>;</span><br><span class="line">                strNewFileName += szNow;</span><br><span class="line">                strNewFileName += <span class="string">&quot;.&quot;</span>;</span><br><span class="line">                strNewFileName += m_strFileNamePID;</span><br><span class="line">                strNewFileName += <span class="string">&quot;.log&quot;</span>;</span><br><span class="line">                <span class="keyword">if</span> (!createNewFile(strNewFileName.c_str()))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="comment">// end inner if</span></span><br><span class="line"></span><br><span class="line">            writeToFile(strLine);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="comment">// end outer-if</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//让程序主动crash掉</span></span><br><span class="line">        crash();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出线程ID号和所在函数签名、行号</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CAsyncLog::output</span><span class="params">(<span class="keyword">long</span> nLevel, <span class="keyword">const</span> <span class="keyword">char</span>* pszFileName, <span class="keyword">int</span> nLineNo, <span class="keyword">const</span> <span class="keyword">char</span>* pszFmt, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nLevel != LOG_LEVEL_CRITICAL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nLevel &lt; m_nCurrentLevel)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> strLine;</span><br><span class="line">    makeLinePrefix(nLevel, strLine);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//函数签名</span></span><br><span class="line">    <span class="keyword">char</span> szFileName[<span class="number">512</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">snprintf</span>(szFileName, <span class="keyword">sizeof</span>(szFileName), <span class="string">&quot;[%s:%d]&quot;</span>, pszFileName, nLineNo);</span><br><span class="line">    strLine += szFileName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//日志正文</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> strLogMsg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先计算一下不定参数的长度，以便于分配空间</span></span><br><span class="line">    va_list ap;</span><br><span class="line">    va_start(ap, pszFmt);</span><br><span class="line">    <span class="keyword">int</span> nLogMsgLength = vsnprintf(<span class="literal">NULL</span>, <span class="number">0</span>, pszFmt, ap);</span><br><span class="line">    va_end(ap);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//容量必须算上最后一个\0</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">int</span>)strLogMsg.capacity() &lt; nLogMsgLength + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        strLogMsg.resize(nLogMsgLength + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    va_list aq;</span><br><span class="line">    va_start(aq, pszFmt);</span><br><span class="line">    vsnprintf((<span class="keyword">char</span>*)strLogMsg.data(), strLogMsg.capacity(), pszFmt, aq);</span><br><span class="line">    va_end(aq);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//string内容正确但length不对，恢复一下其length</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> strMsgFormal;</span><br><span class="line">    strMsgFormal.append(strLogMsg.c_str(), nLogMsgLength);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果日志开启截断，长日志只取前MAX_LINE_LENGTH个字符</span></span><br><span class="line">    <span class="keyword">if</span> (m_bTruncateLongLog)</span><br><span class="line">        strMsgFormal = strMsgFormal.substr(<span class="number">0</span>, MAX_LINE_LENGTH);</span><br><span class="line"></span><br><span class="line">    strLine += strMsgFormal;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不是输出到控制台才会在每一行末尾加一个换行符</span></span><br><span class="line">    <span class="keyword">if</span> (!m_strFileName.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        strLine += <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nLevel != LOG_LEVEL_FATAL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock_guard</span><span class="params">(m_mutexWrite)</span></span>;</span><br><span class="line">        <span class="comment">/*m_mutexWrite 的类型是 std::mutex，在 guard 对象的构造函数中，会自动调用 m_mutexWrite.lock() 方法加锁，当该函数出了作用域后，调用 guard 对象时析构函数时会自动调用 m_mutexWrite.unlock() 方法解锁。*/</span></span><br><span class="line">        m_listLinesToWrite.push_back(strLine);</span><br><span class="line">        m_cvWrite.notify_one();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//为了让FATAL级别的日志能立即crash程序，采取同步写日志的方法</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; strLine &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _WIN32</span></span><br><span class="line">        OutputDebugStringA(strLine.c_str());</span><br><span class="line">        OutputDebugStringA(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!m_strFileName.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (m_hLogFile == <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//新建文件</span></span><br><span class="line">                <span class="keyword">char</span> szNow[<span class="number">64</span>];</span><br><span class="line">                <span class="keyword">time_t</span> now = time(<span class="literal">NULL</span>);</span><br><span class="line">                tm time;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _WIN32</span></span><br><span class="line">                localtime_s(&amp;time, &amp;now);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">                localtime_r(&amp;now, &amp;time);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                strftime(szNow, <span class="keyword">sizeof</span>(szNow), <span class="string">&quot;%Y%m%d%H%M%S&quot;</span>, &amp;time);</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">strNewFileName</span><span class="params">(m_strFileName)</span></span>;</span><br><span class="line">                strNewFileName += <span class="string">&quot;.&quot;</span>;</span><br><span class="line">                strNewFileName += szNow;</span><br><span class="line">                strNewFileName += <span class="string">&quot;.&quot;</span>;</span><br><span class="line">                strNewFileName += m_strFileNamePID;</span><br><span class="line">                strNewFileName += <span class="string">&quot;.log&quot;</span>;</span><br><span class="line">                <span class="keyword">if</span> (!createNewFile(strNewFileName.c_str()))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="comment">// end inner if</span></span><br><span class="line"></span><br><span class="line">            writeToFile(strLine);</span><br><span class="line">        &#125;<span class="comment">// end outer-if</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//让程序主动crash掉</span></span><br><span class="line">        crash();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二进制写日志,目前没有看懂</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CAsyncLog::outputBinary</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>* buffer, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//std::string strBinary;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">ostringstream</span> os;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> PRINTSIZE = <span class="number">512</span>;</span><br><span class="line">    <span class="keyword">char</span> szbuf[PRINTSIZE * <span class="number">3</span> + <span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> lsize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> lprintbufsize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    os &lt;&lt; <span class="string">&quot;address[&quot;</span> &lt;&lt; (<span class="keyword">long</span>)buffer &lt;&lt; <span class="string">&quot;] size[&quot;</span> &lt;&lt; size &lt;&lt; <span class="string">&quot;] \n&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(szbuf, <span class="number">0</span>, <span class="keyword">sizeof</span>(szbuf));</span><br><span class="line">        <span class="keyword">if</span> (size &gt; lsize)</span><br><span class="line">        &#123;</span><br><span class="line">            lprintbufsize = (size - lsize);</span><br><span class="line">            lprintbufsize = lprintbufsize &gt; PRINTSIZE ? PRINTSIZE : lprintbufsize;</span><br><span class="line">            formLog(index, szbuf, <span class="keyword">sizeof</span>(szbuf), buffer + lsize, lprintbufsize);</span><br><span class="line">            <span class="keyword">size_t</span> len = <span class="built_in">strlen</span>(szbuf);</span><br><span class="line">            os &lt;&lt; szbuf;</span><br><span class="line">            lsize += lprintbufsize;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock_guard</span><span class="params">(m_mutexWrite)</span></span>;</span><br><span class="line">    m_listLinesToWrite.push_back(os.str());</span><br><span class="line">    m_cvWrite.notify_one();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="makeLinePrefix"><a href="#makeLinePrefix" class="headerlink" title="makeLinePrefix"></a>makeLinePrefix</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造出[INFO][[2020-06-02 22:18:58:847]][140639504140096]的头=&gt;[级别][[当前时间]][线程id]</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CAsyncLog::makeLinePrefix</span><span class="params">(<span class="keyword">long</span> nLevel, <span class="built_in">std</span>::<span class="built_in">string</span>&amp; strPrefix)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//级别</span></span><br><span class="line">    strPrefix = <span class="string">&quot;[INFO]&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (nLevel == LOG_LEVEL_TRACE)</span><br><span class="line">        strPrefix = <span class="string">&quot;[TRACE]&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (nLevel == LOG_LEVEL_DEBUG)</span><br><span class="line">        strPrefix = <span class="string">&quot;[DEBUG]&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (nLevel == LOG_LEVEL_WARNING)</span><br><span class="line">        strPrefix = <span class="string">&quot;[WARN]&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (nLevel == LOG_LEVEL_ERROR)</span><br><span class="line">        strPrefix = <span class="string">&quot;[ERROR]&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (nLevel == LOG_LEVEL_SYSERROR)</span><br><span class="line">        strPrefix = <span class="string">&quot;[SYSE]&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (nLevel == LOG_LEVEL_FATAL)</span><br><span class="line">        strPrefix = <span class="string">&quot;[FATAL]&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (nLevel == LOG_LEVEL_CRITICAL)</span><br><span class="line">        strPrefix = <span class="string">&quot;[CRITICAL]&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//时间</span></span><br><span class="line">    <span class="keyword">char</span> szTime[<span class="number">64</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    getTime(szTime, <span class="keyword">sizeof</span>(szTime));<span class="comment">//设置问&quot;[时间]&quot;的格式</span></span><br><span class="line"></span><br><span class="line">    strPrefix += <span class="string">&quot;[&quot;</span>;</span><br><span class="line">    strPrefix += szTime;</span><br><span class="line">    strPrefix += <span class="string">&quot;]&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前线程信息</span></span><br><span class="line">    <span class="keyword">char</span> szThreadID[<span class="number">32</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">ostringstream</span> osThreadID;</span><br><span class="line">    osThreadID &lt;&lt; <span class="built_in">std</span>::this_thread::get_id();</span><br><span class="line">    <span class="built_in">snprintf</span>(szThreadID, <span class="keyword">sizeof</span>(szThreadID), <span class="string">&quot;[%s]&quot;</span>, osThreadID.str().c_str());</span><br><span class="line">    strPrefix += szThreadID;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="getTime"><a href="#getTime" class="headerlink" title="getTime"></a>getTime</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CAsyncLog::getTime</span><span class="params">(<span class="keyword">char</span>* pszTime, <span class="keyword">int</span> nTimeStrLength)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeb</span> <span class="title">tp</span>;</span></span><br><span class="line">    ftime(&amp;tp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">time_t</span> now = tp.time;</span><br><span class="line">    tm time;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _WIN32</span></span><br><span class="line">    localtime_s(&amp;time, &amp;now);<span class="comment">//线程安全函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    localtime_r(&amp;now, &amp;time);<span class="comment">//线程安全函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">snprintf</span>(pszTime, nTimeStrLength, <span class="string">&quot;[%04d-%02d-%02d %02d:%02d:%02d:%03d]&quot;</span>, time.tm_year + <span class="number">1900</span>, time.tm_mon + <span class="number">1</span>, time.tm_mday, time.tm_hour, time.tm_min, time.tm_sec, tp.millitm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="createNewFile"><a href="#createNewFile" class="headerlink" title="createNewFile"></a>createNewFile</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CAsyncLog::createNewFile</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pszLogFileName)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//创建文件</span></span><br><span class="line">    <span class="keyword">if</span> (m_hLogFile != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fclose(m_hLogFile);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//始终新建文件</span></span><br><span class="line">    m_hLogFile = fopen(pszLogFileName, <span class="string">&quot;w+&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> m_hLogFile != <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="createNewFile-1"><a href="#createNewFile-1" class="headerlink" title="createNewFile"></a>createNewFile</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CAsyncLog::writeToFile</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; data)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//写文件，一次写一行</span></span><br><span class="line">    <span class="comment">//为了防止长文件一次性写不完，放在一个循环里面分批写</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">strLocal</span><span class="params">(data)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ret = fwrite(strLocal.c_str(), <span class="number">1</span>, strLocal.length(), m_hLogFile);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ret &lt;= (<span class="keyword">int</span>)strLocal.length())</span><br><span class="line">        &#123;</span><br><span class="line">            strLocal.erase(<span class="number">0</span>, ret);<span class="comment">//将0-ret的字符删除，若没写完则继续写</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (strLocal.empty())</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fflush(m_hLogFile);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="crash"><a href="#crash" class="headerlink" title="crash"></a>crash</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CAsyncLog::crash</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//0地址赋值，产生段错误，程序崩溃</span></span><br><span class="line">    <span class="keyword">char</span>* p = <span class="literal">nullptr</span>;</span><br><span class="line">    *p = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ullto4Str"><a href="#ullto4Str" class="headerlink" title="ullto4Str"></a>ullto4Str</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">CAsyncLog::ullto4Str</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">64</span> + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%06u&quot;</span>, n);<span class="comment">//如30=》000030</span></span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="formLog"><a href="#formLog" class="headerlink" title="formLog"></a>formLog</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//目前未看懂</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">CAsyncLog::formLog</span><span class="params">(<span class="keyword">int</span>&amp; index, <span class="keyword">char</span>* szbuf, <span class="keyword">size_t</span> size_buf, <span class="keyword">unsigned</span> <span class="keyword">char</span>* buffer, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> lsize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> headlen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> szhead[<span class="number">64</span> + <span class="number">1</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">char</span> szchar[<span class="number">17</span>] = <span class="string">&quot;0123456789abcdef&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (size &gt; lsize &amp;&amp; len + <span class="number">10</span> &lt; size_buf)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (lsize % <span class="number">32</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> != headlen)</span><br><span class="line">            &#123;</span><br><span class="line">                szbuf[len++] = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">memset</span>(szhead, <span class="number">0</span>, <span class="keyword">sizeof</span>(szhead));</span><br><span class="line">            <span class="built_in">strncpy</span>(szhead, ullto4Str(index++), <span class="keyword">sizeof</span>(szhead) - <span class="number">1</span>);</span><br><span class="line">            headlen = <span class="built_in">strlen</span>(szhead);</span><br><span class="line">            szhead[headlen++] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">strcat</span>(szbuf, szhead);</span><br><span class="line">            len += headlen;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (lsize % <span class="number">16</span> == <span class="number">0</span> &amp;&amp; <span class="number">0</span> != headlen)</span><br><span class="line">            szbuf[len++] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        szbuf[len++] = szchar[(buffer[lsize] &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0xf</span>];</span><br><span class="line">        szbuf[len++] = szchar[(buffer[lsize]) &amp; <span class="number">0xf</span>];</span><br><span class="line">        lsize++;</span><br><span class="line">    &#125;</span><br><span class="line">    szbuf[len++] = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    szbuf[len++] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> szbuf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="writeThreadProc"><a href="#writeThreadProc" class="headerlink" title="writeThreadProc"></a>writeThreadProc</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//日志打印线程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CAsyncLog::writeThreadProc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_bRunning = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!m_strFileName.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (m_hLogFile == <span class="literal">nullptr</span> || m_nCurrentWrittenSize &gt;= m_nFileRollSize)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//重置m_nCurrentWrittenSize大小</span></span><br><span class="line">                m_nCurrentWrittenSize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//第一次或者文件大小超过rollsize，均新建文件</span></span><br><span class="line">                <span class="keyword">char</span> szNow[<span class="number">64</span>];</span><br><span class="line">                <span class="keyword">time_t</span> now = time(<span class="literal">NULL</span>);</span><br><span class="line">                tm time;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _WIN32</span></span><br><span class="line">                localtime_s(&amp;time, &amp;now);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">                localtime_r(&amp;now, &amp;time);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                strftime(szNow, <span class="keyword">sizeof</span>(szNow), <span class="string">&quot;%Y%m%d%H%M%S&quot;</span>, &amp;time);</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">strNewFileName</span><span class="params">(m_strFileName)</span></span>;</span><br><span class="line">                strNewFileName += <span class="string">&quot;.&quot;</span>;</span><br><span class="line">                strNewFileName += szNow;</span><br><span class="line">                strNewFileName += <span class="string">&quot;.&quot;</span>;</span><br><span class="line">                strNewFileName += m_strFileNamePID;</span><br><span class="line">                strNewFileName += <span class="string">&quot;.log&quot;</span>;</span><br><span class="line">                <span class="keyword">if</span> (!createNewFile(strNewFileName.c_str()))</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">            &#125;<span class="comment">// end inner if</span></span><br><span class="line">        &#125;<span class="comment">// end outer-if</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> strLine;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">guard</span><span class="params">(m_mutexWrite)</span></span>;<span class="comment">//加锁</span></span><br><span class="line">            <span class="keyword">while</span> (m_listLinesToWrite.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (m_bExit)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">                m_cvWrite.wait(guard);<span class="comment">//原子地释放 guard ，阻塞当前执行线程，即调用m_mutexWrite.unlock()</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            strLine = m_listLinesToWrite.front();</span><br><span class="line">            m_listLinesToWrite.pop_front();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; strLine &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _WIN32</span></span><br><span class="line">        OutputDebugStringA(strLine.c_str());</span><br><span class="line">        OutputDebugStringA(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!m_strFileName.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!writeToFile(strLine))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            m_nCurrentWrittenSize += strLine.length();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">// end outer-while-loop</span></span><br><span class="line"></span><br><span class="line">    m_bRunning = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="配置文件读取类"><a href="#配置文件读取类" class="headerlink" title="配置文件读取类"></a>配置文件读取类</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> *  简单的配置文件读取类，ConfigFileReader.h</span></span><br><span class="line"><span class="comment"> *  zhangyl 2017.05.27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __CONFIG_FILE_READER_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __CONFIG_FILE_READER_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CConfigFileReader</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	CConfigFileReader(<span class="keyword">const</span> <span class="keyword">char</span>* filename);</span><br><span class="line">	~CConfigFileReader();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">char</span>* <span class="title">getConfigName</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name)</span></span>;<span class="comment">//获取配置名为name的变量值</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">setConfigValue</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">const</span> <span class="keyword">char</span>*  value)</span></span>;<span class="comment">//设置变量名为name的变量，值为value</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span>  <span class="title">loadFile</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* filename)</span></span>;<span class="comment">//加载文件</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span>   <span class="title">writeFile</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* filename = <span class="literal">NULL</span>)</span></span>;<span class="comment">//写配置文件</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span>  <span class="title">parseLine</span><span class="params">(<span class="keyword">char</span>* line)</span></span>;<span class="comment">//处理行</span></span><br><span class="line">    <span class="function"><span class="keyword">char</span>* <span class="title">trimSpace</span><span class="params">(<span class="keyword">char</span>* name)</span></span>;<span class="comment">//去掉空格</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span>                                m_load_ok;<span class="comment">//判断文件是否加载成功</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;  m_config_map;<span class="comment">//配置项kay-value</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span>                         m_config_file;<span class="comment">//保存配置文件名</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//!__CONFIG_FILE_READER_H__</span></span></span><br></pre></td></tr></table></figure>

<h4 id="大致执行流程"><a href="#大致执行流程" class="headerlink" title="大致执行流程"></a>大致执行流程</h4><p>CConfigFileReader类传入文件名构造=&gt;构造函数调用loadFile加载文件=&gt;loadFile函数提取行而后将提取结果交给=&gt;parseLine调用trimSpace等函数处理单行并提出出配置</p>
<h4 id="CConfigFileReader构造函数"><a href="#CConfigFileReader构造函数" class="headerlink" title="CConfigFileReader构造函数"></a>CConfigFileReader构造函数</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">CConfigFileReader::CConfigFileReader(<span class="keyword">const</span> <span class="keyword">char</span>* filename)</span><br><span class="line">&#123;</span><br><span class="line">    loadFile(filename);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="loadFile"><a href="#loadFile" class="headerlink" title="loadFile"></a>loadFile</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CConfigFileReader::loadFile</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* filename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_config_file.clear();</span><br><span class="line">    m_config_file.append(filename);<span class="comment">//初始化m_config_file成员变量保存文件名以供后续调用</span></span><br><span class="line">    FILE* fp = fopen(filename, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!fp)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span>* p = fgets(buf, <span class="number">256</span>, fp);</span><br><span class="line">        <span class="keyword">if</span> (!p)<span class="comment">//循环跳出标志，文件到达，末尾fgets返回NULL,跳出循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">size_t</span> len = <span class="built_in">strlen</span>(buf);</span><br><span class="line">        <span class="keyword">if</span> (buf[len - <span class="number">1</span>] == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            buf[len - <span class="number">1</span>] = <span class="number">0</span>;			<span class="comment">//去除末尾的\n</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>* ch = <span class="built_in">strchr</span>(buf, <span class="string">&#x27;#&#x27;</span>);	<span class="comment">// 去除#开头的注释行，如果第一个字符为#跳过当前行，重新进行循环</span></span><br><span class="line">        <span class="keyword">if</span> (ch)</span><br><span class="line">            *ch = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strlen</span>(buf) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        parseLine(buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fclose(fp);</span><br><span class="line">    m_load_ok = <span class="literal">true</span>;<span class="comment">//加载文件成功，设置成功位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="parseLine"><a href="#parseLine" class="headerlink" title="parseLine"></a>parseLine</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CConfigFileReader::parseLine</span><span class="params">(<span class="keyword">char</span>* line)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* p = <span class="built_in">strchr</span>(line, <span class="string">&#x27;=&#x27;</span>);<span class="comment">//设置p为=号后一个字符</span></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    *p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span>* key =  trimSpace(line);</span><br><span class="line">    <span class="keyword">char</span>* value = trimSpace(p + <span class="number">1</span>);<span class="comment">//去除空格等字符</span></span><br><span class="line">    <span class="keyword">if</span> (key &amp;&amp; value)<span class="comment">//如果key和value有效则插入map中</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_config_map.insert(<span class="built_in">std</span>::<span class="built_in">make_pair</span>(key, value));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="trimSpace"><a href="#trimSpace" class="headerlink" title="trimSpace"></a>trimSpace</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">CConfigFileReader::trimSpace</span><span class="params">(<span class="keyword">char</span>* name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//去除行开始的空格等字符</span></span><br><span class="line">    <span class="keyword">char</span>* start_pos = name;</span><br><span class="line">    <span class="keyword">while</span> ( (*start_pos == <span class="string">&#x27; &#x27;</span>) || (*start_pos == <span class="string">&#x27;\t&#x27;</span>) || (*start_pos == <span class="string">&#x27;\r&#x27;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        start_pos++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(start_pos) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去除行尾的空格等字符</span></span><br><span class="line">    <span class="keyword">char</span>* end_pos = name + <span class="built_in">strlen</span>(name) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> ( (*end_pos == <span class="string">&#x27; &#x27;</span>) || (*end_pos == <span class="string">&#x27;\t&#x27;</span>) || (*end_pos == <span class="string">&#x27;\r&#x27;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        *end_pos = <span class="number">0</span>;</span><br><span class="line">        end_pos--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> len = (<span class="keyword">int</span>)(end_pos - start_pos) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> start_pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="writeFile"><a href="#writeFile" class="headerlink" title="writeFile"></a>writeFile</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CConfigFileReader::writeFile</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* filename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE* fp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(filename == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fp = fopen(m_config_file.c_str(), <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        fp = fopen(filename, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> szPaire[<span class="number">128</span>];</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;::iterator it = m_config_map.begin();</span><br><span class="line">    <span class="keyword">for</span> (; it != m_config_map.end(); it++)<span class="comment">//遍历map组包写入配置文件</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(szPaire, <span class="number">0</span>, <span class="keyword">sizeof</span>(szPaire));</span><br><span class="line">        <span class="built_in">snprintf</span>(szPaire, <span class="keyword">sizeof</span>(szPaire), <span class="string">&quot;%s=%s\n&quot;</span>, it-&gt;first.c_str(), it-&gt;second.c_str());</span><br><span class="line">        <span class="keyword">size_t</span> ret =  fwrite(szPaire, <span class="built_in">strlen</span>(szPaire),<span class="number">1</span>,fp);</span><br><span class="line">        <span class="keyword">if</span>(ret != <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            fclose(fp);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="getConfigName"><a href="#getConfigName" class="headerlink" title="getConfigName"></a>getConfigName</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">CConfigFileReader::getConfigName</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!m_load_ok)<span class="comment">//判断文件是否加载成功</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>* value = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;::iterator it = m_config_map.find(name);<span class="comment">//调用find方法进行查找</span></span><br><span class="line">    <span class="keyword">if</span> (it != m_config_map.end())<span class="comment">//如果it等于end迭代器则表示没有该配置名函数返回</span></span><br><span class="line">    &#123;</span><br><span class="line">        value = (<span class="keyword">char</span>*)it-&gt;second.c_str();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="setConfigValue"><a href="#setConfigValue" class="headerlink" title="setConfigValue"></a>setConfigValue</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CConfigFileReader::setConfigValue</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">const</span> <span class="keyword">char</span>* value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!m_load_ok)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;::iterator it = m_config_map.find(name);</span><br><span class="line">    <span class="keyword">if</span>(it != m_config_map.end())<span class="comment">//如果存在该配置名则设置值</span></span><br><span class="line">    &#123;</span><br><span class="line">        it-&gt;second = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//不存在则添加</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_config_map.insert(<span class="built_in">std</span>::<span class="built_in">make_pair</span>(name, value));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> writeFile();<span class="comment">//写入文件保存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="倒计时锁类"><a href="#倒计时锁类" class="headerlink" title="倒计时锁类"></a>倒计时锁类</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** CountDownLatch.h 还未找到引用处**/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CountDownLatch</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span></span>;<span class="comment">//阻塞当前线程</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span></span>;<span class="comment">//count_减一，阻塞取消条件</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="built_in">std</span>::mutex      mutex_;</span><br><span class="line">    <span class="built_in">std</span>::condition_variable condition_;</span><br><span class="line">    <span class="keyword">int</span>                     count_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">CountDownLatch::CountDownLatch(<span class="keyword">int</span> count)</span><br><span class="line">: count_(count)&#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CountDownLatch::wait</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (count_ &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		condition_.wait(lock);<span class="comment">//释放lock并阻塞在此处，等待唤醒，此处必须使用循环，若使用if则只会阻塞一次</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="countDown"><a href="#countDown" class="headerlink" title="countDown"></a>countDown</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CountDownLatch::countDown</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">	--count_;<span class="comment">//判断条件减一</span></span><br><span class="line">	<span class="keyword">if</span> (count_ == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		condition_.notify_all();<span class="comment">//唤醒阻塞线程</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="getCount"><a href="#getCount" class="headerlink" title="getCount"></a>getCount</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CountDownLatch::getCount</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">	<span class="keyword">return</span> count_;<span class="comment">//获取剩余阻塞条件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Platform"><a href="#Platform" class="headerlink" title="Platform"></a>Platform</h3><p>跨平台使用，统一数据名</p>
<h3 id="RAIIWrapper"><a href="#RAIIWrapper" class="headerlink" title="RAIIWrapper"></a>RAIIWrapper</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __RAII_WRAPPER_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __RAII_WRAPPER_H__</span></span><br><span class="line"><span class="comment">//对象析构时自动释放指针</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">RAIIWrapper</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    RAIIWrapper(T* p) :ptr(p) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~RAIIWrapper()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ptr != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> ptr;</span><br><span class="line">            ptr = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//!__RAII_WRAPPER_H__</span></span></span><br></pre></td></tr></table></figure>

<h3 id="单例模板类"><a href="#单例模板类" class="headerlink" title="单例模板类"></a>单例模板类</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">static</span> T&amp; <span class="title">Instance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="literal">nullptr</span> == value_)</span><br><span class="line">		&#123;</span><br><span class="line">			value_ = <span class="keyword">new</span> T();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> *value_;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Singleton();<span class="comment">//将构造函数设置为私有</span></span><br><span class="line">	~Singleton() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//禁用拷贝构造函数和赋值函数</span></span><br><span class="line">	Singleton(<span class="keyword">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">	Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		value_ = <span class="keyword">new</span> T();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">delete</span> value_;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//static pthread_once_t ponce_;</span></span><br><span class="line">	<span class="keyword">static</span> T*             value_;<span class="comment">//静态成员指针，只存在一个</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T* Singleton&lt;T&gt;::value_ = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>

<h4 id="使用示例-1"><a href="#使用示例-1" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ClassName&amp; test=Singleton&lt;ClassName&gt;::Instance();</span><br></pre></td></tr></table></figure>

<h3 id="时间类"><a href="#时间类" class="headerlink" title="时间类"></a>时间类</h3><h4 id="Timestamp-h"><a href="#Timestamp-h" class="headerlink" title="Timestamp.h"></a>Timestamp.h</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Timestamp.h</span></span><br><span class="line"><span class="comment">//出处muduo网络库</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> FLAMINGREAD_TIMESTAMP_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FLAMINGREAD_TIMESTAMP_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Timestamp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Timestamp() : microSecondsSinceEpoch_(<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Timestamp</span><span class="params">(<span class="keyword">int64_t</span> microSecondsSinceEpoch)</span></span>;</span><br><span class="line"></span><br><span class="line">    Timestamp&amp; <span class="keyword">operator</span>+=(Timestamp lhs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;microSecondsSinceEpoch_ += lhs.microSecondsSinceEpoch_;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Timestamp&amp; <span class="keyword">operator</span>+=(<span class="keyword">int64_t</span> lhs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;microSecondsSinceEpoch_ += lhs;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Timestamp&amp; <span class="keyword">operator</span>-=(Timestamp lhs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;microSecondsSinceEpoch_ -= lhs.microSecondsSinceEpoch_;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Timestamp&amp; <span class="keyword">operator</span>-=(<span class="keyword">int64_t</span> lhs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;microSecondsSinceEpoch_ -= lhs;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Timestamp&amp; that)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::swap(microSecondsSinceEpoch_, that.microSecondsSinceEpoch_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">toString</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">toFormattedString</span><span class="params">(<span class="keyword">bool</span> showMicroseconds = <span class="literal">true</span>)</span> <span class="keyword">const</span></span>;<span class="comment">//showMicroseconds是否显示微妙标志</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">valid</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> microSecondsSinceEpoch_ &gt; <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int64_t</span> <span class="title">microSecondsSinceEpoch</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> microSecondsSinceEpoch_; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">time_t</span> <span class="title">secondsSinceEpoch</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">time_t</span>&gt;(microSecondsSinceEpoch_ / kMicroSecondsPerSecond);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Timestamp <span class="title">now</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Timestamp <span class="title">invalid</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kMicroSecondsPerSecond = <span class="number">1000</span> * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int64_t</span>     microSecondsSinceEpoch_;<span class="comment">//unix时间戳</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(Timestamp lhs, Timestamp rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> lhs.microSecondsSinceEpoch() &lt; rhs.microSecondsSinceEpoch();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(Timestamp lhs, Timestamp rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> rhs &lt; lhs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;=(Timestamp lhs, Timestamp rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> !(lhs &gt; rhs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;=(Timestamp lhs, Timestamp rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> !(lhs &lt; rhs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(Timestamp lhs, Timestamp rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> lhs.microSecondsSinceEpoch() == rhs.microSecondsSinceEpoch();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>!=(Timestamp lhs, Timestamp rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> !(lhs == rhs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///获取两个时间戳的时差，以秒为单位。</span></span><br><span class="line"><span class="comment">///@param高，低</span></span><br><span class="line"><span class="comment">///@返回（高-低）（秒）</span></span><br><span class="line"><span class="comment">///@c double有52位精度，足够一微秒</span></span><br><span class="line"><span class="comment">///最大记录100年后</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">timeDifference</span><span class="params">(Timestamp high, Timestamp low)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int64_t</span> diff = high.microSecondsSinceEpoch() - low.microSecondsSinceEpoch();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(diff) / Timestamp::kMicroSecondsPerSecond;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将@c秒添加到给定的时间戳。</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Timestamp <span class="title">addTime</span><span class="params">(Timestamp timestamp, <span class="keyword">int64_t</span> microseconds)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Timestamp(timestamp.microSecondsSinceEpoch() + microseconds);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//FLAMINGREAD_TIMESTAMP_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Timestamp-cpp"><a href="#Timestamp-cpp" class="headerlink" title="Timestamp.cpp"></a>Timestamp.cpp</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Timestamp.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static_assert</span>(<span class="keyword">sizeof</span>(Timestamp) == <span class="keyword">sizeof</span>(<span class="keyword">int64_t</span>), <span class="string">&quot;sizeof(Timestamp) error&quot;</span>);</span><br><span class="line"></span><br><span class="line">Timestamp::Timestamp(<span class="keyword">int64_t</span> microSecondsSinceEpoch)</span><br><span class="line">: microSecondsSinceEpoch_(microSecondsSinceEpoch)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">Timestamp::toString</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">64</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">int64_t</span> seconds = microSecondsSinceEpoch_ / kMicroSecondsPerSecond;</span><br><span class="line">    <span class="keyword">int64_t</span> microseconds = microSecondsSinceEpoch_ % kMicroSecondsPerSecond;</span><br><span class="line">    <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf)<span class="number">-1</span>, <span class="string">&quot;%lld.%06lld&quot;</span>, (<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span>)seconds, (<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span>)microseconds);</span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">Timestamp::toFormattedString</span><span class="params">(<span class="keyword">bool</span> showMicroseconds)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">time_t</span> seconds = <span class="keyword">static_cast</span>&lt;<span class="keyword">time_t</span>&gt;(microSecondsSinceEpoch_ / kMicroSecondsPerSecond);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">tm_time</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> WIN32</span></span><br><span class="line">	localtime_s(&amp;tm_time, &amp;seconds);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">ptm</span>;</span></span><br><span class="line">	ptm = localtime(&amp;seconds);</span><br><span class="line">	tm_time = *ptm;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">32</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (showMicroseconds)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> microseconds = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(microSecondsSinceEpoch_ % kMicroSecondsPerSecond);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> WIN32</span></span><br><span class="line">		_snprintf_s(buf, <span class="keyword">sizeof</span>(buf), <span class="string">&quot;%4d%02d%02d %02d:%02d:%02d.%06d&quot;</span>,</span><br><span class="line">			tm_time.tm_year + <span class="number">1900</span>, tm_time.tm_mon + <span class="number">1</span>, tm_time.tm_mday,</span><br><span class="line">			tm_time.tm_hour, tm_time.tm_min, tm_time.tm_sec,</span><br><span class="line">			microseconds);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">		<span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf), <span class="string">&quot;%4d%02d%02d %02d:%02d:%02d.%06d&quot;</span>,</span><br><span class="line">			tm_time.tm_year + <span class="number">1900</span>, tm_time.tm_mon + <span class="number">1</span>, tm_time.tm_mday,</span><br><span class="line">			tm_time.tm_hour, tm_time.tm_min, tm_time.tm_sec,</span><br><span class="line">			microseconds);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">#ifdef WIN32</span><br><span class="line">		_snprintf_s(buf, <span class="keyword">sizeof</span>(buf), <span class="string">&quot;%4d%02d%02d %02d:%02d:%02d&quot;</span>,</span><br><span class="line">			tm_time.tm_year + <span class="number">1900</span>, tm_time.tm_mon + <span class="number">1</span>, tm_time.tm_mday,</span><br><span class="line">			tm_time.tm_hour, tm_time.tm_min, tm_time.tm_sec);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">		<span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf), <span class="string">&quot;%4d%02d%02d %02d:%02d:%02d&quot;</span>,</span><br><span class="line">			tm_time.tm_year + <span class="number">1900</span>, tm_time.tm_mon + <span class="number">1</span>, tm_time.tm_mday,</span><br><span class="line">			tm_time.tm_hour, tm_time.tm_min, tm_time.tm_sec);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Timestamp <span class="title">Timestamp::now</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	chrono::time_point&lt;chrono::system_clock, chrono::microseconds&gt; now = chrono::time_point_cast&lt;chrono::microseconds&gt;(</span><br><span class="line">		chrono::system_clock::now());</span><br><span class="line">	<span class="keyword">int64_t</span> microSeconds = now.time_since_epoch().count();</span><br><span class="line">	<span class="function">Timestamp <span class="title">time</span><span class="params">(microSeconds)</span></span>;</span><br><span class="line">	<span class="keyword">return</span> time;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Timestamp <span class="title">Timestamp::invalid</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> Timestamp();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">	Timestamp test=Timestamp::now();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;test.toString()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;test.toFormattedString(<span class="literal">false</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;test.toFormattedString()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">out:</span><br><span class="line">	<span class="number">1591163093.408394</span></span><br><span class="line">    <span class="number">20200603</span> <span class="number">13</span>:<span class="number">44</span>:<span class="number">53</span></span><br><span class="line">    <span class="number">20200603</span> <span class="number">13</span>:<span class="number">44</span>:<span class="number">53.408394</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>开源代码</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>Flamingo</tag>
      </tags>
  </entry>
  <entry>
    <title>线性表</title>
    <url>/posts/40f24371/</url>
    <content><![CDATA[<h3 id="异常类"><a href="#异常类" class="headerlink" title="异常类"></a>异常类</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异常类</span></span><br><span class="line"><span class="comment"> *illegalParameterValue.h</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _ILLEGALPARMETERVALUE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _ILLEGALPARMETERVALUE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">illegalParameterValue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		illegalParameterValue():message(<span class="string">&quot;Illegal paramter value&quot;</span>)&#123;&#125;</span><br><span class="line">		illegalParameterValue(<span class="built_in">std</span>::<span class="built_in">string</span> theMessage)</span><br><span class="line">		&#123;message = theMessage;&#125;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">outputMessage</span><span class="params">()</span></span>&#123;<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;message&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;&#125;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">string</span> message;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>使用示例:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;illegalParameterValue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">abc</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(a&lt;=<span class="number">0</span>||b&lt;=<span class="number">0</span>||c&lt;=<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">throw</span> illegalParameterValue(<span class="string">&quot;All paramtesrs should be &gt;0&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">try</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;abc(<span class="number">2</span>,<span class="number">0</span>,<span class="number">4</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span>(illegalParameterValue e)</span><br><span class="line">	&#123;</span><br><span class="line">		e.outputMessage();</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="改变一个一维数组的长度"><a href="#改变一个一维数组的长度" class="headerlink" title="改变一个一维数组的长度"></a>改变一个一维数组的长度</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *改变一个一维数组的长度</span></span><br><span class="line"><span class="comment"> *changeLength1D.h</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _CHANGELENGTH1D_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CHANGELENGTH1D_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;illegalParameterValue.h&quot;</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">changeLength1D</span>(<span class="title">T</span>*&amp; <span class="title">a</span>, <span class="title">int</span> <span class="title">oldlength</span>, <span class="title">int</span> <span class="title">newlength</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">if</span> (newlength &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">throw</span> illegalParameterValue(<span class="string">&quot;new length must be &gt;0&quot;</span>);</span><br><span class="line">	T* temp = <span class="keyword">new</span> T[newlength];</span><br><span class="line">	<span class="keyword">int</span> number = oldlength &lt; newlength ? oldlength : newlength;</span><br><span class="line">	<span class="built_in">std</span>::copy(a, a + number, temp);</span><br><span class="line">	<span class="keyword">delete</span>[] a;</span><br><span class="line">	a = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span><span class="comment">//!_CHANGELENGTH1D_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="抽象类linearList"><a href="#抽象类linearList" class="headerlink" title="抽象类linearList"></a>抽象类linearList</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *抽象线性表类</span></span><br><span class="line"><span class="comment"> *linearList.h</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _LINEARLIST_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _LINEARLIST_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;illegalParameterValue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">linearList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~linearList()&#123;&#125;;</span><br><span class="line">    <span class="comment">/*纯虚函数，继承后必须实现才能实例化*/</span></span><br><span class="line">    <span class="comment">/*判断线性表是否为空*/</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*返回线性表的元素个数*/</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*返回索引为theIndex的元素*/</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> T&amp; <span class="title">get</span><span class="params">(<span class="keyword">int</span> theIndex)</span> <span class="keyword">const</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*返回元素theElement第一次出现时的索引*/</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">const</span> T&amp; theElement)</span> <span class="keyword">const</span> </span>=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*删除索引为theIndex的元素*/</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">erase</span><span class="params">(<span class="keyword">int</span> theIndex)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*把theElement插入线性表中索引为theIndex的位置上*/</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> T&amp; theElement,<span class="keyword">int</span> theIndex)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*把线性表输出流out上*/</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="built_in">std</span>::ostream&amp; out)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span><span class="comment">//!_LINEARLIST_H_</span></span></span><br></pre></td></tr></table></figure>

<h3 id="数组描述"><a href="#数组描述" class="headerlink" title="数组描述"></a>数组描述</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *线性表类</span></span><br><span class="line"><span class="comment"> *arrayList.h</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _ARRAYLIST_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _ARRAYLIST_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../../base/changeLength1D.h&quot;</span><span class="comment">//头文件在base目录中</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../../base/linearList.h&quot;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">arrayList</span>:</span><span class="keyword">public</span> linearList&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T * element;</span><br><span class="line">    <span class="keyword">int</span> arrayLength;<span class="comment">//一维数组容量</span></span><br><span class="line">    <span class="keyword">int</span> listSize;<span class="comment">//线性表元素个数</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">/*判断传入下标是否正确，抛出异常*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">checkIndex</span><span class="params">(<span class="keyword">int</span> theIndex)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~arrayList()&#123;<span class="keyword">delete</span> [] element;&#125;</span><br><span class="line">    arrayList(<span class="keyword">int</span> initialCapacity=<span class="number">10</span>);<span class="comment">//初始化一个长度为initialCapacity的数组,默认为10</span></span><br><span class="line">    arrayList(<span class="keyword">const</span> arrayList&lt;T&gt;&amp; );<span class="comment">//用一个线性数组来初始化</span></span><br><span class="line">    arrayList(T*&amp;,<span class="keyword">int</span>);<span class="comment">//用一个数组来初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*基本方法*/</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span><span class="keyword">const</span></span>&#123;<span class="keyword">return</span> listSize==<span class="number">0</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span><span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> listSize;&#125;</span><br><span class="line">    <span class="function">T&amp; <span class="title">get</span><span class="params">(<span class="keyword">int</span> theIndex)</span><span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">const</span> T&amp; theElement)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(<span class="keyword">int</span> theIndex)</span> </span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> T&amp; theElement,<span class="keyword">int</span> theIndex)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="built_in">std</span>::ostream&amp; out)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">capacity</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;<span class="keyword">return</span> arrayLength;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*操作符重载*/</span></span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> theIndex )<span class="keyword">const</span>&#123;checkIndex(theIndex);<span class="keyword">return</span> element[theIndex]; &#125;</span><br><span class="line">    arrayList&lt;T&gt;  <span class="keyword">operator</span>+(arrayList&lt;T&gt; &amp;cArray );</span><br><span class="line">    arrayList&lt;T&gt;&amp;  <span class="keyword">operator</span>+=(arrayList&lt;T&gt; &amp;cArray );</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> arrayList&lt;T&gt; &amp;cArray );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">arrayList</span>&lt;T&gt;:</span>:arrayList(<span class="keyword">int</span> initialCapacity)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">ostringstream</span> s;</span><br><span class="line">            s &lt;&lt; <span class="string">&quot;Initial capacity= &quot;</span> &lt;&lt; initialCapacity &lt;&lt; <span class="string">&quot; must be&gt;0&quot;</span>;</span><br><span class="line">            <span class="keyword">throw</span> illegalParameterValue(s.str());</span><br><span class="line">        &#125;</span><br><span class="line">        arrayLength = initialCapacity;</span><br><span class="line">        element = <span class="keyword">new</span> T[initialCapacity];</span><br><span class="line">        listSize = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">arrayList</span>&lt;T&gt;:</span>:arrayList(<span class="keyword">const</span> arrayList&lt;T&gt;&amp;  <span class="built_in">list</span>)</span><br><span class="line">&#123;</span><br><span class="line">    arrayLength=<span class="built_in">list</span>.arrayLength;</span><br><span class="line">    listSize=<span class="built_in">list</span>.listSize;</span><br><span class="line">    element =<span class="keyword">new</span> T[arrayLength];</span><br><span class="line">    <span class="built_in">std</span>::copy(<span class="built_in">list</span>.element,<span class="built_in">list</span>.element+listSize,element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">arrayList</span>&lt;T&gt;:</span>:arrayList(T*&amp; <span class="built_in">list</span>,<span class="keyword">int</span> length)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span> (length &lt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">ostringstream</span> s;</span><br><span class="line">            s &lt;&lt; <span class="string">&quot;Initial capacity= &quot;</span> &lt;&lt; length &lt;&lt; <span class="string">&quot; must be&gt;0&quot;</span>;</span><br><span class="line">            <span class="keyword">throw</span> illegalParameterValue(s.str());</span><br><span class="line">        &#125;</span><br><span class="line">        listSize=length;</span><br><span class="line">        arrayLength=length;</span><br><span class="line">        element=<span class="keyword">new</span> T[length];</span><br><span class="line">        <span class="built_in">std</span>::copy(<span class="built_in">list</span>,<span class="built_in">list</span>+length,element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">arrayList</span>&lt;T&gt;:</span>:output(<span class="built_in">std</span>::ostream &amp;out) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::copy(element, element + listSize, <span class="built_in">std</span>::ostream_iterator&lt;T&gt;(<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">&quot; &quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span>&amp; <span class="title">arrayList</span>&lt;T&gt;:</span>:get(<span class="keyword">int</span> theIndex)<span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    checkIndex(theIndex);</span><br><span class="line">	<span class="keyword">return</span> element[theIndex];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">arrayList</span>&lt;T&gt;:</span>:indexOf(<span class="keyword">const</span> T&amp; theElement) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> Index;</span><br><span class="line">	Index = (<span class="keyword">int</span>)(<span class="built_in">std</span>::find(element, element + listSize, theElement) - element);</span><br><span class="line">	<span class="keyword">if</span> (Index == listSize)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> Index;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">arrayList</span>&lt;T&gt;:</span>:erase(<span class="keyword">int</span> theIndex) </span><br><span class="line">&#123;</span><br><span class="line">    checkIndex(theIndex);</span><br><span class="line">	<span class="built_in">std</span>::copy(element + theIndex + <span class="number">1</span>, element + listSize, element + theIndex);</span><br><span class="line">	element[--listSize].~T();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">arrayList</span>&lt;T&gt;:</span>:insert(<span class="keyword">const</span> T&amp; theElement,<span class="keyword">int</span> theIndex)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (theIndex&lt;<span class="number">0</span> || theIndex&gt;listSize)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">ostringstream</span> s;</span><br><span class="line">		s &lt;&lt; <span class="string">&quot;index = &quot;</span> &lt;&lt;theIndex &lt;&lt; <span class="string">&quot;  size = &quot;</span> &lt;&lt; listSize;</span><br><span class="line">		<span class="keyword">throw</span> illegalParameterValue(s.str());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (listSize == arrayLength)</span><br><span class="line">	&#123;</span><br><span class="line">		changeLength1D(element, arrayLength, arrayLength * <span class="number">2</span>);</span><br><span class="line">		arrayLength *= <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::copy_backward(element + theIndex, element + listSize, element + theIndex+<span class="number">1</span>);</span><br><span class="line">	element[theIndex] = theElement;</span><br><span class="line">	listSize++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">arrayList</span>&lt;T&gt;:</span>:checkIndex(<span class="keyword">int</span> theIndex) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (theIndex &lt; <span class="number">0</span> || theIndex &gt;= listSize)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">ostringstream</span> s;</span><br><span class="line">		s &lt;&lt; <span class="string">&quot;index = &quot;</span> &lt;&lt;theIndex &lt;&lt; <span class="string">&quot;  size = &quot;</span> &lt;&lt; listSize;</span><br><span class="line">		<span class="keyword">throw</span> illegalParameterValue(s.str());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">std</span>:</span>:ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp; out,arrayList&lt;T&gt;&amp; cArray)</span><br><span class="line">&#123;</span><br><span class="line">    cArray.output(out);</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">arrayList</span>&lt;T&gt;&amp;   <span class="title">arrayList</span>&lt;T&gt;:</span>:<span class="keyword">operator</span>+=(arrayList&lt;T&gt; &amp; cArry )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> temp=listSize;</span><br><span class="line">    listSize+=cArry.listSize;</span><br><span class="line">    arrayLength+=cArry.arrayLength;</span><br><span class="line">    changeLength1D(element,temp,listSize);</span><br><span class="line">    <span class="built_in">std</span>::copy(cArry.element,cArry.element+cArry.listSize,element+temp);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">arrayList</span>&lt;T&gt;   <span class="title">arrayList</span>&lt;T&gt;:</span>:<span class="keyword">operator</span>+(arrayList&lt;T&gt; &amp; cArry)</span><br><span class="line">&#123;</span><br><span class="line">    arrayList&lt;T&gt; temp;</span><br><span class="line">    temp.listSize=cArry.listSize+<span class="keyword">this</span>-&gt;listSize;</span><br><span class="line">    temp.arrayLength=cArry.arrayLength+<span class="keyword">this</span>-&gt;arrayLength;</span><br><span class="line">    changeLength1D(temp.element,<span class="number">10</span>,temp.arrayLength);</span><br><span class="line">    <span class="built_in">std</span>::copy(<span class="keyword">this</span>-&gt;element,<span class="keyword">this</span>-&gt;element+<span class="keyword">this</span>-&gt;listSize,temp.element);</span><br><span class="line">    <span class="built_in">std</span>::copy(cArry.element,cArry.element+cArry.listSize,temp.element+<span class="keyword">this</span>-&gt;listSize);</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">arrayList</span>&lt;T&gt;:</span>:<span class="keyword">operator</span>=(<span class="keyword">const</span> arrayList&lt;T&gt; &amp;cArray )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;arrayLength=cArray.arrayLength;</span><br><span class="line">    <span class="keyword">this</span>-&gt;listSize=cArray.listSize;</span><br><span class="line">    <span class="keyword">this</span>-&gt;element =<span class="keyword">new</span> T[<span class="keyword">this</span>-&gt;arrayLength];</span><br><span class="line">    <span class="built_in">std</span>::copy(cArray.element,cArray.element+listSize,<span class="keyword">this</span>-&gt;element);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="链表描述"><a href="#链表描述" class="headerlink" title="链表描述"></a>链表描述</h3><h4 id="链表节点结构"><a href="#链表节点结构" class="headerlink" title="链表节点结构"></a>链表节点结构</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *链表节点结构</span></span><br><span class="line"><span class="comment"> *chainNode.h</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _CHAINNODE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CHAINNODE_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">chainNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   T element;</span><br><span class="line">   chainNode&lt;T&gt;* next;</span><br><span class="line">   chainNode()&#123;<span class="keyword">this</span>-&gt;next=<span class="literal">NULL</span>;&#125;</span><br><span class="line">   chainNode(<span class="keyword">const</span> T&amp; element )</span><br><span class="line">    &#123;<span class="keyword">this</span>-&gt;element=element;</span><br><span class="line">    <span class="keyword">this</span>-&gt;next=<span class="literal">NULL</span>;&#125;</span><br><span class="line">    chainNode(<span class="keyword">const</span> T&amp; element, chainNode&lt;T&gt;* next)</span><br><span class="line">    &#123;<span class="keyword">this</span>-&gt;element=element;</span><br><span class="line">    <span class="keyword">this</span>-&gt;next=next;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span><span class="comment">//!_CHAINNODE_H_</span></span></span><br></pre></td></tr></table></figure>

<h4 id="链表类"><a href="#链表类" class="headerlink" title="链表类"></a>链表类</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *链表数据结构</span></span><br><span class="line"><span class="comment"> *chain.h</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _CHAIN_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CHAIN_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../../base/linearList.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../../base/changeLength1D.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;chainNode.h&quot;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">chain</span> :</span><span class="keyword">public</span> linearList&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	chain(<span class="keyword">int</span> initialCpacity = <span class="number">10</span>);</span><br><span class="line">	chain(<span class="keyword">const</span> chain&lt;T&gt;&amp;);</span><br><span class="line">    chain(T*&amp;,<span class="keyword">int</span>);</span><br><span class="line">	~chain();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;<span class="keyword">return</span> listSize==<span class="number">0</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;<span class="keyword">return</span> listSize;&#125;</span><br><span class="line">	<span class="function">T&amp; <span class="title">get</span><span class="params">(<span class="keyword">int</span> theIndex)</span> <span class="keyword">const</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">const</span> T &amp; theElement)</span> <span class="keyword">const</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(<span class="keyword">int</span> theIndex)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> T&amp; theElement,<span class="keyword">int</span> theIndex)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="built_in">std</span>::ostream&amp; out)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T&amp; theElement)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*操作符重载*/</span></span><br><span class="line">    chain&lt;T&gt;  <span class="keyword">operator</span>+(chain&lt;T&gt; &amp;cList );</span><br><span class="line">    chain&lt;T&gt;&amp;  <span class="keyword">operator</span>+=(chain&lt;T&gt; &amp;cList );</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> chain&lt;T&gt; &amp;cList );</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">checkIndex</span><span class="params">(<span class="keyword">int</span> theIndex)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	chainNode&lt;T&gt;* firstNode; <span class="comment">//指向链表的第一个元素</span></span><br><span class="line">	<span class="keyword">int</span> listSize;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">chain</span>&lt;T&gt;:</span>:output(<span class="built_in">std</span>::ostream&amp; out) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (chainNode&lt;T&gt;* currNode = firstNode; currNode != <span class="literal">NULL</span>; currNode = currNode-&gt;next)</span><br><span class="line">	&#123;</span><br><span class="line">		out &lt;&lt; currNode-&gt;element&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">std</span>:</span>:ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp; out,chain&lt;T&gt;&amp; cList)</span><br><span class="line">&#123;</span><br><span class="line">    cList.output(out);</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">chain</span>&lt;T&gt;  <span class="title">chain</span>&lt;T&gt;:</span>:<span class="keyword">operator</span>+(chain&lt;T&gt; &amp;cList )</span><br><span class="line">&#123;</span><br><span class="line">  chain&lt;T&gt; ret;</span><br><span class="line">  chainNode&lt;T&gt;* soureNode =<span class="keyword">this</span>-&gt;firstNode;</span><br><span class="line">  chainNode&lt;T&gt;* targetNode=<span class="keyword">new</span> chainNode&lt;T&gt;(soureNode-&gt;element);</span><br><span class="line">  chainNode&lt;T&gt;* retNode=targetNode;</span><br><span class="line">  soureNode=soureNode-&gt;next;</span><br><span class="line">  <span class="keyword">while</span> (soureNode != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		targetNode-&gt;next = <span class="keyword">new</span> chainNode&lt;T&gt;(soureNode-&gt;element);</span><br><span class="line">		targetNode = targetNode-&gt;next;</span><br><span class="line">		soureNode = soureNode-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">    soureNode=cList.firstNode;</span><br><span class="line">    <span class="keyword">while</span> (soureNode != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		targetNode-&gt;next = <span class="keyword">new</span> chainNode&lt;T&gt;(soureNode-&gt;element);</span><br><span class="line">		targetNode = targetNode-&gt;next;</span><br><span class="line">		soureNode = soureNode-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	targetNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	ret.clear();</span><br><span class="line">	ret.listSize=cList.listSize+<span class="keyword">this</span>-&gt;listSize;</span><br><span class="line">    ret.firstNode=retNode;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">chain</span>&lt;T&gt;&amp;  <span class="title">chain</span>&lt;T&gt;:</span>:<span class="keyword">operator</span>+=(chain&lt;T&gt; &amp;cList )</span><br><span class="line">&#123;</span><br><span class="line">  chainNode&lt;T&gt;* soureNode =cList.firstNode;</span><br><span class="line">  chainNode&lt;T&gt;* targetNode = <span class="keyword">this</span>-&gt;firstNode;</span><br><span class="line">  <span class="keyword">while</span>(targetNode-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">       targetNode=targetNode-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (soureNode != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		targetNode-&gt;next = <span class="keyword">new</span> chainNode&lt;T&gt;(soureNode-&gt;element);</span><br><span class="line">		targetNode = targetNode-&gt;next;</span><br><span class="line">		soureNode = soureNode-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	targetNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">   <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">chain</span>&lt;T&gt;:</span>:<span class="keyword">operator</span>=(<span class="keyword">const</span> chain&lt;T&gt; &amp;cList )</span><br><span class="line">&#123;</span><br><span class="line">    listSize = cList.listSize;</span><br><span class="line">	<span class="keyword">if</span> (cList.listSize == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		listSize = <span class="number">0</span>;</span><br><span class="line">		firstNode = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	chainNode&lt;T&gt;* soureNode = cList.firstNode;</span><br><span class="line">	firstNode = <span class="keyword">new</span> chainNode&lt;T&gt;(soureNode-&gt;element);</span><br><span class="line">	soureNode = soureNode-&gt;next;</span><br><span class="line">	chainNode&lt;T&gt;* targetNode = firstNode;</span><br><span class="line">	<span class="keyword">while</span> (soureNode != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		targetNode-&gt;next = <span class="keyword">new</span> chainNode&lt;T&gt;(soureNode-&gt;element);</span><br><span class="line">		targetNode = targetNode-&gt;next;</span><br><span class="line">		soureNode = soureNode-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	targetNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">chain</span>&lt;T&gt;:</span>:chain(<span class="keyword">int</span> initialCpacity)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCpacity &lt; <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">ostringstream</span> s;</span><br><span class="line">		s &lt;&lt; <span class="string">&quot;Initial capaity = &quot;</span> &lt;&lt; initialCpacity &lt;&lt; <span class="string">&quot; must be &gt; 0 &quot;</span> ;</span><br><span class="line">		<span class="keyword">throw</span> illegalParameterValue(s.str());</span><br><span class="line">	&#125;</span><br><span class="line">	firstNode = <span class="literal">NULL</span>;</span><br><span class="line">	listSize = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">chain</span>&lt;T&gt;:</span>:chain(<span class="keyword">const</span> chain&lt;T&gt;&amp;theList)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (theList.listSize == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		listSize = <span class="number">0</span>;</span><br><span class="line">		firstNode = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">     listSize = theList.listSize;</span><br><span class="line">	chainNode&lt;T&gt;* soureNode = theList.firstNode;</span><br><span class="line">	firstNode = <span class="keyword">new</span> chainNode&lt;T&gt;(soureNode-&gt;element);</span><br><span class="line">	soureNode = soureNode-&gt;next;</span><br><span class="line">	chainNode&lt;T&gt;* targetNode = firstNode;</span><br><span class="line">	<span class="keyword">while</span> (soureNode != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		targetNode-&gt;next = <span class="keyword">new</span> chainNode&lt;T&gt;(soureNode-&gt;element);</span><br><span class="line">		targetNode = targetNode-&gt;next;</span><br><span class="line">		soureNode = soureNode-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	targetNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">chain</span>&lt;T&gt;:</span>:chain(T*&amp; <span class="built_in">list</span>,<span class="keyword">int</span> length)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (length &lt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">ostringstream</span> s;</span><br><span class="line">            s &lt;&lt; <span class="string">&quot;Initial capacity= &quot;</span> &lt;&lt; length &lt;&lt; <span class="string">&quot; must be&gt;0&quot;</span>;</span><br><span class="line">            <span class="keyword">throw</span> illegalParameterValue(s.str());</span><br><span class="line">        &#125;</span><br><span class="line">    listSize=length;</span><br><span class="line">	firstNode = <span class="keyword">new</span> chainNode&lt;T&gt;(<span class="built_in">list</span>[<span class="number">0</span>]);</span><br><span class="line">    firstNode-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	chainNode&lt;T&gt;* targetNode = firstNode;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        targetNode-&gt;next=<span class="keyword">new</span> chainNode&lt;T&gt;(<span class="built_in">list</span>[i]);</span><br><span class="line">        targetNode=targetNode-&gt;next;</span><br><span class="line">        targetNode-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">chain</span>&lt;T&gt;:</span>:~chain()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span> (firstNode != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		chainNode&lt;T&gt;* nextNode = firstNode-&gt;next;</span><br><span class="line">		<span class="keyword">delete</span> firstNode;</span><br><span class="line">		firstNode = nextNode;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">chain</span>&lt;T&gt;:</span>:checkIndex(<span class="keyword">int</span> theIndex) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (theIndex &lt; <span class="number">0</span> || theIndex &gt;= listSize)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">ostringstream</span> s;</span><br><span class="line">		s &lt;&lt; <span class="string">&quot;index =&quot;</span> &lt;&lt; theIndex &lt;&lt; <span class="string">&quot;  size = &quot;</span> &lt;&lt; listSize;</span><br><span class="line">		<span class="keyword">throw</span> illegalParameterValue(s.str());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span>&amp; <span class="title">chain</span>&lt;T&gt;:</span>:get(<span class="keyword">int</span> theIndex) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	checkIndex(theIndex);</span><br><span class="line">	chainNode&lt;T&gt;* currNode = firstNode;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; theIndex; i++)</span><br><span class="line">		currNode = currNode-&gt;next;</span><br><span class="line">	<span class="keyword">return</span> currNode-&gt;element;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">chain</span>&lt;T&gt;:</span>:indexOf(<span class="keyword">const</span> T &amp; theElement) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	chainNode&lt;T&gt;* currNode = firstNode;</span><br><span class="line">	<span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (currNode != <span class="literal">NULL</span> &amp;&amp; currNode-&gt;element != theElement)</span><br><span class="line">	&#123;</span><br><span class="line">		currNode = currNode-&gt;next;</span><br><span class="line">		index++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (currNode == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">chain</span>&lt;T&gt;:</span>:erase(<span class="keyword">int</span> theIndex)</span><br><span class="line">&#123;</span><br><span class="line">	checkIndex(theIndex);</span><br><span class="line">	chainNode&lt;T&gt;* delNode;</span><br><span class="line">	<span class="keyword">if</span> (theIndex == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		delNode = firstNode;</span><br><span class="line">		firstNode = firstNode-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		chainNode&lt;T&gt;* p = firstNode;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; theIndex - <span class="number">1</span>; i++)</span><br><span class="line">			p = p-&gt;next;</span><br><span class="line">		delNode = p-&gt;next;</span><br><span class="line">		p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	listSize--;</span><br><span class="line">	<span class="keyword">delete</span> delNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">chain</span>&lt;T&gt;:</span>:insert(<span class="keyword">const</span> T&amp; theElement,<span class="keyword">int</span> theIndex)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (theIndex &lt; <span class="number">0</span> || theIndex &gt; listSize)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">ostringstream</span> s;</span><br><span class="line">		s &lt;&lt; <span class="string">&quot;index =&quot;</span> &lt;&lt; theIndex &lt;&lt; <span class="string">&quot;  size = &quot;</span> &lt;&lt; listSize;</span><br><span class="line">		<span class="keyword">throw</span> illegalParameterValue(s.str());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (theIndex == <span class="number">0</span>)</span><br><span class="line">		firstNode = <span class="keyword">new</span> chainNode&lt;T&gt;(theElement, firstNode);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		chainNode&lt;T&gt;* p = firstNode;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; theIndex - <span class="number">1</span>; i++)</span><br><span class="line">			p = p-&gt;next;</span><br><span class="line">		p-&gt;next = <span class="keyword">new</span> chainNode&lt;T&gt;(theElement, p-&gt;next);</span><br><span class="line">	&#125;</span><br><span class="line">	listSize++;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">chain</span>&lt;T&gt;:</span>:clear()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span> (firstNode != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		chainNode&lt;T&gt;* nextNode = firstNode-&gt;next;</span><br><span class="line">		<span class="keyword">delete</span> firstNode;</span><br><span class="line">		firstNode = nextNode;</span><br><span class="line">	&#125;</span><br><span class="line">	listSize=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">chain</span>&lt;T&gt;:</span>:push_back(<span class="keyword">const</span> T&amp; theElement)</span><br><span class="line">&#123;</span><br><span class="line">	chainNode&lt;T&gt;* newNode = <span class="keyword">new</span> chainNode&lt;T&gt;(theElement,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span>(firstNode==<span class="literal">NULL</span>)</span><br><span class="line">		firstNode=newNode;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		chainNode&lt;T&gt;* targetNode = firstNode;</span><br><span class="line">		<span class="keyword">while</span>(targetNode-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">			targetNode=targetNode-&gt;next;</span><br><span class="line">		targetNode-&gt;next=newNode;</span><br><span class="line">	&#125;</span><br><span class="line">	listSize++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span><span class="comment">//!_CHAIN_H_</span></span></span><br></pre></td></tr></table></figure>

<p>参考及代码来源: <a href="https://www.cise.ufl.edu/~sahni/dsaac/">《数据结构、算法与应用  C++语言描述  原书第2版》</a></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/posts/735e5788/</url>
    <content><![CDATA[<h3 id="交换算法"><a href="#交换算法" class="headerlink" title="交换算法"></a>交换算法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">int</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp;</span><br><span class="line">	temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p><a href="https://www.jianshu.com/p/1458abf81adf">图文参考</a></p>
<p>比较相邻的两个数大的(或小的)换到右边去，每经过一次循环，便有一个数冒到顶端.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt; size;i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size-i<span class="number">-1</span>; j++)<span class="comment">//大循环每循环一次比较的元素就可以减少一个，可以用i来控制</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (a[j + <span class="number">1</span>] &lt; a[j])</span><br><span class="line">				swap(a[j + <span class="number">1</span>], a[j]);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="及时终止的冒泡排序"><a href="#及时终止的冒泡排序" class="headerlink" title="及时终止的冒泡排序"></a>及时终止的冒泡排序</h3><p>在上一个冒泡排序的算法中即使数组是有序的也会执行和乱序数组相同的次数，可以在内循环设置一个是否发生了数据交换的标志，如果没有发生交换则说明数组已经有序，便不用再进行比较了.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bubble</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">bool</span> swaped = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (a[i] &gt; a[i + <span class="number">1</span>])</span><br><span class="line">		&#123;</span><br><span class="line">			swap(a[i], a[i + <span class="number">1</span>]);</span><br><span class="line">			swaped = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> swaped;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt; <span class="number">1</span> &amp;&amp; bubble(a, i); i--);<span class="comment">//bubble返回真，即发生了数字交换，数组无序，继续进行排序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>区间依次变大将下一个数插入到合适的位置．</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_sort</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> temp = a[i];</span><br><span class="line">		<span class="keyword">int</span> j;</span><br><span class="line">		<span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; temp &lt; a[j]; j--)</span><br><span class="line">			a[j + <span class="number">1</span>] = a[j];</span><br><span class="line">		a[j + <span class="number">1</span>] = temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>图文参考:<a href="https://www.cnblogs.com/chengxiao/p/6104371.html">1</a>,<a href="https://www.jianshu.com/p/40dcc3b83ddc">2</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell_sort</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> gap, f, i, j, temp;</span><br><span class="line">	f = <span class="number">2</span>;</span><br><span class="line">	gap = size / f;<span class="comment">//每次的增量，依次减小插入排序的区间</span></span><br><span class="line">	<span class="keyword">while</span> (gap &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (i = gap; i &lt; size; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			temp = a[i];</span><br><span class="line">			<span class="keyword">for</span> (j = i - gap; j &gt;= <span class="number">0</span> &amp;&amp; temp &lt; a[j]; j -= gap)</span><br><span class="line">				a[j + gap] = a[j];</span><br><span class="line">			a[j + gap] = temp;</span><br><span class="line">		&#125;</span><br><span class="line">		gap /= f;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>固定最左端的一个数，将小的移动到其左边，大的移动到右边．</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> _left = left;</span><br><span class="line">	<span class="keyword">int</span> _right = right;</span><br><span class="line">	<span class="keyword">int</span> base = left;</span><br><span class="line">	<span class="keyword">if</span> (_left &lt; _right)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (_left &lt; _right)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">do</span></span><br><span class="line">			&#123;</span><br><span class="line">				_left++;</span><br><span class="line">			&#125; <span class="keyword">while</span> (a[_left] &lt; a[base] &amp;&amp; _left &lt; right);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">while</span> (a[_right] &gt; a[base] &amp;&amp; _right &gt; left)</span><br><span class="line">				_right--;</span><br><span class="line">			<span class="keyword">if</span> (_left &lt; _right)</span><br><span class="line">				swap(a[_left], a[_right]);</span><br><span class="line">		&#125;</span><br><span class="line">		swap(a[left], a[_right]);</span><br><span class="line">		quick_sort(a, left, _right <span class="number">-1</span>);</span><br><span class="line">		quick_sort(a, _right + <span class="number">1</span>, right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串匹配算法</title>
    <url>/posts/cf923a11/</url>
    <content><![CDATA[<h3 id="暴力法–bf算法"><a href="#暴力法–bf算法" class="headerlink" title="暴力法–bf算法"></a>暴力法–bf算法</h3><p>算法思想:将目标串S的第一个字符与模式串T的第一个字符进行匹配，若相等，则继续比较S的第二个字符和 T的第二个字符；若不相等，则比较S的第二个字符和T的第一个字符，依次比较下去，直到得出最后的匹配结果。设模式串长度为n,目标串长度为m,bf算法的时间复杂度最好为O(n),最差为O(m*n)</p>
<a id="more"></a>

<h4 id="伪码"><a href="#伪码" class="headerlink" title="伪码"></a>伪码</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1 . 在串 S 和串 T 中设比较的起始下标 i 和 j;</span><br><span class="line">2 . 循环直到 S 中所剩字符个数小于 T 的长度或 T 的所有字符均比较完</span><br><span class="line">    2 .1 如果 S[i] = T [j] ,则继续比较 S 和 T 的下一个字符 ; 否则</span><br><span class="line">    2 .2 将 i 和 j 回溯 ,准备下一趟比较 ;</span><br><span class="line">3 . 如果 T 中所有字符均比较完 , 则匹配成功 , 返回匹配的起始比较下标 ;</span><br><span class="line">否则 ,匹配失败 ,返回 0;</span><br></pre></td></tr></table></figure>

<h4 id="C代码"><a href="#C代码" class="headerlink" title="C代码"></a>C代码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bf</span><span class="params">(<span class="keyword">char</span> *str1,<span class="keyword">char</span> *str2)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//str1为模式串，str2为目标串，返回模式串在目标串中开始的位置</span></span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;<span class="comment">//i为模式串下标，j为目标串下标</span></span><br><span class="line">    <span class="keyword">while</span> (i&lt;<span class="built_in">strlen</span>(str1)&amp;&amp;j&lt;<span class="built_in">strlen</span>(str2))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(str1[i]==str2[j]) </span><br><span class="line">        &#123;<span class="comment">//如果两个串的字符相等则同时后移</span></span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;<span class="comment">//如果没有，则str1回到开始，str2往后移一位</span></span><br><span class="line">            j=j-i+<span class="number">1</span>;</span><br><span class="line">            i=<span class="number">0</span>;</span><br><span class="line">        &#125;     </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="built_in">strlen</span>(str1))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果i等与str1的长度，则有匹配的字符串，跳出循环,返回子串起始位置</span></span><br><span class="line">        <span class="keyword">return</span> (j-i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//例如:目标串S=″aaaaaaaaaaab″,模式串为&quot;aaab&quot;，使用示例:./app aaaab aaaaaaaaaab</span></span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Usage %s str1,str2&quot;</span>,argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">int</span> i=bf(argv[<span class="number">1</span>],argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">if</span>(i&gt;<span class="number">0</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="执行示例"><a href="#执行示例" class="headerlink" title="执行示例"></a>执行示例</h4><p><img src="/images/bf.png" alt="bf"> </p>
<h3 id="贪心法–KMP算法"><a href="#贪心法–KMP算法" class="headerlink" title="贪心法–KMP算法"></a>贪心法–KMP算法</h3><p>算法思想:设计一个next数组来进行回溯，一旦字符发生不匹配，便按照next数组进行回溯，减少无用的比较.设模式串长度为n,目标串长度为m,KMP算法的时间复杂度为O(n+m).</p>
<h4 id="伪码-1"><a href="#伪码-1" class="headerlink" title="伪码:"></a>伪码:</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1 . 在串 S 和串 T 中分别设比较的起始下标 i 和 j;</span><br><span class="line">2 . 循环直到 S 中所剩字符长度小于 T 的长度或 T 中所有字符均比较完毕</span><br><span class="line">    2 .1 如果 S[i] = T [j] ,则继续比较 S 和 T 的下一个字符 ; 否则</span><br><span class="line">    2 .2 将 j 向右滑动到 next[ j] 位置 ,即 j = next[j] ;</span><br><span class="line">    2 .3 如果 j = -1 ,则将 i 和 j 分别加 1 ,准备下一趟比较;</span><br><span class="line">3 . 如果 T 中所有字符均比较完毕 , 则返回匹配的起始下标 ,否则返回 -1;</span><br></pre></td></tr></table></figure>

<h4 id="Next数组求法"><a href="#Next数组求法" class="headerlink" title="Next数组求法"></a>Next数组求法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNext</span><span class="params">(<span class="built_in">string</span> P, <span class="keyword">int</span> next[])</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//abcdabd 的next数组:-1 0 0 0 0 1 2   next数组解决的主要是模式串中存在一定长度的相同字符串的情况下节省比较次数</span></span><br><span class="line">     <span class="keyword">int</span> j=<span class="number">0</span>,t=<span class="number">-1</span>;</span><br><span class="line">    next[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;P.length())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(t==<span class="number">-1</span>||P[j]==P[t])</span><br><span class="line">        &#123;</span><br><span class="line">            j++;t++;</span><br><span class="line">            next[j]=t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        t=next[t];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Next数组升级版"><a href="#Next数组升级版" class="headerlink" title="Next数组升级版"></a>Next数组升级版</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetNextval</span><span class="params">(<span class="built_in">string</span> p, <span class="keyword">int</span> next[])</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> pLen = p.length();  </span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;  </span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">-1</span>;  </span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span> (j &lt; pLen)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="comment">//p[k]表示前缀，p[j]表示后缀    </span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">-1</span> || p[j] == p[k])  </span><br><span class="line">        &#123;  </span><br><span class="line">            ++j;  </span><br><span class="line">            ++k;  </span><br><span class="line">            <span class="comment">//较之前next数组求法，改动在下面4行  </span></span><br><span class="line">            <span class="keyword">if</span> (p[j] != p[k])  </span><br><span class="line">                next[j] = k;   <span class="comment">//之前只有这一行  </span></span><br><span class="line">            <span class="keyword">else</span>  </span><br><span class="line">                <span class="comment">//因为不能出现p[j] = p[ next[j ]]，所以当出现时需要继续递归，k = next[k] = next[next[k]]  </span></span><br><span class="line">                next[j] = next[k];  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">        &#123;  </span><br><span class="line">            k = next[k];  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h4 id="完整算法"><a href="#完整算法" class="headerlink" title="完整算法"></a>完整算法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNext</span><span class="params">(<span class="built_in">string</span> P, <span class="keyword">int</span> next[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> j=<span class="number">0</span>,t=<span class="number">-1</span>;</span><br><span class="line">    next[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;P.length())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(t==<span class="number">-1</span>||P[j]==P[t])</span><br><span class="line">        &#123;</span><br><span class="line">            j++;t++;</span><br><span class="line">            next[j]=t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        t=next[t];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMP</span><span class="params">(<span class="built_in">string</span> S, <span class="built_in">string</span> P, <span class="keyword">int</span> next[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    getNext(P, next);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;  <span class="comment">// S 的下标</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;  <span class="comment">// P 的下标</span></span><br><span class="line">    <span class="keyword">int</span> s_len = S.size();</span><br><span class="line">    <span class="keyword">int</span> p_len = P.size();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; s_len &amp;&amp; j &lt; p_len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || S[i] == P[j])  <span class="comment">// P 的第一个字符不匹配或 S[i] == P[j]</span></span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j = next[j];  <span class="comment">// 当前字符匹配失败，进行跳转</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (j == p_len)  <span class="comment">// 匹配成功</span></span><br><span class="line">        <span class="keyword">return</span> i - j;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> next[<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; KMP(<span class="string">&quot;bbc abcdab abcdabcdabde&quot;</span>, <span class="string">&quot;abcdabd&quot;</span>, next) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 15　next数组:-1 0 0 0 0 1 2 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用代码进行调试，可以观察到KMP算法的目标串不做回溯，一旦匹配失败则由模式串做移动.</p>
<p>一个运行图示:<img src="/images/kmp.png" alt="kmp"></p>
<h3 id="BM算法"><a href="#BM算法" class="headerlink" title="BM算法"></a>BM算法</h3><p>BM(Boyer -Moore)算法是Boyer 和Moore共同设计的快速串匹配算法。BM 算法与KMP 算法的主要区别是匹配操作的方向不同。虽然BM 算法仅把匹配操作的字符比较顺序改为从右向左,但匹配发生失败时,模式T 右移的计算方法却发生了较大的变化。</p>
<p>为了方便讨论,假设字符表∑= { a, b, ……, y, z} , BM 算法的关键是,对给定的模式T = “t1 t2 …… tm”,定义一个从字符到正整数的映射:</p>
<p>dist ：c→{1, 2,……, m}  [c∈∑]</p>
<p>函数dist 称为滑动距离函数,它给出了正文中可能出现的任意字符在模式中的位置。函数dist 定义如下:</p>
<p><img src="/images/bm1.jpg" alt="img"> </p>
<p>例如, T =”pattern”,则dist ( p) = 6 , dist ( a) = 5 , dist ( t) = 3, dist ( e) = 2, dist ( r) = 1,dist ( n) = 7,字符表∑中的其他字符ch的dist ( ch) = 7。</p>
<p>BM 算法的基本思想是：假设将主串中自位置i 起往左的一个子串与模式进行从右到左的匹配过程中,若发现不匹配,则下次应从主串的i + dist ( si )位置开始重新进行新一轮的匹配,其效果相当于把模式和主串均向右滑过一段距离dist (si) ,即跳过dist (si )个字符而无需进行比较。</p>
<p>代码仅供参考</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dist</span><span class="params">(<span class="keyword">char</span> c,<span class="built_in">string</span> str)</span></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i;i&lt;str.size();i++)</span><br><span class="line">        <span class="keyword">if</span>(c==str[i]) </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;=str.size()<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> str.size()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> (str.size()-i<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BM</span><span class="params">(<span class="built_in">string</span> s,<span class="built_in">string</span> t,<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;    <span class="comment">//主串的长度为n,模式串的长度为m,主串和模式的数组下标从1 开始 s为主串,t为模式串</span></span><br><span class="line">   <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">    i=m;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=n)</span><br><span class="line">    &#123;</span><br><span class="line">        j=m;</span><br><span class="line">        <span class="keyword">while</span> (j&gt;<span class="number">0</span>&amp;&amp;s[i]==t[j])</span><br><span class="line">        &#123;</span><br><span class="line">            j--;i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">else</span>  i=i+dist(s[i],t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s=<span class="string">&quot;bbc abcdab abcdabcdabde&quot;</span>,t=<span class="string">&quot;abcdabd&quot;</span>,st=<span class="string">&quot;pattern&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; BM(s,st,s.length()<span class="number">-1</span>,st.length() <span class="number">-1</span>) &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 通用二进制包安装</title>
    <url>/posts/cf6a0fee/</url>
    <content><![CDATA[<h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.28-linux-glibc2.12-x86_64.tar.gz</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="安装依赖包"><a href="#安装依赖包" class="headerlink" title="安装依赖包"></a>安装依赖包</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#redhat系列</span></span><br><span class="line">yum search libaio  <span class="comment"># search for info</span></span><br><span class="line">yum install libaio <span class="comment"># install library</span></span><br><span class="line"><span class="comment">#debain系列</span></span><br><span class="line">apt-cache search libaio <span class="comment"># search for info</span></span><br><span class="line">apt-get install libaio1 <span class="comment"># install library</span></span><br></pre></td></tr></table></figure>

<h3 id="redhat系列需要卸载自带的mariadb"><a href="#redhat系列需要卸载自带的mariadb" class="headerlink" title="redhat系列需要卸载自带的mariadb"></a>redhat系列需要卸载自带的mariadb</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@my-pi <span class="built_in">local</span>]<span class="comment"># rpm -qa | grep mariadb</span></span><br><span class="line">mariadb-libs-5.5.64-1.el7.armv7hl</span><br><span class="line">[root@my-pi <span class="built_in">local</span>]<span class="comment">#  rpm -e --nodeps mariadb-libs-5.5.64-1.el7.armv7hl</span></span><br></pre></td></tr></table></figure>

<h3 id="创建一个mysql用户和组"><a href="#创建一个mysql用户和组" class="headerlink" title="创建一个mysql用户和组"></a>创建一个mysql用户和组</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">groupadd mysql <span class="comment">#添加mysql组</span></span><br><span class="line">useradd -r -g mysql -s /bin/<span class="literal">false</span> mysql <span class="comment">#添加mysql用户设置其不允许登录</span></span><br></pre></td></tr></table></figure>

<h3 id="解压文件"><a href="#解压文件" class="headerlink" title="解压文件"></a>解压文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar  -zxvf /path/to/mysql-VERSION-OS.tar.gz -C /path <span class="comment">#解压下载的二进制包到需要安装mysql的目录</span></span><br><span class="line">tar -zxvf mysql-5.7.28-linux-glibc2.12-x86_64.tar.gz  -C /usr/<span class="built_in">local</span>/</span><br></pre></td></tr></table></figure>

<h3 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h3><h4 id="以下目录-path-为-usr-local"><a href="#以下目录-path-为-usr-local" class="headerlink" title="以下目录(path)为/usr/local"></a>以下目录(path)为/usr/local</h4><ol>
<li><p>创建一个mysql的软链接</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span> </span><br><span class="line"> ln -s full-path-to-mysql-VERSION-OS mysql</span><br><span class="line"> ln -s /usr/<span class="built_in">local</span>/mysql-5.7.28-linux-glibc2.12-x86_64/ mysql</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加mysql环境变量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/profile</span><br><span class="line"><span class="comment">#添加下面一行</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/<span class="built_in">local</span>/mysql/bin</span><br><span class="line"><span class="built_in">source</span> /etc/profile <span class="comment">#使环境变量生效</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建数据目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/mysql</span><br><span class="line">mkdir data</span><br><span class="line">chown mysql.mysql data</span><br><span class="line">chmod 750 data</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化mysql</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/mysql</span><br><span class="line">bin/mysqld --initialize  --user=mysql  --basedir=/usr/<span class="built_in">local</span>/mysql  --datadir=/usr/<span class="built_in">local</span>/mysql/data</span><br><span class="line"><span class="comment">#完成之后会有一个临时密码</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置ssl</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bin/mysql_ssl_rsa_setup</span><br><span class="line">bin/mysql_ssl_rsa_setup --datadir=/usr/<span class="built_in">local</span>/mysql/data</span><br></pre></td></tr></table></figure>
</li>
<li><p>编辑配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/my.cnf</span><br><span class="line"></span><br><span class="line">[client]</span><br><span class="line">port = 3306</span><br><span class="line">socket = /tmp/mysql.sock</span><br><span class="line">default-character-set=utf8</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">port = 3306</span><br><span class="line">socket = /tmp/mysql.sock</span><br><span class="line">basedir = /home/wxl/date/mysql </span><br><span class="line">datadir = /home/wxl/date/mysql/data</span><br><span class="line">user = mysql</span><br><span class="line">default-storage-engine=InnoDB</span><br><span class="line">character_set_server =utf8</span><br><span class="line"><span class="comment">#建库时默认字符集</span></span><br><span class="line">collation-server=utf8_general_ci</span><br><span class="line">[mysqld_safe]</span><br><span class="line">log-error=/home/wxl/date/mysql/data/mysql-error.log</span><br><span class="line">pid-file=//home/wxl/date/mysql/data/mysqld.pid</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动mysql</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bin/mysqld_safe --user=mysql &amp;</span><br></pre></td></tr></table></figure>
</li>
<li><p>复制mysql启动脚本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp support-files/mysql.server /etc/init.d/mysql.server</span><br><span class="line"><span class="comment">#之后可以使用 /etc/init.d.mysql.server start|stop|restart 来启动、关闭、重启mysql</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>登录mysql并修改临时密码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br><span class="line">&gt; <span class="built_in">set</span> password <span class="keyword">for</span> root@localhost = password(<span class="string">&#x27;123&#x27;</span>);  </span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>win10下搭建php+mysql+apache开发环境</title>
    <url>/posts/fcb57d42/</url>
    <content><![CDATA[<p>版本说明：win10，php：php-7.1.28-Win32-VC14-x64，mysql：5.7.24，apcche：httpd-2.4.39-o102r-x64-vc14</p>
<a id="more"></a>

<h2 id="安装前准备"><a href="#安装前准备" class="headerlink" title="安装前准备"></a><strong>安装前准备</strong></h2><ol>
<li><p>分<em>别到官网下载相应版本：</em></p>
<ul>
<li>php： <a href="https://windows.php.net/download">https://windows.php.net/download</a> </li>
<li>apche： <a href="http://www.apachelounge.com/download/">http://www.apachelounge.com/download/</a></li>
<li>mysql： <a href="https://dev.mysql.com/downloads/mysql/5.7.html#downloads">https://dev.mysql.com/downloads/mysql/5.7.html#downloads</a></li>
</ul>
</li>
</ol>
<ol start="2">
<li><p><em>新建一个文件夹取名为“wamp”</em></p>
</li>
<li><p><em>注意事项：</em></p>
<p>一定要下载符合自己电脑安装环境的版本，选择vc14一定要知道自己的电脑是否安装了vc14相关的库，如果版本不匹配会导致无法安装成功，并且CGI也无法正常运行</p>
</li>
</ol>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a><strong>安装</strong></h2><ol>
<li><h3 id="apache安装与配置"><a href="#apache安装与配置" class="headerlink" title="apache安装与配置"></a><em>apache安装与配置</em></h3><p>将下载好的压缩包解压到wamp文件夹下，全部解压完成后如图<img src="/images/fcb57d42/%E8%A7%A3%E5%8E%8B%E5%AE%8C%E6%88%90.png" alt="解压"></p>
</li>
<li><h3 id="配置apache的http-conf文件"><a href="#配置apache的http-conf文件" class="headerlink" title="配置apache的http.conf文件"></a><em>配置apache的http.conf文件</em></h3><p>修改文件中apache的目录，如下图：<img src="/images/fcb57d42/apachepeizh.png" alt="apache配置"></p>
<p>以管理员身份运行cmd，然后进入到apache的bin目录下执行 httpd -k install ，然后会生成一个apache2.4的服务，(可用httpd -t 检查配置文件是否有错),如图：<img src="/images/fcb57d42/cmd.jpg" alt="cmd"></p>
<p>开启Apache服务的命令：net start Apache2.4 </p>
<p>关闭Apache服务的命令：net stop Apache2.4</p>
</li>
<li><h3 id="php配置"><a href="#php配置" class="headerlink" title=".php配置"></a><em>.php配置</em></h3><ol>
<li><p>修改htrpd.conf文件，在文件末尾添加如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AddHandler application&#x2F;x-httpd-php .php</span><br><span class="line">LoadModule php7_module &quot;F:&#x2F;wamp&#x2F;php&#x2F;php7apache2_4.dll&quot;</span><br><span class="line">AddType application&#x2F;x-httpd-php .php .html .htm</span><br><span class="line">PHPIniDir &quot;F:&#x2F;wamp&#x2F;php&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在PHP根目录找到php.ini-production文件，复制一份并重命名为php.ini，打开php.ini文件，将extension_dir=”ext”修改为extension_dir = “F:/wamp/php/ext”，并去掉前面的分号，然后根据自己需求开启相关php扩展，如下图所示<img src="/images/fcb57d42/phpini.png" alt="phpkuozhan"></p>
</li>
</ol>
</li>
<li><h3 id="MySQL配置"><a href="#MySQL配置" class="headerlink" title="MySQL配置"></a><em>MySQL配置</em></h3><ol>
<li><p>在MySQL目录下新建一个文件，名为my.ini，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[mysql]</span><br><span class="line">设置mysql客户端默认字符集</span><br><span class="line">default-character-set&#x3D;utf8</span><br><span class="line">[mysqld]</span><br><span class="line">设置3306端口</span><br><span class="line">port &#x3D; 3306</span><br><span class="line">设置mysql的安装目录</span><br><span class="line">basedir&#x3D;F:\wamp\mysql-5.7.24-winx64</span><br><span class="line">设置mysql数据库的数据的存放目录</span><br><span class="line">datadir&#x3D;F:\wamp\mysql-5.7.24-winx64\data</span><br><span class="line">允许最大连接数</span><br><span class="line">max_connections&#x3D;200</span><br><span class="line">服务端使用的字符集默认为8比特编码的latin1字符集</span><br><span class="line">character-set-server&#x3D;utf8</span><br><span class="line">创建新表时将使用的默认存储引擎</span><br><span class="line">default-storage-engine&#x3D;INNODB</span><br></pre></td></tr></table></figure>
</li>
<li><p>以管理员身份启动cmd执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysqld --initialize-insecure --user=mysql</span><br></pre></td></tr></table></figure>



</li>
</ol>
</li>
</ol>
<ol start="3">
<li><p>执行mysqld -install 来注册MySQL服务<img src="/images/fcb57d42/%E6%B3%A8%E5%86%8C.png" alt="mysql注册"></p>
</li>
<li><p>用net start msyql来启动MySQL</p>
<p>然后到data目录下，找到一个后缀为.err的文件打开，查看MySQL初始密码，下方红框中的即为临时密码<img src="/images/fcb57d42/MySQL.jpg" alt="mysqlmima"></p>
</li>
<li><p>输入mysql -uroot -p临时密码复制输入登录数据库，之后执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> password <span class="keyword">for</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>=password(<span class="string">&#x27;newpasswd&#x27;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改密码之后， 执行flush privileges;刷新权限后退出。<img src="/images/fcb57d42/%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81.png" alt="flush"></p>
</li>
</ol>
<h2 id="检测"><a href="#检测" class="headerlink" title="检测"></a><strong>检测</strong></h2><p>在apache的htdocs目录下新建一个1.php的文件，输入以下内容</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$servername = <span class="string">&quot;localhost&quot;</span>;</span><br><span class="line">$username = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">$password = <span class="string">&quot;newpasswd&quot;</span>;</span><br><span class="line"><span class="comment">// 创建连接</span></span><br><span class="line">$conn = mysqli_connect($servername, $username, $password);</span><br><span class="line"><span class="comment">// 检测连接</span></span><br><span class="line"><span class="keyword">if</span> (!$conn) &#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&quot;Connection failed: &quot;</span> . mysqli_connect_error());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;连接成功&quot;</span>;</span><br><span class="line">phpinfo();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>在浏览器输入127.0.0.1/1.php 可看到如下结果<img src="/images/fcb57d42/%E6%A3%80%E6%9F%A5.png" alt="检查"></p>
]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>php</tag>
        <tag>apache</tag>
      </tags>
  </entry>
</search>
